<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hard Division - A Minimalist Turn-Based Roguelike</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'VT323', monospace;
            background-color: #000; /* Pure black background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #e2e8f0;
            overflow: hidden; /* Prevent body scrollbars */
        }
        
        .game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            position: relative;
            /* Move the entire content area slightly left to center both game and chat */
            transform: translateX(-10vw);
        }

        .game-container {
            position: relative;
            flex-grow: 1;
        }

        .message-area {
            position: absolute;
            right: 0;
            width: 40%;
            height: 73vh;
            bottom: 0;
            z-index: 2;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 20px;
            pointer-events: none;
        }

        .event-message {
            font-family: 'VT323', monospace;
            color: #e2e8f0;
            font-size: 24px;
            text-align: right;
            opacity: 0.8;
            animation: fadeIn 0.3s ease-out;
        }

        .event-messages-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 10px;
            z-index: 3;
            pointer-events: none;
        }

        .event-title {
            padding: 5px 15px;
            background-color: #000000;
            font-family: 'VT323', monospace;
            color: #e2e8f0;
            font-size: 24px;
            animation: fadeIn 0.3s ease-out;
        }

        .event-message {
            padding: 5px 15px;
            background-color: #000000;
            font-family: 'VT323', monospace;
            color: #e2e8f0;
            font-size: 20px;
            animation: fadeIn 0.3s ease-out;
            opacity: 0.8;
        }

        .kill-message {
            font-family: 'VT323', monospace;
            color: #e2e8f0;
            font-size: 24px;
            text-align: right;
            opacity: 0.8;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 0.8; transform: translateY(0); }
        }

        .dialogue-message {
            color: #FFFFFF; /* White text */
            border-radius: 10px;
            padding: 8px 12px; /* Smaller padding */
            margin-bottom: 4px; /* Smaller line spacing */
            align-self: flex-end; /* Align to the right for player messages */
            max-width: 80%; /* Don't take full width */
            font-size: 1.2rem; /* Smaller text */
            line-height: 1.3; /* Smaller line height */
            word-wrap: break-word; /* Ensure long words break */
            /* Animation properties */
            opacity: 0;
            transform: translateY(100%);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out; /* Smooth transition for slide-in */
        }

        /* Activity log styles */
        .activity-log-entry {
            color: #FFFFFF;
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 4px;
            font-size: 1.3rem;
            line-height: 1.4;
            word-wrap: break-word;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .activity-log-entry.dimmed {
            opacity: 0.4;
        }

        .activity-log-entry .player-name {
            font-weight: bold;
        }

        .activity-log-entry .enemy-name {
            font-weight: bold;
        }

        .activity-log-entry .damage-comparison {
            font-size: 0.9rem;
            margin-top: 2px;
            opacity: 0.8;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center canvas inside */
            background-color: #000;
            position: relative;
            flex-grow: 1; /* Takes remaining space */
            height: 100%; /* Fill parent height */
            /* Use flexbox properties to make it square and center */
            /* Max width/height will be determined by the smaller of available space */
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 1 / 1; /* Ensure it's square */
            margin: auto; /* Center itself within the flex container */
        }

        canvas {
            background-color: #000;
            border: none; /* No border for the canvas itself */
            touch-action: none;
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensure canvas scales within the square container */
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .side-panel {
                width: 180px; /* Slightly narrower on medium screens */
            }
        }

        @media (max-width: 768px) {
            .game-wrapper {
                flex-direction: column; /* Stack vertically on smaller screens */
                height: auto;
            }
            .side-panel {
                width: 100%; /* Full width when stacked */
                height: auto; /* Allow height to be determined by content or flex */
                flex-grow: 1; /* Allow it to grow to fill space */
                border-right: none;
                border-left: none;
                border-bottom: 2px solid #333; /* Separator when stacked */
                flex-direction: column-reverse; /* Messages appear at bottom */
                overflow-y: auto; /* Allow scrolling when stacked */
            }
            .dialogue-area {
                order: 2; /* Put dialogue below game on mobile */
            }
            .right-panel {
                order: 3; /* Put right panel below dialogue on mobile */
            }
            .game-container {
                width: 100%;
                height: auto; /* Allow height to be determined by canvas */
                order: 1; /* Put game container at the top on mobile */
                max-width: 100vw; /* Remove max-width constraints for mobile */
                max-height: none; /* Remove max-height constraints for mobile */
            }
            /* Messages should still align to the right in the dialogue area, even on mobile */
            .dialogue-message {
                align-self: flex-end;
            }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div id="eventMessagesContainer" class="event-messages-container">
            <div id="eventTitle" class="event-title"></div>
        </div>
        <div id="gameContainer" class="game-container">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div id="messageArea" class="message-area"></div>
        <div id="dialogueArea" class="dialogue-area"></div>
        <div id="rightPanel" class="right-panel"></div>
    </div>

    <script>
        // Game constants
        const CANVAS_WIDTH_INITIAL = 730; // Initial canvas width for logical scaling
        const CANVAS_HEIGHT_INITIAL = 730; // Initial canvas height for logical scaling

        const MAX_VISIBLE_TILES_LEVEL1 = 7; // Adjusted for closer zoom at level 1
        // MODIFIED: Decreased maximum zoom out by half (from 25 to 12.5)
        const MIN_VISIBLE_TILES_MAX_LEVEL = 12.5;
        const ZOOM_LEVELS_EFFECTIVE = 30;

        // Score box constants
        const SCORE_BOX_WIDTH = 120;
        const SCORE_BOX_HEIGHT = 40;
        const SCORE_BOX_PADDING = 5;
        const SCORE_BOX_MARGIN = 0;

        // Health-based visual scaling constants (now act as thresholds, not caps)
        const PLAYER_VISUAL_HEALTH_THRESHOLD = 73;
        const ENEMY_VISUAL_HEALTH_THRESHOLD = 73;
        const MIN_HEALTH_FOR_VISUAL_EFFECTS = 1;
        const MIN_OPACITY_AT_LOW_HEALTH = 0.9; // Increased starting opacity again
        // New constants for Flow bias
        const BASE_FLOW_FOR_BIAS = 1.0;
        const FLOW_BIAS_STRENGTH = 0.5;

        // New constants for player death animation
        const PLAYER_DEATH_PARTICLE_COUNT = 50;
        const PLAYER_DEATH_PICKUP_VALUE_PER_CHUNK = 1;
        const PLAYER_DEATH_EXPLOSION_DURATION = 3000;
        const PLAYER_DEATH_PARTICLE_SPREAD_FACTOR = 2.5;

        // New constants for explosion and pickup scattering based on damage
        const ENEMY_DEATH_EXPLOSION_BASE_SPREAD = 1.0;
        const ENEMY_DEATH_EXPLOSION_DAMAGE_SPREAD_MULTIPLIER = 0.1; // Adjust this value to control how much damage affects spread
        const PICKUP_SCATTER_BASE_SPREAD = 1.5; // Original value for pickup scatter
        const PICKUP_SCATTER_DAMAGE_MULTIPLIER = 0.15; // Adjust this value to control how much damage affects pickup scatter

        // Mathematical symbols for player death
        const MATH_SYMBOLS = ['+', '-', '*', '/', '=', '>', '<', '%', '&', '!', '?', '^', '~', '|', '(', ')', '[', ']', '{', '}'];

        // Tile size calculation

        // Tile types
        const TILE_WALL = 0;
        const TILE_FLOOR = 1;
        const TILE_STAIRS = 2;

        // Colors (consistent across gameplay and UI)
        let COLOR_WALL = '#222222'; // Darkened
        let COLOR_FLOOR = '#111111'; // Darkened
        const FIXED_COLOR_PLAYER = '#0000CC';
        const FIXED_COLOR_STAIRS = '#38a169';
        const FIXED_COLOR_ENEMY = '#8B0000';
        const VINTAGE_GREEN = '#00FF00';

        // Name generation utilities from namegen.html - exact implementation from namegen.html
        function hasVowel(str) {
          return /[aeiouyAEIOUY]/.test(str);
        }

        // Massively Expanded Phoneme lists from namegen.html
        const commonWordPhonemes = {
          start: [
            // Pure vowel starts
            'A', 'E', 'I', 'O', 'U', 'Ya', 'Ye', 'Yo', 'Yu', 'Ae', 'Io', 'Ou', 'Ui', 'Au', 'Ei',
            // Common Object/Concept Starts
            'Air', 'Arm', 'Box', 'Book', 'Card', 'Chair', 'Cloud', 'Desk', 'Door', 'Dust', 'Earth', 'Fire', 'Fork', 'Glass',
            'Hand', 'Head', 'Home', 'Hour', 'Key', 'Lamp', 'Leaf', 'Light', 'Line', 'Lock', 'Moon', 'Moun', 'Name', 'Page',
            'Pen', 'Pipe', 'Plan', 'Plas', 'Plate', 'Rain', 'Road', 'Rock', 'Room', 'Rope', 'Sand', 'Ship', 'Shoe', 'Sky',
            'Soap', 'Sofa', 'Star', 'Stee', 'Ston', 'Sun', 'Tab', 'Tail', 'Time', 'Tool', 'Top', 'Tree', 'Wall', 'Wat',
            'Whee', 'Wind', 'Wire', 'Wood', 'Word', 'Bell', 'Bowl', 'Brush', 'Cable', 'Chain', 'Coin', 'Comb', 'Couch', 'Cup',
            'Curtain', 'Dish', 'Drawer', 'Drum', 'Fence', 'Flag', 'Flute', 'Frame', 'Glove', 'Grain', 'Grape', 'Guard', 'Harp',
            'Hinge', 'Hole', 'Hook', 'Horn', 'Jacket', 'Jar', 'Jewel', 'Joint', 'Juice', 'Kettle', 'Kite', 'Knob', 'Lace', 'Ladder',
            'Lake', 'Lens', 'Lever', 'Lid', 'Loom', 'Loud', 'Magnet', 'Mask', 'Match', 'Metal', 'Meter', 'Mirror', 'Mist', 'Mop',
            'Mug', 'Nail', 'Net', 'Nook', 'Nut', 'Oar', 'Pad', 'Paint', 'Pan', 'Path', 'Pearl', 'Pillow', 'Pin', 'Plane',
            'Pond', 'Pool', 'Pot', 'Pouch', 'Pound', 'Pulp', 'Pump', 'Rack', 'Rail', 'Rake', 'Ramp', 'Ring', 'Rod', 'Roof',
            'Root', 'Rug', 'Ruler', 'Sack', 'Scale', 'Scoop', 'Screen', 'Seal', 'Seat', 'Shade', 'Shelf', 'Shell', 'Shield', 'Sign',
            'Slab', 'Slate', 'Sleeve', 'Slide', 'Slot', 'Smoke', 'Snare', 'Snow', 'Spade', 'Spoon', 'Spot', 'Spout', 'Spring',
            'Spool', 'Stair', 'Stamp', 'Stick', 'Stool', 'Strap', 'Straw', 'Stream', 'String', 'Strip', 'Stud', 'Swarm', 'Swing',
            'Switch', 'Table', 'Tank', 'Tape', 'Target', 'Thorn', 'Thread', 'Thumb', 'Tile', 'Tong', 'Torch', 'Tower', 'Track',
            'Train', 'Trap', 'Tray', 'Trowel', 'Trunk', 'Tube', 'Tug', 'Tune', 'Turf', 'Twine', 'Unit', 'Urn', 'Valve', 'Vase',
            'Veil', 'Vent', 'Vest', 'Vial', 'Vise', 'Wagon', 'Web', 'Wedge', 'Whale', 'Whirl', 'Wick', 'Wing', 'Wrench', 'Yoke',
            'Zest', 'Zone', 'Zorb',
            // Company Name Starts
            'Aero', 'Airb', 'Alib', 'Amaz', 'Amgen', 'Anhe', 'Astra', 'Audi', 'Baidu', 'Bayer', 'Berk', 'Black', 'Boe',
            'Canon', 'Cisco', 'Coca', 'Comc', 'Daim', 'Dell', 'Disn', 'DuPont', 'Face', 'Fid', 'Ford',
            'Gen', 'Gile', 'Goog', 'Hon', 'HP', 'Huan', 'Hyun', 'Intel', 'Master',
            'McDon', 'Merck', 'Meta', 'Micro', 'Neste', 'Nike', 'Nint', 'Oracle', 'Pana', 'Peps', 'Pfiz', 'Phil',
            'Qual', 'Riche', 'Roya', 'Sam', 'Siem', 'Spot', 'Starb', 'Suba', 'Targ', 'Tenc', 'Tes', 'Teva', 'Toyota',
            'Uber', 'Unile', 'Volks', 'Walm', 'Walt', 'Xiaom', 'Yaho', 'Yelp', 'Zara', 'Zoom', 'Zurich',
            // Country/City Name Starts
            'Aba', 'Abu', 'Accra', 'Adel', 'Addis', 'Agra', 'Algiers', 'Amman', 'Amst', 'Anka', 'Arg', 'Ashg', 'Astana', 'Ath',
            'Aus', 'Baku', 'Ban', 'Bang', 'Bei', 'Beir', 'Belg', 'Belm', 'Ber', 'Bog', 'Boha', 'Bol', 'Bra', 'Bras', 'Brat',
            'Braz', 'Bru', 'Buda', 'Bue', 'Bukh', 'Cai', 'Canb', 'Cara', 'Casab', 'Che', 'Chi', 'Copen', 'Col', 'Cona', 'Cop',
            'Coru', 'Cro', 'Daka', 'Dam', 'Dar', 'Del', 'Den', 'Dhaka', 'Doha', 'Dub', 'Edin', 'Egy', 'Eth', 'Fin', 'Fra',
            'Fuji', 'Gab', 'Gabo', 'Ger', 'Gha', 'Gree', 'Guat', 'Hano', 'Har', 'Hel', 'Ho', 'Hon', 'Hung', 'Ice', 'Ind',
            'Ira', 'Ire', 'Isr', 'Ista', 'Ita', 'Jak', 'Jam', 'Jap', 'Jeru', 'Johan', 'Jor', 'Kab', 'Kam', 'Kar', 'Kaz',
            'Ken', 'Kha', 'Kie', 'Kin', 'Kish', 'Kua', 'Kuw', 'Lag', 'Lao', 'Leb', 'Lis', 'Ljub', 'Lon', 'Los', 'Luanda',
            'Madr', 'Mal', 'Man', 'Manil', 'Mapu', 'Mex', 'Min', 'Monro', 'Monte', 'Mos', 'Mumb', 'Mus', 'Nair', 'Nass', 'Nep',
            'New', 'Nic', 'Nis', 'Nor', 'Os', 'Ott', 'Pak', 'Pal', 'Pan', 'Par', 'Peki', 'Peru', 'Phil', 'Pol', 'Port',
            'Prag', 'Pret', 'Puer', 'Qat', 'Quito', 'Rab', 'Rey', 'Riga', 'Riy', 'Rom', 'Rus', 'San', 'Sao', 'Sar', 'Sau',
            'Scot', 'Seo', 'Ser', 'Sing', 'Sko', 'Slo', 'Sof', 'Sou', 'Spa', 'Sri', 'Stoc', 'Sud', 'Swe', 'Swit', 'Syd',
            'Syr', 'Tai', 'Tan', 'Teh', 'Thai', 'Thi', 'Tir', 'Tok', 'Trip', 'Tun', 'Tur', 'Ugan', 'Ukra', 'Uni', 'Uru',
            'Val', 'Ven', 'Vie', 'Viet', 'Vil', 'War', 'Was', 'Wel', 'Wien', 'Yem', 'Zag', 'Zim'
          ].filter(hasVowel),

          middle: [
            'a', 'e', 'i', 'o', 'u', 'y', 'an', 'en', 'in', 'on', 'un', 'am', 'em', 'im', 'om', 'um',
            'ar', 'er', 'ir', 'or', 'ur', 'as', 'es', 'is', 'os', 'us', 'at', 'et', 'it', 'ot', 'ut',
            'ax', 'ex', 'ix', 'ox', 'ux', 'ay', 'ey', 'oy', 'ow', 'ou', 'ea', 'ee', 'ie', 'oa', 'oo'
          ],

          end: [
            'a', 'e', 'i', 'o', 'u', 'y', 'ah', 'al', 'an', 'ar', 'as', 'at', 'ay', 'el', 'en', 'er',
            'es', 'et', 'il', 'in', 'ir', 'is', 'it', 'ol', 'on', 'or', 'os', 'ot', 'ul', 'un', 'ur',
            'us', 'ut', 'ice', 'ide', 'ile', 'ine', 'ing', 'ion', 'ive', 'ize', 'ode', 'oke', 'ole',
            'ome', 'one', 'ore', 'ose', 'ote', 'ove', 'owl', 'own', 'ule', 'une', 'ure'
          ].filter(hasVowel)
        };

        function randomFrom(array) {
          if (array.length === 0) return '';
          return array[Math.floor(Math.random() * array.length)];
        }

        function buildName(phonemes, syllables = 3) {
          let name = '';
          if (syllables <= 0) return '';

          // Always start with a 'start' phoneme
          name += randomFrom(phonemes.start);

          // Add 'middle' phonemes for intermediate syllables
          for (let i = 1; i < syllables - 1; i++) {
            name += randomFrom(phonemes.middle);
            // 20% chance to repeat a middle phoneme
            if (Math.random() < 0.2 && i < syllables - 2) {
              name += randomFrom(phonemes.middle);
            }
          }

          // End with an 'end' phoneme for the last syllable, if more than 1 syllable
          if (syllables > 1) {
                name += randomFrom(phonemes.end);
            }

            // Capitalize the first letter of the generated name
            return name.charAt(0).toUpperCase() + name.slice(1);
        }

        function generateAgentName() {
          let firstName, lastName;
          const MAX_COMBINED_LENGTH = 9; // Maximum total characters excluding the space
          const MIN_COMBINED_LENGTH = 5; // Minimum total characters excluding the space

          do {
            // Randomly choose 1 or 2 syllables for the first name
            const firstSyllables = Math.floor(Math.random() * 2) + 1; // Generates 1 or 2
            // Randomly choose 1 or 2 syllables for the last name
            const lastSyllables = Math.floor(Math.random() * 2) + 1; // Generates 1 or 2

            firstName = buildName(commonWordPhonemes, firstSyllables);
            lastName = buildName(commonWordPhonemes, lastSyllables);

          } while (firstName.length + lastName.length > MAX_COMBINED_LENGTH ||
                   firstName.length + lastName.length < MIN_COMBINED_LENGTH ||
                   !hasVowel(firstName) || !hasVowel(lastName));

          return `${firstName} ${lastName}`;
        }

        // Game state variables are declared below with 'let' and initialized in initGame()
        // Player and enemy objects now include thrust animation properties

        // Activity log state
        let activityLog = [];
        const MAX_ACTIVITY_LOG_ENTRIES = 10;

        // New global state for death animation
        let deathAnimationActive = false;
        let deathAnimationStartTime = 0;
        const DEATH_ZOOM_DURATION = 1000; // Reduced for quicker zoom
        const DEATH_SLOW_MOTION_FACTOR = 0.2;
        const DEATH_ZOOM_TARGET_TILE_SCALE = 1.0; // Reduced for less zoom-in after death
        let timeScale = 1; // Global time scale for animations

        // Title overlay constants
        const OVERLAY_ZOOM_DURATION = 1000;
        const OVERLAY_FADE_DURATION = 2000;
        const GAME_START_OVERLAY_DURATION = OVERLAY_ZOOM_DURATION + OVERLAY_FADE_DURATION;
        const INITIAL_OVERLAY_FONT_FACTOR = 0.12;
        const MAX_OVERLAY_FONT_FACTOR = 0.15;

        // New constants for game start/restart zoom out
        // MODIFIED: Decreased zoom out rate by half (from 3000 to 6000)
        const GAME_START_ZOOM_OUT_DURATION = 6000;
        const GAME_START_INITIAL_ZOOM_FACTOR = 2.5; // Decreased for less initial zoom
        const RESTART_TEXT_EXPLOSION_DURATION = 2000; // Increased duration for slower explosion (This constant is globally accessible)

        // Game start zoom state
        let gameStartZoomStartTime = 0;

        // Title screen state
        let gameStartedOverlayStartTime = 0;

        // Restart text animation state
        let restartTextAnimationActive = false;
        let restartTextAnimationStartTime = 0;
        let restartTextParticles = [];

        // Game running state (always true after initial load now)
        let isGameRunning = true; // Game is always running after initial load now

        // Game statistics
        let hitsDealt = 0;
        let hitsTaken = 0;
        let stepsTaken = 0;
        let totalDamageDealt = 0;
        const HEALTH_LOSS_INTERVAL = 37;

        // Auto-movement state
        let autoMode = null;
        let autoMovePath = [];
        let currentPathIndex = 0;
        let autoMoveTimeoutId = null;

        // Auto-move speed variables
        const DEFAULT_AUTO_MOVE_SPEED = 100;
        let AUTO_MOVE_SPEED = DEFAULT_AUTO_MOVE_SPEED;
        const COMBAT_MOVE_DELAY = 500;
        const PICKUP_COLLECTION_RADIUS = 7;
        const DIRECT_PICKUP_RADIUS = 1.5;

        // Damage animation duration constants
        const MIN_DAMAGE_ANIM_DURATION = 300;
        const MAX_DAMAGE_ANIM_DURATION = 1000;
        const MAX_DAMAGE_VALUE_FOR_ANIM_SCALE = 10;

        // Combat balancing constant
        const COMBAT_BIAS_STRENGTH = 0.7;

        // High Score Data (kept for internal tracking, not displayed)
        let highScores = [];
        const MAX_HIGH_SCORES = 7;
        const HIGH_SCORES_STORAGE_KEY = 'roguelikeHighScores';

        // Global variables
        let gameCanvas;
        let ctx;
        let gameMap;
        let dynamicMapWidth;
        let dynamicMapHeight; 
        let player;
        let stairs;
        let enemies;
        let currentLevel;
        let gameOver;
        let dynamicTileSize;
        let visitedTiles;
        let gameStartZoomActive;
        let gameStartedOverlayActive;
        
        // Animation frame ID for controlling the game loop
        let animationFrameId = null;

        // --- New constants and variables for event detection and display ---
        let gameHistory = []; // Stores snapshots for event detection
        const HISTORY_LENGTH = 15; // Number of turns to keep in history for analysis

        let activeEventMessages = []; // Messages currently displayed on screen

        // Event Constants
        const SURROUNDED_THRESHOLD = 3; // Number of adjacent enemies for "Player Surrounded"
        const NEAR_DEATH_HEALTH_RATIO = 0.2; // Player health below this ratio for "Near-Death Recovery" start
        const RECOVERY_HEALTH_GAIN_RATIO = 0.3; // Player gains this ratio of max health after low point for "Near-Death Recovery" end
        const LONG_FIGHT_TURNS_THRESHOLD = 10; // Turns for "Long Fight"
        const KILLING_SPREE_COUNT = 3; // Enemies killed for "Killing Spree"
        const ONE_SHOT_MIN_HEALTH = 5; // Minimum enemy health for "One-Shot Kill"
        const HIGH_VALUE_PICKUP_THRESHOLD = PLAYER_VISUAL_HEALTH_THRESHOLD * 0.5; // Collect 50% of max health in pickups for "High-Value Pickups"
        const PICKUP_SPREE_TURNS = 3; // Turns to check for "High-Value Pickups"
        const ENEMY_OVERWHELM_THRESHOLD = PLAYER_VISUAL_HEALTH_THRESHOLD * 1.5; // Combined health of adjacent enemies for "Enemy Overwhelm"
        const RETREAT_TURNS = 3; // Turns to check for "Strategic Retreat"
        const RETREAT_DISTANCE_INCREASE = 2; // Tiles distance increase for "Strategic Retreat"
        const UNSTOPPABLE_TURNS = 5; // Turns to check for "Unstoppable Force"
        const EXPLORER_TURNS = 5; // Turns to check for "Map Explorer"
        const EXPLORER_TILE_PERCENTAGE = 0.05; // 5% of map revealed for "Map Explorer"
        const CORNERED_THRESHOLD = 6; // 6 out of 8 directions blocked for "Cornered"
        const PERFECT_DODGE_THRESHOLD = 0; // No damage taken in a combat turn
        const CRITICAL_STRIKE_DAMAGE_MULTIPLIER = 2.0; // Damage multiplier for critical strike

        const EVENT_TEXT_DURATION = 2000; // Duration for event messages

        // Event tracking flags (to prevent spamming)
        let eventFlags = {
            playerSurrounded: false,
            nearDeathRecovery: false,
            longFight: false,
            highValuePickups: false,
            enemyOverwhelm: false,
            strategicRetreat: false,
            killingSpree: false,
            unstoppableForce: false,
            mapExplorer: false,
            cornered: false,
            stairsBlocked: false,
            oneShotKill: false,
            perfectDodge: false, // New flag
            criticalStrike: false, // New flag
            flawlessVictory: false, // New flag
        };

        // Per-turn tracking variables (reset after each turn)
        let enemiesKilledThisTurn = 0;
        let damageDealtThisTurn = 0; // Cumulative damage dealt by player in current turn
        let hitsTakenThisTurn = 0; // Cumulative hits taken by player in current turn
        let totalPickupValueCollectedThisTurn = 0; // Cumulative pickup value collected in current turn
        let combatOccurredThisTurn = false; // New: track if any combat happened this turn
        let playerTookDamageInCombatThisTurn = false; // New: track if player took damage in combat this turn

        visitedTiles = []; // 2D array, true if visited

        // --- Constants for HIGH_SCORE auto-mode ---
        const HIGH_SCORE_LOW_HEALTH_THRESHOLD_RATIO = 0.3; // Player health below this will prioritize pickups
        const HIGH_SCORE_WEAK_ENEMY_THRESHOLD_RATIO = 1.0; // Enemy is "weak" if its health is <= player.health * this ratio

        // --- End new constants and variables ---

        // Get reference to the message areas
        const messageArea = document.getElementById('messageArea');
        const eventTitle = document.getElementById('eventTitle');
        const MAX_MESSAGES = 10; // Max messages to display in the message area

        // Event and message state
        let currentEventTitle = '';
        let eventTitleTimeout = null;
        const EVENT_TITLE_DURATION = 2000; // Duration to show event title
        const PLAYER_DIALOGUE = {
            "Player Surrounded": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Near-Death Recovery": "Health matrix restored. Too bad there's no patch for a broken heart.",
            "Long Fight": "The algorithm is flowing. A rare moment of positive progression in a negatively charged existence.",
            "One-Shot Kill!": "Divided and conquered. Just like my soul.",
            "High-Value Pickups": "Optimizing my intake. Every bit counts when you're running on empty, inside and out.",
            "Enemy Overwhelm": "My vitals are degrading. This feels... logarithmically familiar.",
            "Strategic Retreat": "Holding my ground. A constant, unlike the variables in my life.",
            "Killing Spree": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Unstoppable Force": "I'm an integer, moving forward, indivisible. Can't say the same for my past.",
            "Map Explorer": "A new tangent. Maybe this one doesn't lead to another fractured dimension.",
            "Cornered": "Figures. Just another cul-de-sac in this infinite loop of despair.",
            "Stairs Blocked": "Venturing into the unknown. A lot like trying to understand human emotion.",
            "Perfect Dodge!": "Calculated. Every variable accounted for, unlike my past.",
            "Critical Strike!": "An eye for an eye, a byte for a byte. The equation balances, even if my heart never will.",
            "Flawless Victory!": "All threats nullified. If only I could clear the cache of my memories so easily.",
            "Multi-Kill!": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Finisher!": "Divided and conquered. Just like my soul.",
            "Precision Strike!": "Calculated. Every variable accounted for, unlike my past.",
            "Overkill!": "Excessive force. A bit like how love subtracted everything from me.",
            "Retribution!": "An eye for an eye, a byte for a byte. The equation balances, even if my heart never will.",
            "Combat Ready!": "Systems online. Ready to integrate some pain, though my emotional processors are still offline.",
            "Defensive Stance!": "Holding my ground. A constant, unlike the variables in my life.",
            "Hidden Path Found!": "A new tangent. Maybe this one doesn't lead to another fractured dimension.",
            "Dead End!": "Figures. Just another cul-de-sac in this infinite loop of despair.",
            "Map Cleared!": "All threats nullified. If only I could clear the cache of my memories so easily.",
            "Uncharted Territory!": "Venturing into the unknown. A lot like trying to understand human emotion.",
            "Full Recovery!": "Health matrix restored. Too bad there's no patch for a broken heart.",
            "Resourceful!": "Optimizing my intake. Every bit counts when you're running on empty, inside and out.",
            "Health Drain!": "My vitals are degrading. This feels... logarithmically familiar.",
            "Level Up!": "Another iteration. The numbers grow, but the emptiness remains a constant.",
            "Momentum!": "The algorithm is flowing. A rare moment of positive progression in a negatively charged existence.",
            "Unstoppable!": "I'm an integer, moving forward, indivisible. Can't say the same for my past."
        };

        /**
         * Converts a hexadecimal color string to HSL (Hue, Saturation, Lightness) values.
         * @param {string} hex - The hexadecimal color string (e.g., "#RRGGBB").
         * @returns {Array<number>} An array [h, s, l] where h is 0-360, s and l are 0-100.
         */
        function hexToHsl(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            r /= 255;
            g /= 255;
            b /= 255;

            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [h * 360, s * 100, l * 100];
        }

        /**
         * Converts HSL (Hue, Saturation, Lightness) values to a hexadecimal color string.
         * @param {number} h - Hue (0-360).
         * @param {number} s - Saturation (0-100).
         * @param {number} l - Lightness (0-100).
         * @returns {string} The hexadecimal color string (e.g., "#RRGGBB").
         */
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0'); // convert to Hex and pad with 0
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        /**
         * Calculates an interpolated color based on a base hexadecimal color and a health ratio.
         * Color becomes darker and muted with lower health ratio, and bright and rich (not lightened) with higher health ratio.
         * @param {string} baseHexColor - The base hexadecimal color (e.g., "#0000CC").
         * @param {number} currentValue - The current health value.
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {string} The interpolated hexadecimal color.
         */
        function getHealthColor(baseHexColor, currentValue, thresholdValue) {
            const [h, s_base_original, l_base_original] = hexToHsl(baseHexColor);

            // Calculate ratio, capping at 1.0 to ensure visuals don't exceed 100% intensity
            const clampedRatio = Math.max(0, Math.min(1, currentValue / thresholdValue));

            // Define ranges for saturation and lightness based on desired effect
            // Low power: darker and muted (low saturation, low lightness)
            // High power: bright and rich (high saturation, mid lightness, not lightened)

            const minSaturation = 20; // Muted
            const maxSaturation = 90; // Bright/Rich (e.g., fire engine red would be high sat)

            const minLightness = 15; // Darker at low power
            const maxLightness = 50; // Mid-range for rich colors (like fire engine red)

            // Interpolate saturation: from muted to rich
            const s = minSaturation + (maxSaturation - minSaturation) * clampedRatio;

            // Interpolate lightness: from darker to mid-range.
            // When clampedRatio is 0, l = minLightness (15).
            // When clampedRatio is 1, l = maxLightness (50).
            const l = minLightness + (maxLightness - minLightness) * clampedRatio;

            return hslToHex(h, s, l);
        }

        /**
         * Calculates an interpolated font weight based on a value.
         * Font becomes thinner with lower value and thicker with higher value.
         * @param {number} currentValue - The current value (health, level, pickup amount).
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {number} The interpolated font weight (100-900).
         */
        function getFontWeight(currentValue, thresholdValue) {
            // Normalize value relative to the scaling range (MIN_HEALTH_FOR_VISUAL_EFFECTS to thresholdValue)
            const normalizedValue = Math.max(0, Math.min(1, (currentValue - MIN_HEALTH_FOR_VISUAL_EFFECTS) / (thresholdValue - MIN_HEALTH_FOR_VISUAL_EFFECTS)));

            const minWeight = 100; // Very thin
            const maxWeight = 900; // Full thickness (Black/Heavy)
            return Math.floor(minWeight + (maxWeight - minWeight) * normalizedValue);
        }

        /**
         * Calculates an interpolated opacity based on a value.
         * Opacity scales from MIN_OPACITY_AT_LOW_HEALTH at MIN_HEALTH_FOR_VISUAL_EFFECTS to full opacity at max value.
         * @param {number} currentValue - The current value (health, level, pickup amount).
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {number} The interpolated opacity (0.0 to 1.0).
         */
        function getOpacity(currentValue, thresholdValue) {
            // Normalize value relative to the scaling range (MIN_HEALTH_FOR_VISUAL_EFFECTS to thresholdValue)
            const normalizedValue = Math.max(0, Math.min(1, (currentValue - MIN_HEALTH_FOR_VISUAL_EFFECTS) / (thresholdValue - MIN_HEALTH_FOR_VISUAL_EFFECTS)));

            const minOpacity = MIN_OPACITY_AT_LOW_HEALTH; // Almost full transparency
            const maxOpacity = 1.0; // Full opacity
            return minOpacity + (maxOpacity - minOpacity) * normalizedValue;
        }

        /**
         * Adds an activity log entry for enemy kills.
         * @param {object} player - The player object.
         * @param {object} enemy - The enemy that was killed.
         * @param {number} playerDamage - Damage dealt by player to enemy.
         * @param {number} enemyDamage - Damage dealt by enemy to player.
         */
        /**
         * Updates the event title and message at the top of the screen
         * @param {string} eventName - The name of the event to display
         */
        function updateEventTitle(eventName) {
            // Update title
            currentEventTitle = eventName;
            eventTitle.textContent = eventName;
            eventTitle.style.display = 'block';
            
            // Clear any existing timeout
            if (eventTitleTimeout) {
                clearTimeout(eventTitleTimeout);
            }
            
            // Set new timeout to clear the title
            eventTitleTimeout = setTimeout(() => {
                eventTitle.style.display = 'none';
                currentEventTitle = '';
            }, EVENT_TITLE_DURATION);

            // Add event message under title
            if (PLAYER_DIALOGUE[eventName]) {
                const container = document.getElementById('eventMessagesContainer');
                const messageElement = document.createElement('div');
                messageElement.className = 'event-message';
                messageElement.textContent = PLAYER_DIALOGUE[eventName];
                
                container.appendChild(messageElement);
                
                // Remove the message after duration
                setTimeout(() => {
                    messageElement.remove();
                }, EVENT_TITLE_DURATION);
            }
        }

        /**
         * Adds a kill message to the right side message area
         * @param {string} message - The message to display
         */
        function addKillMessage(message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'kill-message';
            messageElement.textContent = message;
            
            // Insert at the top
            if (messageArea.firstChild) {
                messageArea.insertBefore(messageElement, messageArea.firstChild);
            } else {
                messageArea.appendChild(messageElement);
            }
            
            // Remove old messages if we have too many
            while (messageArea.children.length > MAX_MESSAGES) {
                messageArea.removeChild(messageArea.lastChild);
            }
        }

        function addActivityLogEntry(player, enemy, playerDamage, enemyDamage) {
            // Format the kill message
            const killMessage = `${player.name} [${player.health}] eliminated ${enemy.name} [${enemy.initialHealth}]`;
            addKillMessage(killMessage);
        }

        /**
         * Updates the activity log display in the right panel.
         */
        function updateActivityLogDisplay() {
            const rightPanel = document.getElementById('rightPanel');
            rightPanel.innerHTML = ''; // Clear existing entries
            
            activityLog.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'activity-log-entry';
                
                // Dim older entries
                if (index > 0) {
                    entryDiv.classList.add('dimmed');
                }
                
                // Create the main text
                const mainText = document.createElement('div');
                mainText.innerHTML = `<span class="player-name" style="color: ${entry.playerColor}">${entry.playerName}</span> has killed <span class="enemy-name" style="color: ${entry.enemyColor}">${entry.enemyName}</span>`;
                
                // Create damage comparison text
                const damageText = document.createElement('div');
                damageText.className = 'damage-comparison';
                if (entry.playerDamage > entry.enemyDamage) {
                    damageText.innerHTML = `<span style="color: ${entry.playerColor}">${entry.playerDamage}</span> damage vs <span style="color: ${entry.enemyColor}">${entry.enemyDamage}</span> damage`;
                } else if (entry.enemyDamage > entry.playerDamage) {
                    damageText.innerHTML = `<span style="color: ${entry.enemyColor}">${entry.enemyDamage}</span> damage vs <span style="color: ${entry.playerColor}">${entry.playerDamage}</span> damage`;
                } else {
                    damageText.innerHTML = `<span style="color: ${entry.playerColor}">${entry.playerDamage}</span> damage vs <span style="color: ${entry.enemyColor}">${entry.enemyDamage}</span> damage (tie)`;
                }
                
                entryDiv.appendChild(mainText);
                entryDiv.appendChild(damageText);
                rightPanel.appendChild(entryDiv);
            });
        }

        /**
         * Sets up the color scheme for the level.
         */
        function setupColors() {
            COLOR_FLOOR = '#111111'; // Darkened
            COLOR_WALL = '#222222'; // Darkened
        }

        /**
         * Adds an event message to the game interface.
         * This will display both the event name and its dialogue at the top of the screen.
         * @param {string} eventName - The name of the event that occurred.
         */
        function addEventMessage(eventName) {
            updateEventTitle(eventName);
        }

        /**
         * Initializes the game map with walls.
         */
        function initializeMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
        }

        /**
         * Generates procedural paths using a random walk algorithm.
         * @param {number} steps - The number of steps for the random walk.
         */
        function generatePaths(steps) {
            console.log('Starting map generation:', { steps, mapWidth: dynamicMapWidth, mapHeight: dynamicMapHeight });
            
            // Initialize starting point in the middle
            let currentX = Math.floor(dynamicMapWidth / 2);
            let currentY = Math.floor(dynamicMapHeight / 2);

            currentX = Math.max(1, Math.min(dynamicMapWidth - 2, currentX));
            currentY = Math.max(1, Math.min(dynamicMapHeight - 2, currentY));

            // Create initial map
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Start with a floor tile in the middle
            gameMap[currentY][currentX] = TILE_FLOOR;

            // Generate paths
            for (let i = 0; i < steps; i++) {
                // Pick a random direction (0: up, 1: right, 2: down, 3: left)
                const direction = Math.floor(Math.random() * 4);
                let nextX = currentX;
                let nextY = currentY;

                switch (direction) {
                    case 0: nextY--; break; // Up
                    case 1: nextX++; break; // Right
                    case 2: nextY++; break; // Down
                    case 3: nextX--; break; // Left
                }

                // Check bounds and make floor tile if valid
                if (nextX >= 1 && nextX < dynamicMapWidth - 1 && nextY >= 1 && nextY < dynamicMapHeight - 1) {
                    gameMap[nextY][nextX] = TILE_FLOOR;
                    currentX = nextX;
                    currentY = nextY;
                }
            }
        }

        /**
         * Generates a random integer between min (inclusive) and max (inclusive).
         * @param {number} min - The minimum value.
         * @param {number} max - The maximum value.
         * @returns {number} A random integer.
         */
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * Generates a random integer between min (inclusive) and max (inclusive),
         * biased by the health ratio of attacker to defender and optionally by attacker's flow.
         * If attacker is stronger, bias towards lower damage.
         * If attacker's weaker, bias towards higher damage.
         * If attacker's flow is high, bias towards higher damage.
         * If attacker's flow is low, bias towards lower damage.
         * @param {number} min - The minimum damage value.
         * @param {number} max - The maximum damage value.
         * @param {number} attackerHealth - Current health of the attacker.
         * @param {number} defenderHealth - Current health of the defender.
         * @param {number} [currentAttackerFlow=null] - Optional: The current flow of the attacker.
         * @returns {number} A biased random integer damage value.
         */
        function getWeightedRandomInt(min, max, attackerHealth, defenderHealth, currentAttackerFlow = null) {
            if (attackerHealth <= 0 || defenderHealth <= 0) {
                return 0;
            }

            const healthRatio = attackerHealth / defenderHealth;
            let biasFactor = 1;

            // Existing health-based bias
            if (healthRatio > 1) { // Attacker is stronger (relative to defender)
                biasFactor = 1 + (healthRatio - 1) * COMBAT_BIAS_STRENGTH;
            } else if (healthRatio < 1) { // Attacker is weaker (relative to defender)
                biasFactor = 1 - (1 - healthRatio) * COMBAT_BIAS_STRENGTH;
            }

            // New flow-based bias (only applies if currentAttackerFlow is provided and valid)
            if (currentAttackerFlow !== null && !isNaN(currentAttackerFlow) && currentAttackerFlow > 0) {
                const flowMultiplier = Math.pow(BASE_FLOW_FOR_BIAS / currentAttackerFlow, FLOW_BIAS_STRENGTH);
                biasFactor *= flowMultiplier;
            }

            biasFactor = Math.max(0.1, Math.min(biasFactor, 5.0)); // Clamp final biasFactor

            const biasedRandom = Math.pow(Math.random(), biasFactor);
            let damage = Math.floor(min + biasedRandom * (max - min + 1));
            damage = Math.max(min, Math.min(damage, max));

            return damage;
        }

        /**
         * Calculates the Euclidean distance between two points.
         * @param {object} p1 - First point {x, y}.
         * @param {object} p2 - Second point {x, y}.
         * @returns {number} The distance between the two points.
         */
        function getDistance(p1, p2) {
            if (!p1 || !p2) {
                console.error("Attempted to calculate distance with null or undefined point:", p1, p2);
                return Infinity;
            }
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        /**
         * Helper function to find an empty floor tile, excluding specified entities, and ensuring reachability from player start.
         * @param {Array<object>} excludeEntities - An array of entities to avoid placing the tile on.
         * @returns {object|null} An {x, y} object if a spot is found, otherwise null.
         */
        function findEmptyFloorTile(excludeEntities = []) {
            if (player.x === undefined || player.y === undefined || player.x === null || player.y === null) {
                console.error("Player position is undefined or null when trying to find empty floor tile. Cannot guarantee reachability.");
                let attempts = 0;
                const MAX_FALLBACK_ATTEMPTS = 500;
                while (attempts < MAX_FALLBACK_ATTEMPTS) {
                    const randX = getRandomInt(0, dynamicMapWidth - 1);
                    const randY = getRandomInt(0, dynamicMapHeight - 1);
                    if (gameMap[randY][randX] === TILE_FLOOR &&
                        !excludeEntities.some(e => e.x === randX && e.y === randY)) {
                        console.warn(`Placed item at (${randX}, ${randY}) without reachability check due to invalid player position.`);
                        return { x: randX, y: randY };
                    }
                    attempts++;
                }
                console.error("Failed to find any empty floor tile even as a last resort.");
                return null;
            }

            const potentialTiles = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (gameMap[y][x] === TILE_FLOOR &&
                        !excludeEntities.some(e => e.x === x && e.y === y)) {

                        let wallNeighbors = 0;
                        for (const [dx, dy] of directions) {
                            const checkX = x + dx;
                            const checkY = y + dy;

                            if (checkX >= 0 && checkX < dynamicMapWidth && checkY >= 0 && checkY < dynamicMapHeight) {
                                if (gameMap[checkY][checkX] === TILE_WALL) {
                                    wallNeighbors++;
                                }
                            } else {
                                wallNeighbors++;
                            }
                        }

                        if (wallNeighbors < 4) {
                            if (findPathBasic(player.x, player.y, x, y, gameMap, dynamicMapWidth, dynamicMapHeight)) {
                                potentialTiles.push({ x, y });
                            }
                        }
                    }
                }
            }

            if (potentialTiles.length > 0) {
                const randomIndex = getRandomInt(0, potentialTiles.length - 1);
                return potentialTiles[randomIndex];
            } else {
                console.warn("No reachable empty floor tiles found for placement of item.");
                let attempts = 0;
                const MAX_LAST_RESORT_ATTEMPTS = 500;
                while (attempts < MAX_LAST_RESORT_ATTEMPTS) {
                    const randX = getRandomInt(0, dynamicMapWidth - 1);
                    const randY = getRandomInt(0, dynamicMapHeight - 1);
                    if (gameMap[randY][randX] === TILE_FLOOR &&
                        !excludeEntities.some(e => e.x === randX && e.y === randY)) {
                        console.warn(`Placed item at (${randX}, ${randY}) as a last resort (reachability not guaranteed).`);
                        return { x: randX, y: randY };
                    }
                    attempts++;
                }
                console.error("Failed to find any empty floor tile even as a last resort.");
                return null;
            }
        }

        /**
         * Finds the shortest path from start to end using Breadth-First Search (BFS).
         * Returns an array of {x, y} coordinates representing the path, or null if no path exists.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {number} endX - Target X coordinate.
         * @param {number} endY - Target Y coordinate.
         * @param {Array<Array<number>>} map - The game map.
         * @param {number} mapWidth - Width of the map.
         * @param {number} mapHeight - Height of the map.
         * @param {Array<object>} [entitiesToStrictlyAvoid=[]] - Optional: An array of entity positions ({x, y}) to treat as impassable.
         * @returns {Array<{x: number, y: number}>|null} The path as an array of coordinates, or null.
         */
        function findPathBasic(startX, startY, endX, endY, map, mapWidth, mapHeight, entitiesToStrictlyAvoid = []) {
            const queue = [{ x: startX, y: startY, path: [] }];
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            while (queue.length > 0) {
                const { x, y, path } = queue.shift();

                if (x === endX && y === endY) {
                    return path.concat({ x, y });
                }

                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;

                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS) &&
                        !visited.has(`${newX},${newY}`) &&
                        !entitiesToStrictlyAvoid.some(e => e.x === newX && e.y === newY)) {

                        visited.add(`${newX},${newY}`);
                        queue.push({ x: newX, y: newY, path: path.concat({ x, y }) });
                    }
                }
            }
            return null;
        }

        /**
         * Finds the shortest path from start to end using a Dijkstra-like algorithm,
         * with a penalty for moving into tiles adjacent to enemies.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {number} endX - Target X coordinate.
         * @param {number} endY - Target Y coordinate.
         * @param {Array<Array<number>>} map - The game map.
         * @param {number} mapWidth - Width of the map.
         * @param {number} mapHeight - Height of the map.
         * @param {Array<object>} entitiesWithProximityPenalty - An array of entity positions ({x, y}) to apply proximity penalty for.
         * @returns {Array<{x: number, y: number}>|null} The path as an array of coordinates, or null.
         */
        function findPathWithProximityPenalty(startX, startY, endX, endY, map, mapWidth, mapHeight, entitiesWithProximityPenalty) {
            const queue = [{ x: startX, y: startY, path: [], cost: 0 }];
            const visitedCosts = new Map();
            visitedCosts.set(`${startX},${startY}`, 0);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Only cardinal directions for pathfinding
            const eightDirections = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]; // For proximity check

            const PROXIMITY_PENALTY = 5; // Cost penalty for moving into a tile adjacent to an entity

            while (queue.length > 0) {
                queue.sort((a, b) => a.cost - b.cost);
                const { x, y, path, cost } = queue.shift();

                if (cost > visitedCosts.get(`${x},${y}`)) {
                    continue;
                }

                if (x === endX && y === endY) {
                    return path.concat({ x, y });
                }

                for (const [dx, dy] of directions) { // Iterate over cardinal directions for movement
                    const newX = x + dx;
                    const newY = y + dy;

                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS)) {

                        let stepCost = 1;

                        for (const [edx, edy] of eightDirections) { // Check proximity in all 8 directions
                            const checkX = newX + edx;
                            const checkY = newY + edy;
                            if (entitiesWithProximityPenalty.some(e => e.x === checkX && e.y === checkY)) {
                                stepCost += PROXIMITY_PENALTY;
                                break;
                            }
                        }

                        const newCost = cost + stepCost;

                        if (!visitedCosts.has(`${newX},${newY}`) || newCost < visitedCosts.get(`${newX},${newY}`)) {
                            visitedCosts.set(`${newX},${newY}`, newCost);
                            queue.push({ x: newX, y: newY, path: path.concat({ x, y }), cost: newCost });
                        }
                    }
                }
            }
            return null;
        }

        /**
         * Finds a random floor tile for the player's starting position, prioritizing the top-left corner.
         */
        function findPlayerStartInCorner() {
            const playerPos = findEmptyFloorTile([]);
            if (playerPos) {
                player.x = playerPos.x;
                player.y = playerPos.y; // Corrected: assign to player.y
            } else {
                console.error("Failed to find a valid player start position. Forcing placement.");
                player.x = 1;
                player.y = 1;
                if (gameMap[1] && gameMap[1][1] === TILE_WALL) {
                    gameMap[1][1] = TILE_FLOOR; // This is the key part
                }
            }
        }

        /**
         * Finds a random floor tile in the bottom-right corner for the staircase, prioritizing open areas.
         */
        function placeStairsOppositeCorner() {
            let found = false;
            let attempts = 0;
            const MAX_PLACEMENT_ATTEMPTS = 1000;
            const MIN_OPEN_NEIGHBORS_FOR_STAIRS = 2; // Minimum number of adjacent floor tiles for stairs

            const searchStartX = Math.floor(dynamicMapWidth * 3 / 4);
            const searchStartY = Math.floor(dynamicMapHeight * 3 / 4);

            let validStairsCandidates = [];
            const cardinalDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            // First, try to find candidates with enough open neighbors
            for (let y = searchStartY; y < dynamicMapHeight; y++) {
                for (let x = searchStartX; x < dynamicMapWidth; x++) {
                    if (y >= 0 && y < dynamicMapHeight && x >= 0 && x < dynamicMapWidth &&
                        gameMap[y][x] === TILE_FLOOR && (x !== player.x || y !== player.y)) {

                        let openNeighbors = 0;
                        for (const [dx, dy] of cardinalDirections) {
                            const checkX = x + dx;
                            const checkY = y + dy;
                            if (checkX >= 0 && checkX < dynamicMapWidth && checkY >= 0 && checkY < dynamicMapHeight &&
                                gameMap[checkY][checkX] === TILE_FLOOR) {
                                openNeighbors++;
                            }
                        }

                        if (openNeighbors >= MIN_OPEN_NEIGHBORS_FOR_STAIRS) {
                            validStairsCandidates.push({ x, y, openNeighbors });
                        }
                    }
                }
            }

            // Sort candidates by openNeighbors in descending order
            validStairsCandidates.sort((a, b) => b.openNeighbors - a.openNeighbors);

            if (validStairsCandidates.length > 0) {
                // Pick a random one from the top few, or just the very best one
                const bestCandidatesSlice = validStairsCandidates.slice(0, Math.min(5, validStairsCandidates.length));
                const chosen = bestCandidatesSlice[getRandomInt(0, bestCandidatesSlice.length - 1)];
                stairs.x = chosen.x;
                stairs.y = chosen.y;
                gameMap[stairs.y][stairs.x] = TILE_STAIRS;
                found = true;
            }

            // Fallback if no suitable candidates found with open neighbors
            if (!found) {
                attempts = 0;
                while (!found && attempts < MAX_PLACEMENT_ATTEMPTS) {
                    const randX = searchStartX + Math.floor(Math.random() * (dynamicMapWidth - searchStartX));
                    const randY = searchStartY + Math.floor(Math.random() * (dynamicMapHeight - searchStartY));

                    if (randY >= 0 && randY < dynamicMapHeight && randX >= 0 && randX < dynamicMapWidth &&
                        gameMap[randY][randX] === TILE_FLOOR && (randX !== player.x || randY !== player.y)) {
                        stairs.x = randX;
                        stairs.y = randY;
                        gameMap[stairs.y][stairs.x] = TILE_STAIRS;
                        found = true;
                    }
                    attempts++;
                }
            }

            // Final fallback if still not found (should be rare with MAX_PLACEMENT_ATTEMPTS)
            if (!found) {
                attempts = 0;
                while (!found && attempts < MAX_PLACEMENT_ATTEMPTS) {
                    const randX = Math.floor(Math.random() * dynamicMapWidth);
                    const randY = Math.floor(Math.random() * dynamicMapHeight);
                    if (gameMap[randY][randX] === TILE_FLOOR && (randX !== player.x || randY !== player.y)) {
                        stairs.x = randX;
                        stairs.y = randY;
                        gameMap[randY][randX] = TILE_STAIRS; // Ensure the tile is set to stairs
                        found = true;
                    }
                    attempts++;
                }
            }

            if (!found) {
                console.error("Failed to find a valid stairs position after many attempts. Forcing placement.");
                stairs.x = dynamicMapWidth - 2;
                stairs.y = dynamicMapHeight - 2;
                if (gameMap[dynamicMapHeight - 2] && gameMap[dynamicMapHeight - 2][dynamicMapWidth - 2] === TILE_WALL) {
                    gameMap[dynamicMapHeight - 2][dynamicMapWidth - 2] = TILE_FLOOR;
                }
                gameMap[stairs.y][stairs.x] = TILE_STAIRS;
            }
        }

        /**
         * Spawns enemies on the map, distributing total health points equal to the current level.
         * @param {number} levelHealthBonus - Additional health points for enemies based on player's health.
         * @param {number} playerAverageFlow - The player's average flow so far in the run.
         */
        function spawnEnemies(levelHealthBonus = 0, playerAverageFlow = 0) {
            enemies = [];
            const totalHealthForLevel = currentLevel + levelHealthBonus;

            let actualNumEnemies;
            if (currentLevel === 1) {
                actualNumEnemies = 1; // For level 1, always spawn exactly one enemy
            } else {
                const maxPossibleEnemies = Math.max(1, Math.min(totalHealthForLevel, 7));
                actualNumEnemies = getRandomInt(1, maxPossibleEnemies);
            }

            // Removed: Reintroduced minimum enemies based on level number divided by two
            // actualNumEnemies = Math.max(Math.floor(currentLevel / 2), actualNumEnemies);


            let remainingHealthToDistribute = totalHealthForLevel;

            for (let i = 0; i < actualNumEnemies; i++) {
                const excludeList = [player, stairs, ...enemies]; // Ensure stairs is in the exclude list for spawning
                const enemyPos = findEmptyFloorTile(excludeList);

                if (enemyPos) {
                    let role;
                    const roleRoll = Math.random();
                    if (roleRoll < 0.4) {
                        role = 'hunter';
                    } else if (roleRoll < 0.7) {
                        role = 'guard';
                    } else {
                        role = 'tracker';
                    }

                    // Temporary health for initial flow calculation (will be updated after distribution)
                    const tempEnemyHealth = 1;

                    // Calculate initial enemy flow based on player's average flow and inverse health bias
                    let initialEnemyFlowForThisEnemy = 0;
                    if (playerAverageFlow > 0) {
                        const healthNormalized = tempEnemyHealth / ENEMY_VISUAL_HEALTH_THRESHOLD;
                        // Bias the random factor: lower healthNormalized (lower health) means randomFactor biases towards 0
                        // Higher healthNormalized (higher health) means randomFactor biases towards 1
                        let effectiveRandomFactor = Math.random() * healthNormalized;
                        initialEnemyFlowForThisEnemy = playerAverageFlow * effectiveRandomFactor;
                    }

                    const baseStepsForFlow = 5; // Use a base number of steps to avoid very high flow from 1 damage / 1 step
                    const initialEnemyDamageDealt = initialEnemyFlowForThisEnemy * baseStepsForFlow;
                    const initialEnemyStepsTaken = initialEnemyFlowForThisEnemy > 0 ? baseStepsForFlow : 0;

                    enemies.push({
                        x: enemyPos.x, y: enemyPos.y, role: role, health: tempEnemyHealth,
                        name: generateAgentName(), // Add generated name
                        thrustAnimActive: false, thrustAnimStartTime: 0, thrustAnimDuration: 150,
                        thrustAnimDirectionX: 0, thrustAnimDirectionY: 0, thrustAnimMagnitude: 0,
                        totalDamageDealtByThisEnemy: initialEnemyDamageDealt,
                        stepsTakenByThisEnemy: initialEnemyStepsTaken,
                        flowLevel: initialEnemyFlowForThisEnemy,
                        initialHealth: tempEnemyHealth,
                        totalDamageTakenByThisEnemy: 0
                    });
                    remainingHealthToDistribute--;
                } else {
                    console.warn(`Could not place enemy ${i + 1}. Skipping this enemy.`);
                }
            }

            // Distribute remaining health points among spawned enemies
            while (remainingHealthToDistribute > 0 && enemies.length > 0) {
                const randomIndex = getRandomInt(0, enemies.length - 1);
                enemies[randomIndex].health = enemies[randomIndex].health + 1; // Explicit assignment
                // Update initialHealth here as well, because we're still in the "initialization" phase for this enemy
                enemies[randomIndex].initialHealth = enemies[randomIndex].health;
                remainingHealthToDistribute--;
            }

            // After health distribution, re-calculate flow based on final enemy health
            enemies.forEach(enemy => {
                let finalEnemyFlowForThisEnemy = 0;
                if (playerAverageFlow > 0) {
                    const healthNormalized = enemy.health / ENEMY_VISUAL_HEALTH_THRESHOLD;
                    // Bias the random factor: lower healthNormalized (lower health) means randomFactor biases towards 0
                    // Higher healthNormalized (higher health) means randomFactor biases towards 1
                    let effectiveRandomFactor = Math.random() * healthNormalized;
                    finalEnemyFlowForThisEnemy = playerAverageFlow * effectiveRandomFactor;
                }
                const baseStepsForFlow = 5;
                enemy.totalDamageDealtByThisEnemy = finalEnemyFlowForThisEnemy * baseStepsForFlow;
                enemy.stepsTakenByThisEnemy = finalEnemyFlowForThisEnemy > 0 ? baseStepsForFlow : 0;
                enemy.flowLevel = finalEnemyFlowForThisEnemy; // Update flowLevel with final calculated value
            });


            // Fallback to ensure at least one enemy if somehow none were placed and totalHealthForLevel > 0
            if (totalHealthForLevel > 0 && enemies.length === 0) {
                const enemyPos = findEmptyFloorTile([player, stairs]); // Ensure stairs is excluded even in fallback
                if (enemyPos) {
                    const baseStepsForFlow = 5;
                    const initialEnemyDamageDealt = playerAverageFlow * baseStepsForFlow; // Use player flow as fallback
                    const initialEnemyStepsTaken = playerAverageFlow > 0 ? baseStepsForFlow : 0;
                    enemies.push({
                        x: enemyPos.x, y: enemyPos.y, role: 'hunter', health: totalHealthForLevel,
                        thrustAnimActive: false, thrustAnimStartTime: 0, thrustAnimDirectionX: 0, thrustAnimDirectionY: 0, thrustAnimMagnitude: 0,
                        totalDamageDealtByThisEnemy: initialEnemyDamageDealt, stepsTakenByThisEnemy: initialEnemyStepsTaken,
                        flowLevel: playerAverageFlow, // Fallback flow level
                        initialHealth: totalHealthForLevel, // Fallback initial health
                        totalDamageTakenByThisEnemy: 0 // Initialize for new enemy flow logic
                    });
                } else {
                    console.error("Critical: Could not place any enemies even for fallback!");
                }
            }
        }

        /**
         * Spawns scattered health pickups on the map.
         */
        function spawnPickups() {
            // Filter out previous level's static pickups, keep only enemy drops (if any are left uncollected)
            staticDamageNumbers = staticDamageNumbers.filter(item => item.isEnemyDrop);

            let pointsToDistribute = currentLevel;
            let numPickupsToSpawn = 0;

            if (currentLevel === 1) {
                numPickupsToSpawn = 1; // For level 1, always spawn exactly one pickup
            } else {
                // For other levels, distribute points among multiple pickups as before
                // This logic can be refined if you want a specific number of pickups per level
                // For now, it will try to create pickups with values up to currentLevel,
                // resulting in a variable number of pickups.
                numPickupsToSpawn = currentLevel; // A rough estimate, actual number depends on random values
            }

            for (let i = 0; i < numPickupsToSpawn && pointsToDistribute > 0; i++) {
                const excludeList = [player, stairs, ...enemies, ...staticDamageNumbers.map(s => ({x: s.x, y: s.y}))];
                const pickupPos = findEmptyFloorTile(excludeList);

                if (pickupPos) {
                    let pickupValue;
                    if (currentLevel === 1) {
                        pickupValue = pointsToDistribute; // For level 1, the single pickup gets all points
                    } else {
                        // Determine the maximum value for the current pickup.
                        // It should be at least 1, not more than the remaining points.
                        const maxPickupValue = pointsToDistribute;
                        pickupValue = getRandomInt(1, maxPickupValue);
                    }
                    
                    staticDamageNumbers.push({
                        x: pickupPos.x,
                        y: pickupPos.y,
                        parts: [{ content: { type: 'number', value: pickupValue }, offsetX: 0, offsetY: 0 }],
                        isEnemyDrop: false // Mark as a static pickup
                    });
                    pointsToDistribute = pointsToDistribute - pickupValue; // Explicit assignment
                } else {
                    console.warn(`Could not place a pickup with ${pointsToDistribute} points. Remaining: ${pointsToDistribute}.`);
                    break; // Stop if no more spots can be found
                }
            }
        }

        /**
         * Draws an off-screen indicator for an entity.
         * @param {object} entity - The entity ({x, y}) to draw an indicator for.
         * @param {string} color - The color of the indicator.
         * @param {number} offsetX - The camera's X offset.
         * @param {number} offsetY - The camera's Y offset.
         * @param {number} opacity - The opacity of the indicator.
         */
        function drawOffScreenIndicator(entity, color, offsetX, offsetY, opacity) {
            const minIndicatorSize = dynamicTileSize * 0.3;
            const maxIndicatorSize = dynamicTileSize;

            const entityPixelX = entity.x * dynamicTileSize + offsetX;
            const entityPixelY = entity.y * dynamicTileSize + offsetY;

            const distFromLeft = Math.max(0, -entityPixelX);
            const distFromRight = Math.max(0, entityPixelX + gameCanvas.width - gameCanvas.width); // Use gameCanvas.width
            const distFromTop = Math.max(0, -entityPixelY);
            const distFromBottom = Math.max(0, entityPixelY + gameCanvas.height - gameCanvas.height); // Use gameCanvas.height

            const distanceOffScreen = Math.max(distFromLeft, distFromRight, distFromTop, distFromBottom);

            const maxScalingDistance = Math.max(gameCanvas.width, gameCanvas.height) / 3; // Use gameCanvas.width/height

            const normalizedDistance = Math.min(distanceOffScreen / maxScalingDistance, 1);

            const currentIndicatorSize = maxIndicatorSize - (normalizedDistance * (maxScalingDistance - minIndicatorSize));

            let indicatorX, indicatorY;

            if (entityPixelX < 0) {
                indicatorX = 0;
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width) { // Use gameCanvas.width
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
            } else {
                indicatorX = entityPixelX + (dynamicTileSize / 2) - (currentIndicatorSize / 2);
            }

            if (entityPixelY < 0) {
                indicatorY = 0;
            } else if (entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else {
                indicatorY = entityPixelY + (dynamicTileSize / 2) - (currentIndicatorSize / 2);
            }

            if (entityPixelX < 0 && entityPixelY < 0) {
                indicatorX = 0;
                indicatorY = 0;
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width && entityPixelY < 0) { // Use gameCanvas.width
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
                indicatorY = 0;
            } else if (entityPixelX < 0 && entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorX = 0;
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width && entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.width/height
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else if (entityPixelX < 0 || entityPixelX + dynamicTileSize > gameCanvas.width) { // Use gameCanvas.width
                indicatorY = Math.max(0, Math.min(gameCanvas.height - currentIndicatorSize, indicatorY)); // Use gameCanvas.height
            } else if (entityPixelY < 0 || entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorX = Math.max(0, Math.min(gameCanvas.width - currentIndicatorSize, indicatorX)); // Use gameCanvas.width
            }

            ctx.save();
            ctx.globalAlpha = opacity; // Apply opacity to the indicator
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(indicatorX), Math.floor(indicatorY), Math.floor(currentIndicatorSize), Math.floor(currentIndicatorSize));
            ctx.restore();
        }

        // Add a roundRect method to CanvasRenderingContext2D for drawing rounded rectangles
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
            if (width < 2 * radius) radius = width / 2;
            if (height < 2 * radius) radius = height / 2;
            this.beginPath();
            this.moveTo(x + radius, y);
            this.arcTo(x + width, y, x + width, y + height, radius);
            this.arcTo(x + width, y + height, x, y + height, radius);
            this.arcTo(x, y + height, x, y, radius);
            this.arcTo(x, y, x + width, y, radius);
            this.closePath();
            return this;
        };

        /**
         * Draws the game map, stairs, player, and enemies on the canvas with a camera effect.
         */
        function drawGame() {
            try {
                // Early validation
                if (!ctx || !gameCanvas) {
                    console.error('Canvas or context not initialized');
                    return;
                }

                // Clear the canvas with a black background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                
                // Draw a test square to ensure canvas is working
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(10, 10, 50, 50);
                
                // Add detailed debug logging
                console.log('Drawing game state:', {
                    mapDimensions: `${dynamicMapWidth}x${dynamicMapHeight}`,
                    playerPos: `(${player.x}, ${player.y})`,
                    canvasDimensions: `${gameCanvas.width}x${gameCanvas.height}`,
                    mapState: gameMap ? `Map exists with ${gameMap.length} rows` : 'No map',
                    tileSize: dynamicTileSize,
                    gameLevel: currentLevel,
                    mapSample: gameMap ? `First row: ${gameMap[0].slice(0, 5).join(',')}...` : 'No map data'
                });

                // Validate critical game state
                if (!gameMap || !gameMap.length || !gameMap[0] || !gameMap[0].length) {
                    console.error("Game map is invalid or empty");
                    return;
                }

                // Validate player position before drawing
                if (isNaN(player.x) || isNaN(player.y) || player.x === null || player.y === null) {
                    console.error("Player position is invalid. Stopping drawGame.");
                    return;
                }

                const now = performance.now();

                let currentRenderTileSize;
                let currentRenderOffsetX;
                let currentRenderOffsetY;

                // Calculate the target dynamicTileSize for the current level based on current canvas dimensions
                const targetDynamicTileSizeForLevel = (() => {
                    const initialMaxTileSize = Math.floor(Math.min(gameCanvas.width / MAX_VISIBLE_TILES_LEVEL1, gameCanvas.height / MAX_VISIBLE_TILES_LEVEL1));
                    const finalMinTileSize = Math.floor(Math.min(gameCanvas.width / MIN_VISIBLE_TILES_MAX_LEVEL, gameCanvas.height / MIN_VISIBLE_TILES_MAX_LEVEL));
                    let calculated = initialMaxTileSize - ((Math.min(currentLevel, ZOOM_LEVELS_EFFECTIVE) - 1) * (initialMaxTileSize - finalMinTileSize) / (ZOOM_LEVELS_EFFECTIVE - 1));
                    return Math.max(finalMinTileSize, Math.floor(calculated));
                })();


                if (deathAnimationActive) {
                    const elapsed = now - deathAnimationStartTime;
                    const zoomProgress = Math.min(1, elapsed / DEATH_ZOOM_DURATION);

                    // For death zoom, we zoom *into* the current dynamicTileSize
                    currentRenderTileSize = Math.floor(targetDynamicTileSizeForLevel + (targetDynamicTileSizeForLevel * DEATH_ZOOM_TARGET_TILE_SCALE - targetDynamicTileSizeForLevel) * zoomProgress);

                    // Clamp currentRenderTileSize to prevent it from getting too large or small
                    currentRenderTileSize = Math.max(1, currentRenderTileSize); // Ensure it's at least 1 pixel

                    const targetPlayerCenterScreenX = gameCanvas.width / 2; // Use dynamic canvas width
                    const targetPlayerCenterScreenY = gameCanvas.height / 2; // Use dynamic canvas height

                    currentRenderOffsetX = Math.floor(targetPlayerCenterScreenX - (player.x * currentRenderTileSize + currentRenderTileSize / 2));
                    currentRenderOffsetY = Math.floor(targetPlayerCenterScreenY - (player.y * currentRenderTileSize + currentRenderTileSize / 2));

                    // Clamp offsets to map boundaries
                    const totalMapPixelWidthZoomed = dynamicMapWidth * currentRenderTileSize;
                    const totalMapPixelHeightZoomed = dynamicMapHeight * currentRenderTileSize;
                    currentRenderOffsetX = Math.max(gameCanvas.width - totalMapPixelWidthZoomed, Math.min(0, currentRenderOffsetX));
                    currentRenderOffsetY = Math.max(gameCanvas.height - totalMapPixelHeightZoomed, Math.min(0, currentRenderOffsetY));

                } else if (gameStartZoomActive) {
                    const elapsed = now - gameStartZoomStartTime;
                    // Make zoom faster and smooth, slowing at the end (ease-out cubic)
                    const rawProgress = Math.min(1, elapsed / (GAME_START_ZOOM_OUT_DURATION * 0.6)); // 40% faster overall
                    // Ease-out cubic: f(t) = 1 - (1 - t)^3
                    const zoomProgress = 1 - Math.pow(1 - Math.min(rawProgress, 1), 3);

                    // Interpolate currentRenderTileSize from the initial zoomed-in size (dynamicTileSize)
                    // to the target normal level size (targetDynamicTileSizeForLevel)
                    currentRenderTileSize = Math.floor(dynamicTileSize - ((dynamicTileSize - targetDynamicTileSizeForLevel) * zoomProgress));

                    // Clamp currentRenderTileSize to prevent it from getting too large or small
                    currentRenderTileSize = Math.max(1, currentRenderTileSize); // Ensure it's at least 1 pixel

                    // Update offsets based on the current animated tile size
                    currentRenderOffsetX = Math.floor((gameCanvas.width / 2 - currentRenderTileSize / 2) - (player.x * currentRenderTileSize));
                    currentRenderOffsetY = Math.floor((gameCanvas.height / 2 - currentRenderTileSize / 2) - (player.y * currentRenderTileSize));

                    if (zoomProgress >= 1) {
                        gameStartZoomActive = false;
                        // Once zoom-out is complete, ensure dynamicTileSize is set to its final, level-appropriate value
                        dynamicTileSize = targetDynamicTileSizeForLevel;
                    }
                } else {
                    // Default case: no specific zoom animation active
                    currentRenderTileSize = Math.floor(dynamicTileSize); // Use the base dynamicTileSize
                    currentRenderOffsetX = Math.floor((gameCanvas.width / 2 - dynamicTileSize / 2) - (player.x * dynamicTileSize));
                    currentRenderOffsetY = Math.floor((gameCanvas.height / 2 - dynamicTileSize / 2) - (player.y * dynamicTileSize));
                }

                // Ensure all drawing dimensions are integers to prevent sub-pixel rendering artifacts
                currentRenderTileSize = Math.floor(currentRenderTileSize);
                currentRenderOffsetX = Math.floor(currentRenderOffsetX);
                currentRenderOffsetY = Math.floor(currentRenderOffsetY);

                const totalMapPixelWidth = dynamicMapWidth * currentRenderTileSize;
                const totalMapPixelHeight = dynamicMapHeight * currentRenderTileSize;

                // These clamping lines are now applied to currentRenderOffsetX/Y, not offsetX/Y directly
                currentRenderOffsetX = Math.max(gameCanvas.width - totalMapPixelWidth, Math.min(0, currentRenderOffsetX));
                currentRenderOffsetY = Math.max(gameCanvas.height - totalMapPixelHeight, Math.min(0, currentRenderOffsetY));

                for (let y = 0; y < dynamicMapHeight; y++) {
                    for (let x = 0; x < dynamicMapWidth; x++) {
                        const tileType = gameMap[y][x];
                        const tileDrawX = Math.floor(x * currentRenderTileSize + currentRenderOffsetX);
                        const tileDrawY = Math.floor(y * currentRenderTileSize + currentRenderOffsetY);
                        const tileSize = Math.floor(currentRenderTileSize);

                        switch (tileType) {
                            case TILE_WALL:
                                ctx.fillStyle = COLOR_WALL;
                                ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                break;
                            case TILE_FLOOR:
                                ctx.fillStyle = COLOR_FLOOR;
                                ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                break;
                            case TILE_STAIRS:
                                // Stairs color is now dynamic based on level
                                const stairsHealthRatio = currentLevel / ZOOM_LEVELS_EFFECTIVE; // Use currentLevel for stairs "health"
                                const currentStairsColor = getHealthColor(FIXED_COLOR_STAIRS, currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold
                                ctx.fillStyle = currentStairsColor;
                                ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                break;
                        }
                    }
                }

                const stairsCanvasX = stairs.x * currentRenderTileSize + currentRenderOffsetX;
                const stairsCanvasY = stairs.y * currentRenderTileSize + currentRenderOffsetY;
                const areStairsOnScreen = stairsCanvasX >= -currentRenderTileSize && stairsCanvasX < gameCanvas.width &&
                                           stairsCanvasY >= -currentRenderTileSize && stairsCanvasY < gameCanvas.height;

                // Calculate opacity and font weight for stairs based on currentLevel
                const stairsOpacity = getOpacity(currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold
                const stairsFontWeight = getFontWeight(currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold
                const currentStairsColor = getHealthColor(FIXED_COLOR_STAIRS, currentLevel, ZOOM_LEVELS_EFFECTIVE); // Use dynamic color for stairs

                if (areStairsOnScreen) {
                    ctx.save();
                    ctx.globalAlpha = stairsOpacity; // Apply opacity to stairs
                    ctx.fillStyle = currentStairsColor; // Use dynamic color
                    ctx.fillRect(Math.floor(stairsCanvasX), Math.floor(stairsCanvasY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                    ctx.restore();

                    // Draw the next level number on the stairs
                    ctx.save();
                    ctx.globalAlpha = stairsOpacity; // Apply opacity to stairs number
                    ctx.fillStyle = '#FFFFFF'; // White color for the level number
                    ctx.font = `${stairsFontWeight} ${Math.floor(currentRenderTileSize * 0.6)}px VT323`; // Apply font weight
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(currentLevel + 1, Math.floor(stairsCanvasX + currentRenderTileSize / 2), Math.floor(stairsCanvasY + currentRenderTileSize / 2));
                    ctx.restore();
                } else {
                    drawOffScreenIndicator(stairs, currentStairsColor, currentRenderOffsetX, currentRenderOffsetY, stairsOpacity); // Indicator also uses dynamic color and opacity
                }

                enemies.forEach(enemy => {
                    const enemyCanvasX = enemy.x * currentRenderTileSize + currentRenderOffsetX;
                    const enemyCanvasY = enemy.y * currentRenderTileSize + currentRenderOffsetY;

                    const isEnemyOnScreen = enemyCanvasX >= -currentRenderTileSize && enemyCanvasX < gameCanvas.width &&
                                            enemyCanvasY >= -currentRenderTileSize && enemyCanvasY < gameCanvas.height;

                    let currentEnemyThrustOffsetX = 0;
                    let currentEnemyThrustOffsetY = 0;
                    let enemyHealthOpacity = 1;

                    if (enemy.thrustAnimActive) {
                        const elapsed = (now - enemy.thrustAnimStartTime) * timeScale; // Apply timeScale
                        if (elapsed < enemy.thrustAnimDuration) {
                            const progress = elapsed / enemy.thrustAnimDuration;
                            const thrustFactor = Math.sin(progress * Math.PI); // Smooth forward and back
                            const displacementMagnitude = currentRenderTileSize * 0.4 * enemy.thrustAnimMagnitude; // Max thrust is 40% of tile size, scaled by damage
                            currentEnemyThrustOffsetX = enemy.thrustAnimDirectionX * thrustFactor * displacementMagnitude;
                            currentEnemyThrustOffsetY = enemy.thrustAnimDirectionY * thrustFactor * displacementMagnitude;
                            enemyHealthOpacity = 1 - (progress * 0.5); // Fade out slightly
                        } else {
                            enemy.thrustAnimActive = false; // Animation finished
                        }
                    }

                    // Calculate health ratio for enemy color and font
                    let currentEnemyColor = getHealthColor(FIXED_COLOR_ENEMY, enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Base color based on health

                    // Calculate enemy flow for blinking effect
                    // MODIFIED: Enemy flow now uses flowLevel if no damage taken, otherwise damage taken flow.
                    const enemyVisualFlow = enemy.totalDamageTakenByThisEnemy > 0
                        ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1) // Ensure no division by zero
                        : enemy.flowLevel; // Use initial flowLevel if no damage taken yet

                    const enemyFlowIntensity = Math.min(1, enemyVisualFlow); // Cap intensity at 1 flow

                    let enemyFlowScale = 1;
                    if (enemyFlowIntensity > 0) {
                        // Invert flow intensity for blink speed: higher flow -> smaller blink speed (faster)
                        const minBlinkSpeed = 50; // Fastest blink speed (for flowIntensity = 1)
                        const maxBlinkSpeed = 200; // Slowest blink speed (for flowIntensity = 0, effectively)
                        const currentBlinkSpeed = maxBlinkSpeed - (maxBlinkSpeed - minBlinkSpeed) * enemyFlowIntensity;
                        const blinkFactor = (Math.sin(now / currentBlinkSpeed) + 1) / 2; // Smooth pulse from 0 to 1

                        // Convert currentEnemyColor to HSL to modulate it for blinking
                        let [h_e, s_e, l_e] = hexToHsl(currentEnemyColor);

                        // Apply saturation boost based on blinkFactor and flowIntensity
                        const maxSaturationBoost_e = 50; // Increased for more obvious effect, same as player
                        s_e = s_e + (blinkFactor * enemyFlowIntensity * maxSaturationBoost_e);
                        s_e = Math.min(100, s_e); // Clamp saturation

                        // Apply a subtle lightness pulse, making it slightly brighter at the peak of the blink
                        const maxLightnessPulse_e = 20; // Increased for more obvious effect, same as player
                        l_e = l_e + (blinkFactor * enemyFlowIntensity * maxLightnessPulse_e);
                        l_e = Math.min(100, l_e); // Clamp lightness

                        currentEnemyColor = hslToHex(h_e, s_e, l_e);

                        enemyFlowScale = 1 + (enemyFlowIntensity * 0.1 * blinkFactor); // Apply size pulse based on flow
                    }


                    const enemyFontWeight = getFontWeight(enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Pass current health and threshold
                    const enemyOpacity = getOpacity(enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Get opacity based on health

                    if (isEnemyOnScreen) {
                        // Draw enemy square
                        ctx.save();
                        ctx.globalAlpha = enemyOpacity;
                        ctx.fillStyle = currentEnemyColor;
                        ctx.fillRect(Math.floor(enemyCanvasX), Math.floor(enemyCanvasY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                        ctx.restore();

                        // Draw enemy health number
                        ctx.save();
                        ctx.globalAlpha = enemyHealthOpacity;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = `${enemyFontWeight} ${Math.floor(currentRenderTileSize * 0.5 * enemyFlowScale)}px VT323`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(enemy.health, Math.floor(enemyCanvasX + currentRenderTileSize / 2 + currentEnemyThrustOffsetX), Math.floor(enemyCanvasY + currentRenderTileSize / 2 + currentEnemyThrustOffsetY));
                        ctx.restore();

                        // Draw enemy name in a crisp font at the bottom of the square
                        ctx.save();
                        ctx.globalAlpha = 1;  // Full opacity for better legibility
                        // Crisp font with slightly reduced weight
                        ctx.font = `${Math.max(8, Math.floor(currentRenderTileSize * 0.25))}px 'VT323'`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';  // Align to bottom of the square
                        // Draw black outline first for better contrast
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(enemy.name, 
                            Math.floor(enemyCanvasX + currentRenderTileSize / 2),
                            Math.floor(enemyCanvasY + currentRenderTileSize));
                        // Then draw white text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(enemy.name, 
                            Math.floor(enemyCanvasX + currentRenderTileSize / 2),
                            Math.floor(enemyCanvasY + currentRenderTileSize));
                        ctx.restore();
                    } else {
                        drawOffScreenIndicator(enemy, currentEnemyColor, currentRenderOffsetX, currentRenderOffsetY, enemyOpacity); // Indicator also uses dynamic color and opacity
                    }
                });

                let currentHealthTextScale = 1;
                const healthAnimDuration = 200;
                if (player.healthAnimStartTime > 0 && (now - player.healthAnimStartTime) * timeScale < healthAnimDuration) { // Apply timeScale
                    const progress = ((now - player.healthAnimStartTime) * timeScale) / healthAnimDuration;
                    if (progress < 0.5) {
                        currentHealthTextScale = 1 + (0.5 * progress * 2);
                    } else {
                        currentHealthTextScale = 1.5 - (0.5 * (progress - 0.5) * 2);
                    }
                } else {
                    player.healthAnimStartTime = 0;
                }

                let currentPlayerThrustOffsetX = 0;
                let currentPlayerThrustOffsetY = 0;
                let playerHealthOpacity = 1;

                if (player.thrustAnimActive) {
                    const elapsed = (now - player.thrustAnimStartTime) * timeScale; // Apply timeScale
                    if (elapsed < player.thrustAnimDuration) {
                        const progress = elapsed / player.thrustAnimDuration;
                        const thrustFactor = Math.sin(progress * Math.PI); // Smooth forward and back
                        const displacementMagnitude = currentRenderTileSize * 0.4 * player.thrustAnimMagnitude; // Max thrust is 40% of tile size, scaled by damage
                        currentPlayerThrustOffsetX = player.thrustAnimDirectionX * thrustFactor * displacementMagnitude;
                        currentPlayerThrustOffsetY = player.thrustAnimDirectionY * thrustFactor * displacementMagnitude;
                        playerHealthOpacity = 1 - (progress * 0.5); // Fade out slightly
                    } else {
                        player.thrustAnimActive = false; // Animation finished
                    }
                }

                // Calculate health ratio for player color and font
                let currentPlayerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Base color based on health

                // Calculate player flow for blinking effect
                playerFlow = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0; // Assign to the global playerFlow
                const flowIntensity = Math.min(1, playerFlow); // Cap intensity at 1 flow

                let playerFlowScale = 1; // Initialize playerFlowScale
                if (flowIntensity > 0) {
                    // Invert flow intensity for blink speed: higher flow -> smaller blink speed (faster)
                    const minBlinkSpeed = 50; // Fastest blink speed (for flowIntensity = 1)
                    const maxBlinkSpeed = 200; // Slowest blink speed (for flowIntensity = 0, effectively)
                    const currentBlinkSpeed = maxBlinkSpeed - (maxBlinkSpeed - minBlinkSpeed) * flowIntensity;
                    const blinkFactor = (Math.sin(now / currentBlinkSpeed) + 1) / 2; // Smooth pulse from 0 to 1

                    // Convert currentPlayerColor to HSL to modulate it for blinking
                    let [h, s, l] = hexToHsl(currentPlayerColor);

                    // Apply saturation boost based on blinkFactor and flowIntensity
                    const maxSaturationBoost = 50; // Increased for more obvious effect
                    s = s + (blinkFactor * flowIntensity * maxSaturationBoost);
                    s = Math.min(100, s); // Clamp saturation

                    // Apply a subtle lightness pulse, making it slightly brighter at the peak of the blink
                    const maxLightnessPulse = 20; // Increased for more obvious effect
                    l = l + (blinkFactor * flowIntensity * maxLightnessPulse);
                    l = Math.min(100, l); // Clamp lightness

                    currentPlayerColor = hslToHex(h, s, l);

                    playerFlowScale = 1 + (flowIntensity * 0.1 * blinkFactor); // Apply size pulse based on flow
                }

                const playerFontWeight = getFontWeight(player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Pass current health and threshold
                const playerOpacity = getOpacity(player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Get opacity based on health

                // Only draw player if not game over (player explodes and is no longer drawn as a solid block)
                    if (!gameOver) {
                        // Draw player square
                        ctx.save();
                        ctx.globalAlpha = playerOpacity;
                        ctx.fillStyle = currentPlayerColor;
                        ctx.fillRect(Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX), Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                        
                        // Draw player name in a crisp font at the bottom of the square
                        ctx.save();
                        ctx.globalAlpha = 1;  // Full opacity for better legibility
                        // Crisp font with slightly reduced weight
                        ctx.font = `${Math.max(8, Math.floor(currentRenderTileSize * 0.25))}px 'VT323'`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';  // Align to bottom of the square
                        // Draw black outline first for better contrast
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(player.name, 
                            Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2), 
                            Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize));
                        // Then draw white text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(player.name, 
                            Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2), 
                            Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize));
                        ctx.restore();
                        ctx.restore();
                    ctx.save(); // Save context again for text opacity
                    ctx.globalAlpha = playerHealthOpacity; // Apply thrust animation opacity
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${playerFontWeight} ${Math.floor(currentRenderTileSize * 0.5 * currentHealthTextScale * playerFlowScale)}px VT323`; // Use dynamic font weight and flow scale
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(player.health, Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + currentPlayerThrustOffsetX), Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + currentPlayerThrustOffsetY));
                    ctx.restore(); // Restore context
                }


                for (let i = activeExplosions.length - 1; i >= 0; i--) {
                    const explosion = activeExplosions[i];
                    const elapsed = (now - explosion.startTime) * timeScale; // Apply timeScale
                    const progress = elapsed / explosion.duration;

                    if (progress >= 1) {
                        activeExplosions.splice(i, 1);
                        continue;
                    }

                    for (let j = explosion.particles.length - 1; j >= 0; j--) {
                        const particle = explosion.particles[j];
                        const particleProgress = ((now - particle.startTime) * timeScale) / particle.duration; // Apply timeScale

                        if (particleProgress >= 1) {
                            continue;
                        }

                        // Calculate current size of the particle (shrinks over time)
                        const initialParticleSize = currentRenderTileSize * 0.2; // Starting size for fragments
                        const currentParticleSize = initialParticleSize * (1 - particleProgress * 0.7); // Shrink more significantly

                        const currentX = particle.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + particle.initialVelocityX * elapsed;
                        const currentY = particle.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + particle.initialVelocityY * elapsed;

                        ctx.save();
                        ctx.globalAlpha = (1 - particleProgress) * particle.fadeFactor; // Apply random fade factor
                        ctx.fillStyle = particle.color;
                        ctx.fillRect(Math.floor(currentX - currentParticleSize / 2), Math.floor(currentY - currentParticleSize / 2), Math.floor(currentParticleSize), Math.floor(currentParticleSize));
                        ctx.restore();
                    }
                }

                // Draw static pickups (including player remains)
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                staticDamageNumbers.forEach(staticNum => {
                    if (staticNum.parts && staticNum.parts.length > 0) {
                        staticNum.parts.forEach(part => {
                            let writhingXOffset = 0;
                            let writhingYOffset = 0;
                            if (staticNum.isPlayerRemains) {
                                writhingXOffset = Math.cos(staticNum.writhingOffsetAngle + now * staticNum.writhingSpeed) * staticNum.writhingOffsetRadius;
                                writhingYOffset = Math.sin(staticNum.writhingOffsetAngle + now * staticNum.writhingSpeed) * staticNum.writhingOffsetRadius;
                            }

                            const drawX = staticNum.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + part.offsetX + writhingXOffset;
                            const drawY = staticNum.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + part.offsetY + writhingYOffset;
                            
                            // Determine color based on type of pickup
                            ctx.fillStyle = staticNum.isPlayerRemains ? staticNum.playerDeathColor : '#CCCC00'; // Use playerDeathColor if it's player remains

                            // Apply font weight based on pickup value
                            // Max value for pickup font scaling should ideally be the maximum possible pickup value,
                            // which is `currentLevel` for the current logic.
                            const pickupFontWeight = getFontWeight(part.content.value, currentLevel > 0 ? currentLevel : 1);
                            ctx.font = `${pickupFontWeight} ${Math.floor(currentRenderTileSize * 0.6)}px VT323`;

                            // Draw either number or symbol
                            if (part.content.type === 'number') {
                                ctx.fillText(part.content.value, Math.floor(drawX), Math.floor(drawY));
                            } else if (part.content.type === 'symbol') {
                                ctx.fillText(part.content.value, Math.floor(drawX), Math.floor(drawY));
                            }
                        });
                    }
                });

                // Drawing activeDamageTextAnimations
                for (let i = activeDamageTextAnimations.length - 1; i >= 0; i--) {
                    const anim = activeDamageTextAnimations[i];
                    const elapsed = (now - anim.startTime) * timeScale; // Apply timeScale

                    if (elapsed < anim.delay) {
                        continue;
                    }

                    const effectiveElapsed = elapsed - anim.delay;
                    const progress = effectiveElapsed / anim.duration;

                    if (progress >= 1) {
                        activeDamageTextAnimations.splice(i, 1);
                        continue;
                    }

                    const opacity = 1 - progress;
                    const moveDistance = currentRenderTileSize * 1.2 * progress;

                    const drawX = Math.floor(anim.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.dirX * moveDistance);
                    const drawY = Math.floor(anim.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.dirY * moveDistance);

                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = anim.color;
                    const baseFontSize = currentRenderTileSize * 0.6;
                    const scaledFontSize = baseFontSize + (anim.amount * (currentRenderTileSize * 0.05));
                    ctx.font = `${Math.floor(scaledFontSize * (1 - progress * 0.5))}px VT323`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(anim.amount, drawX, drawY); // Draw the damage amount
                    ctx.restore();
                }

                // Drawing activePickupAnimations
                for (let i = activePickupAnimations.length - 1; i >= 0; i--) {
                    const anim = activePickupAnimations[i];
                    const elapsed = (now - anim.startTime) * timeScale; // Apply timeScale
                    const progress = elapsed / anim.duration;

                    if (progress >= 1) {
                        activePickupAnimations.splice(i, 1);
                        continue;
                    }

                    const opacity = 1 - progress;

                    const currentX = anim.startX * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.initialOffsetX + (player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 - (anim.startX * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.initialOffsetX)) * progress;
                    const currentY = anim.startY * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.initialOffsetY + (player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 - (anim.startY * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.initialOffsetY)) * progress;


                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = VINTAGE_GREEN; // Green color for health pickups
                    ctx.font = `${Math.floor(currentRenderTileSize * 0.6 * (1 - progress * 0.5))}px VT323`; // Shrink slightly
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(anim.amount, Math.floor(currentX), Math.floor(currentY));
                    ctx.restore();
                }

                // Calculate and draw the score at the top left
                let score = 0;
                if (stepsTaken > 0) {
                    const averageDamagePerTurn = totalDamageDealt / stepsTaken;
                    score = Math.floor(totalDamageDealt * averageDamagePerTurn);
                }

                // Draw the black box for the score
                ctx.fillStyle = '#000000'; // Black color for the box
                ctx.fillRect(SCORE_BOX_MARGIN, SCORE_BOX_MARGIN, SCORE_BOX_WIDTH, SCORE_BOX_HEIGHT);

                // Draw the score text inside the box
                ctx.fillStyle = '#e2e8f0'; // Light text color
                // Adjusted font size to be larger, similar to in-game text
                const scoreFlowFontSize = Math.floor(SCORE_BOX_HEIGHT - (2 * SCORE_BOX_PADDING));
                ctx.font = `${scoreFlowFontSize}px VT323`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Modified to include "SCORE: " before the score
                ctx.fillText(`SCORE: ${score}`, SCORE_BOX_MARGIN + SCORE_BOX_WIDTH / 2, SCORE_BOX_MARGIN + SCORE_BOX_HEIGHT / 2);

                // Calculate and draw the FLOW at the top right
                const displayFlow = playerFlow.toFixed(2); // Format flow to two decimal places

                // Draw the black box for the FLOW
                ctx.fillStyle = '#000000'; // Black color for the box
                ctx.fillRect(gameCanvas.width - SCORE_BOX_WIDTH - SCORE_BOX_MARGIN, SCORE_BOX_MARGIN, SCORE_BOX_WIDTH, SCORE_BOX_HEIGHT); // Use gameCanvas.width

                // Draw the FLOW text inside the box
                ctx.fillStyle = '#e2e8f0'; // Light text color
                ctx.font = `${scoreFlowFontSize}px VT323`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`FLOW: ${displayFlow}`, gameCanvas.width - SCORE_BOX_WIDTH / 2 - SCORE_BOX_MARGIN, SCORE_BOX_MARGIN + SCORE_BOX_HEIGHT / 2); // Use gameCanvas.width

                // Draw the "HARD DIVISION" overlay if active
                if (gameStartedOverlayActive) {
                    const elapsed = now - gameStartedOverlayStartTime;
                    let opacity = 1;
                    let currentTitleFontSize;

                    // Phase 1: Zoom In
                    if (elapsed < OVERLAY_ZOOM_DURATION) {
                        const zoomProgress = elapsed / OVERLAY_ZOOM_DURATION;
                        const initialSize = Math.floor(gameCanvas.height * INITIAL_OVERLAY_FONT_FACTOR); // Use gameCanvas.height
                        const targetSize = Math.floor(gameCanvas.height * MAX_OVERLAY_FONT_FACTOR); // Use gameCanvas.height
                        currentTitleFontSize = initialSize + (targetSize - initialSize) * zoomProgress;
                        opacity = 1; // Full opacity during zoom
                    }
                    // Phase 2: Fade Out (starts after zoom)
                    else {
                        const fadeElapsed = elapsed - OVERLAY_ZOOM_DURATION;
                        const fadeProgress = Math.min(1, fadeElapsed / OVERLAY_FADE_DURATION);
                        opacity = 1 - fadeProgress;
                        currentTitleFontSize = Math.floor(gameCanvas.height * MAX_OVERLAY_FONT_FACTOR); // Hold max size during fade // Use gameCanvas.height
                    }

                    if (opacity <= 0) {
                        gameStartedOverlayActive = false; // Deactivate once fully faded
                    } else {
                        ctx.save();
                        ctx.globalAlpha = opacity;
                        ctx.fillStyle = '#FFD700'; // Gold color for the title
                        ctx.font = `${currentTitleFontSize}px VT323`; // Use dynamic font size
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Add shadow
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; // Black shadow, slightly transparent
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 5;
                        ctx.shadowOffsetY = 5;

                        ctx.fillText("HARD DIVISION", gameCanvas.width / 2, gameCanvas.height / 2 - gameCanvas.height * 0.05); // Use gameCanvas.width/height
                        ctx.restore();
                    }
                }

                // Removed the word bubble drawing logic from here as per user request.
                // Event messages will now only appear in the dialogue area on the left.

                // Draw the "PRESS R TO RESTART" message or its particles if game is over
                // This block now draws if gameOver OR if the restart animation is active
                if (gameOver || restartTextAnimationActive) {
                    if (restartTextAnimationActive) {
                        const elapsed = now - restartTextAnimationStartTime;
                        const progress = elapsed / RESTART_TEXT_EXPLOSION_DURATION;

                        if (progress >= 1) {
                            restartTextAnimationActive = false;
                            restartTextParticles = []; // Clear particles once animation is done
                        } else {
                            for (let i = restartTextParticles.length - 1; i >= 0; i--) {
                                const particle = restartTextParticles[i];
                                const particleProgress = (now - particle.startTime) / RESTART_TEXT_EXPLOSION_DURATION;

                                if (particleProgress >= 1) {
                                    continue;
                                }

                                const opacity = 1 - particleProgress;
                                const moveDistance = particle.initialSpeed * elapsed; // Use elapsed for continuous movement

                                const currentX = particle.startX + particle.dirX * moveDistance;
                                const currentY = particle.startY + particle.dirY * moveDistance;

                                ctx.save();
                                ctx.globalAlpha = opacity;
                                ctx.fillStyle = particle.color;
                                // Ensure font size consistency
                                ctx.font = `${Math.floor(dynamicTileSize * 0.8 * (1 - particleProgress * 0.5))}px VT323`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(particle.char, currentX, currentY);
                                ctx.restore();
                            }
                        }
                    } else if (gameOver) { // Only draw static text if game is over AND no animation is active
                        ctx.fillStyle = '#FFD700'; // Gold color for restart message
                        ctx.font = `${Math.floor(currentRenderTileSize * 0.8)}px VT323`; // Use currentRenderTileSize for scaling
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText("PRESS R TO RESTART", gameCanvas.width / 2, gameCanvas.height / 2 + currentRenderTileSize * 1.5); // Use gameCanvas.width/height
                    }
                }

            } catch (error) {
                console.error("Error in animation loop:", error);
                stopAnimationLoop(); // Stop the loop to prevent further errors
                handleGameOver(); // Attempt to gracefully end the game
            }
        }

        /**
         * Moves an entity (player or enemy) towards a target, considering obstacles.
         * @param {object} entity - The entity to move ({x, y}).
         * @param {number} targetX - The target X coordinate.
         * @param {number} targetY - The target Y coordinate.
         * @param {Array<object>} obstacles - An array of other entities (excluding the moving entity) to avoid.
         * @param {object|null} forbiddenTarget - An optional tile that the entity explicitly cannot move onto.
         * @returns {boolean} True if the entity moved, false otherwise.
         */
        function moveEntityTowardsTarget(entity, targetX, targetY, obstacles, forbiddenTarget = null) {
            // Validate entity position before attempting to move
            if (isNaN(entity.x) || isNaN(entity.y) || entity.x === null || entity.y === null) {
                console.error("Entity position is invalid. Cannot move.");
                return false;
            }

            const dxToTarget = targetX - entity.x;
            const dyToTarget = targetY - entity.y;

            let moveX = 0;
            let moveY = 0;

            // Prioritize movement along the axis with the greater distance
            if (Math.abs(dxToTarget) > Math.abs(dyToTarget)) {
                moveX = Math.sign(dxToTarget);
            } else {
                moveY = Math.sign(dyToTarget);
            }

            let newX = entity.x + moveX;
            let newY = entity.y + moveY;

            // Check if the primary move is valid
            if (newX < 0 || newX >= dynamicMapWidth || newY < 0 || newY >= dynamicMapHeight ||
                gameMap[newY][newX] === TILE_WALL ||
                obstacles.some(o => o.x === newX && o.y === newY) ||
                (forbiddenTarget && newX === forbiddenTarget.x && newY === forbiddenTarget.y)) {
                // If the primary move is blocked, try the other axis
                moveX = 0;
                moveY = 0;
                if (Math.abs(dxToTarget) > Math.abs(dyToTarget)) { // If X was primary, try Y
                    moveY = Math.sign(dyToTarget);
                } else { // If Y was primary, try X
                    moveX = Math.sign(dxToTarget);
                }
                newX = entity.x + moveX;
                newY = entity.y + moveY;
            }

            // Final check for the chosen move (either primary or secondary)
            if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                (gameMap[newY][newX] === TILE_FLOOR || gameMap[newY][newX] === TILE_STAIRS) &&
                !obstacles.some(o => o.x === newX && o.y === newY) &&
                !(forbiddenTarget && newX === forbiddenTarget.x && newY === forbiddenTarget.y)) {
                entity.x = newX;
                entity.y = newY;
                // Increment steps taken for enemies if they are moving
                if (entity.totalDamageDealtByThisEnemy !== undefined && entity.stepsTakenByThisEnemy !== undefined) { // Check if it's an enemy
                    entity.stepsTakenByThisEnemy = entity.stepsTakenByThisEnemy + 1; // Explicit assignment
                }
                return true; // Movement successful
            }

            return false; // Movement failed
        }

        /**
         * Adds a damage text animation to the queue.
         * @param {number} x - X coordinate of the hit entity.
         * @param {number} y - Y coordinate of the hit entity.
         * @param {number} amount - Damage amount.
         * @param {string} color - Color of the damage text.
         * @param {number} dirX - X component of the direction vector for animation.
         * @param {number} dirY - Y component of the direction vector for animation.
         * @param {number} duration - Duration of the animation in milliseconds.
         * @param {number} delay - Delay before animation starts in milliseconds.
         */
        function addDamageAnimation(x, y, amount, color, dirX, dirY, duration = 1000, delay = 0) {
            activeDamageTextAnimations.push({
                x: x,
                y: y,
                amount: amount,
                color: VINTAGE_GREEN,
                dirX: dirX,
                dirY: dirY,
                startTime: performance.now(),
                duration: duration,
                delay: delay
            });
        }

        /**
         * Creates a single particle for an explosion animation.
         * @param {number} x - X coordinate of the particle's origin.
         * @param {number} y - Y coordinate of the particle's origin.
         * @param {string} color - Color of the particle.
         * @param {number} initialVelocityX - Initial horizontal velocity.
         * @param {number} initialVelocityY - Initial vertical velocity.
         * @param {number} duration - Duration of the particle's animation.
         * @param {number} fadeFactor - A factor to control how quickly the particle fades.
         * @returns {object} Particle object.
         */
        function createParticle(x, y, color, initialVelocityX, initialVelocityY, duration, fadeFactor) {
            return {
                x: x,
                y: y,
                color: color,
                initialVelocityX: initialVelocityX,
                initialVelocityY: initialVelocityY,
                startTime: performance.now(),
                duration: duration,
                fadeFactor: fadeFactor
            };
        }

        /**
         * Adds an explosion animation at a given tile.
         * @param {number} tileX - X coordinate of the tile.
         * @param {number} tileY - Y coordinate of the tile.
         * @param {string} color - Color of the particles.
         * @param {number} damageAmount - The damage that caused the explosion (for scaling).
         * @param {number} numParticles - Number of particles in the explosion.
         * @param {number} duration - Duration of the explosion animation in milliseconds.
         * @param {number} [spreadFactor=1] - Multiplier for particle spread.
         */
        function addExplosionAnimation(tileX, tileY, color, damageAmount, numParticles = 15, duration = 1500, spreadFactor = 1) {
            const scaledNumParticles = Math.max(5, Math.min(numParticles + (damageAmount * 1), 50)); // Cap at 50 for performance

            const explosion = {
                particles: [],
                startTime: performance.now(),
                duration: duration,
                damageAmount: damageAmount
            };

            for (let i = 0; i < scaledNumParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                // Scale speed by the provided spreadFactor
                const speed = (Math.random() * 1.0 + 0.1) * (dynamicTileSize / 150) * spreadFactor;
                const initialVelocityX = Math.cos(angle) * speed;
                const initialVelocityY = Math.sin(angle) * speed;
                const randomFadeFactor = Math.random() * 0.7 + 0.3;
                explosion.particles.push(createParticle(tileX, tileY, color, initialVelocityX, initialVelocityY, duration, randomFadeFactor));
            }
            activeExplosions.push(explosion);
        }

        /**
         * Handles game over state.
         */
        function handleGameOver() {
            console.log("Game Over triggered.");
            gameOver = true;
            stopAutomatedMovement();
            // Do not stop animation loop here, enemies need to move and explosion needs to play
            window.removeEventListener('keydown', handleKeyDown); // Temporarily remove player movement listener

            // Activate death animation effects
            deathAnimationActive = true;
            deathAnimationStartTime = performance.now();
            timeScale = DEATH_SLOW_MOTION_FACTOR; // Activate slow motion

            // Capture player's final color
            const playerHealthRatio = player.health / PLAYER_VISUAL_HEALTH_THRESHOLD;
            const finalPlayerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD);

            // Player death animation: Explode and scatter numbers/symbols
            addExplosionAnimation(player.x, player.y, finalPlayerColor, player.health, PLAYER_DEATH_PARTICLE_COUNT, PLAYER_DEATH_EXPLOSION_DURATION, PLAYER_DEATH_PARTICLE_SPREAD_FACTOR);

            // Scatter player's "numbers" (health/damage dealt) and symbols as pickups
            let remainingValueToScatter = player.health;
            const scatterCount = Math.min(player.health + MATH_SYMBOLS.length, 50); // More particles for drama
            for (let i = 0; i < scatterCount; i++) {
                const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR; // Wider spread
                const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;

                let partContent;
                if (remainingValueToScatter > 0 && Math.random() < 0.7) { // Bias towards numbers initially
                    const value = Math.min(PLAYER_DEATH_PICKUP_VALUE_PER_CHUNK, remainingValueToScatter);
                    partContent = { type: 'number', value: value };
                    remainingValueToScatter = remainingValueToScatter - value; // Explicit assignment
                } else {
                    const symbol = MATH_SYMBOLS[getRandomInt(0, MATH_SYMBOLS.length - 1)];
                    partContent = { type: 'symbol', value: symbol };
                }

                staticDamageNumbers.push({
                    x: player.x,
                    y: player.y,
                    parts: [{ content: partContent, offsetX: randomOffsetX, offsetY: randomOffsetY }], // Changed 'amount' to 'content'
                    isEnemyDrop: false,
                    isPlayerRemains: true,
                    playerDeathColor: finalPlayerColor, // Store the player's death color with the remains
                    writhingOffsetAngle: Math.random() * Math.PI * 2, // Initial angle for writhing
                    writhingOffsetRadius: (Math.random() * 0.5 + 0.5) * dynamicTileSize * 0.1, // Small radius, slightly varied
                    writhingSpeed: (Math.random() * 0.0005 + 0.0002) // Very slow speed for subtle writhing
                });
            }
            // Ensure any remaining value is scattered as a final number if any
            if (remainingValueToScatter > 0) {
                const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;
                const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;
                staticDamageNumbers.push({
                    x: player.x,
                    y: player.y,
                    parts: [{ content: { type: 'number', value: remainingValueToScatter }, offsetX: randomOffsetX, offsetY: randomOffsetY }],
                    isEnemyDrop: false,
                    isPlayerRemains: true,
                    playerDeathColor: finalPlayerColor,
                    writhingOffsetAngle: Math.random() * Math.PI * 2,
                    writhingOffsetRadius: (Math.random() * 0.5 + 0.5) * dynamicTileSize * 0.1,
                    writhingSpeed: (Math.random() * 0.0005 + 0.0002)
                });
            }

            // Start enemy swarm behavior (animation loop is already running)
            startEnemySwarm();

            // Re-add event listener for restart only
            window.addEventListener('keydown', handleRestartKeyDown);
        }

        /**
         * Handles the 'R' key press for restarting the game.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleRestartKeyDown(event) {
            if (gameOver && (event.key === 'r' || event.key === 'R')) {
                event.preventDefault();

                // Get the position and size of the "PRESS R TO RESTART" text
                const restartText = "PRESS R TO RESTART";
                // Use dynamicTileSize for font sizing to match the game's current scale
                const baseFontSize = Math.floor(dynamicTileSize * 0.8);
                ctx.font = `${baseFontSize}px VT323`;
                const textMetrics = ctx.measureText(restartText);
                const textWidth = textMetrics.width;
                const textHeight = baseFontSize; // Approximate height based on font size

                const textX = gameCanvas.width / 2;
                const textY = gameCanvas.height / 2 + dynamicTileSize * 1.5;

                // Generate particles for each character
                restartTextParticles = [];
                let currentTextX = textX - textWidth / 2; // Start X for the first character
                const charSpacing = textWidth / restartText.length; // Simple even spacing

                for (let i = 0; i < restartText.length; i++) {
                    const char = restartText[i];
                    const charX = currentTextX + charSpacing * i + charSpacing / 2; // Center of the character
                    const charY = textY;

                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 0.5 + 0.2) * (dynamicTileSize / 20); // Slower, more controlled spread
                    const dirX = Math.cos(angle);
                    const dirY = Math.sin(angle);
                    const fadeFactor = Math.random() * 0.7 + 0.3;

                    restartTextParticles.push({
                        char: char,
                        startX: charX,
                        startY: charY,
                        dirX: dirX,
                        dirY: dirY,
                        initialSpeed: speed,
                        fontSize: baseFontSize, // Use the calculated baseFontSize for consistency
                        color: '#FFD700', // Gold color for the text particles
                        startTime: performance.now(),
                        duration: RESTART_TEXT_EXPLOSION_DURATION,
                        fadeFactor: fadeFactor
                    });
                }

                restartTextAnimationActive = true;
                restartTextAnimationStartTime = performance.now();

                // Immediately start the game restart (which includes the zoom-out)
                restartGame();
            }
        }

        /**
         * Restarts the game.
         */
        function restartGame() {
            window.removeEventListener('keydown', handleRestartKeyDown); // Remove restart listener
            initGame(true, false); // Start a brand new game, no overlay on restart
            // The animation loop is already running, no need to restart it here.
        }

        /**
         * Initiates enemy swarm behavior after player death.
         */
        function startEnemySwarm() {
            // This function ensures enemies continuously move towards player remains.
            // The actual movement logic is within enemyTurn().
            console.log("Enemies starting swarm behavior.");
        }

        /**
         * Checks the player's current tile for any static health pickups and collects them.
         */
        function checkAndCollectPickups() {
            for (let i = staticDamageNumbers.length - 1; i >= 0; i--) {
                const staticNum = staticDamageNumbers[i];
                // Only collect non-player-remains pickups
                if (!staticNum.isPlayerRemains && getDistance(player, staticNum) <= DIRECT_PICKUP_RADIUS) {
                    let healthGained = 0;
                    staticNum.parts.forEach(part => {
                        healthGained = healthGained + part.content.value; // Explicit assignment
                        activePickupAnimations.push({
                            startX: staticNum.x,
                            startY: staticNum.y,
                            initialOffsetX: part.offsetX || 0,
                            initialOffsetY: part.offsetY || 0,
                            amount: part.content.value, // Pass value from content
                            color: VINTAGE_GREEN,
                            startTime: performance.now(),
                            duration: 300
                        });
                    });
                    player.health = player.health + healthGained; // Explicit assignment
                    totalPickupValueCollectedThisTurn = totalPickupValueCollectedThisTurn + healthGained; // Explicit assignment
                    player.healthAnimScale = 1.5;
                    player.healthAnimStartTime = performance.now();
                    staticDamageNumbers.splice(i, 1);
                }
            }
        }

        /**
         * Applies health loss to the player based on steps taken.
         * Interval and damage are both inversely proportional to current health.
         */
        function applyStepBasedHealthLoss() {
            // Calculate dynamic interval based on health
            const MIN_INTERVAL = 10;  // Minimum steps between health loss (when health is high)
            const MAX_INTERVAL = 37;  // Maximum steps between health loss (when health is low)
            
            let dynamicInterval;
            if (player.health <= 1) {
                dynamicInterval = MAX_INTERVAL; // Lowest health = longest interval
            } else {
                // Use inverse proportion: interval = MAX_INTERVAL / (health)
                // Clamp to minimum interval to prevent too-frequent health loss at high health
                dynamicInterval = Math.max(MIN_INTERVAL, Math.floor(MAX_INTERVAL / player.health));
            }

            if (stepsTaken > 0 && stepsTaken % dynamicInterval === 0) {
                // Always lose 10% of current health (rounded)
                let damage = Math.round(player.health * 0.1);
                if (damage < 1 && player.health > 0) {
                    damage = 1;
                } else if (player.health === 0) {
                    damage = 0;
                }

                if (damage > 0) {
                    player.health = player.health - damage;
                    hitsTaken = hitsTaken + 1;
                    hitsTakenThisTurn = hitsTakenThisTurn + 1;
                    playerTookDamageInCombatThisTurn = true;
                    const animDuration = Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damage - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE));
                    addDamageAnimation(player.x, player.y, damage, VINTAGE_GREEN, 0, -1, animDuration, 0);
                }

                // Sanity check for player health after health loss
                if (isNaN(player.health)) {
                    console.error("Player health became NaN after step-based health loss! Forcing game over.");
                    player.health = 0;
                }

                if (player.health <= 0) {
                    player.health = 0; // Ensure health doesn't go negative for display
                    handleGameOver();
                }
            }
        }

        /**
         * Moves the player if the target tile is a floor or stairs.
         * Handles combat if the target tile is occupied by an enemy.
         * @param {number} dx - Change in X coordinate.
         * @param {number} dy - Change in Y coordinate.
         * @returns {boolean} True if combat occurred, false otherwise.
         */
        function movePlayer(dx, dy) {
            if (gameOver) return false;

            // Validate player position before attempting to move
            if (isNaN(player.x) || isNaN(player.y) || player.x === null || player.y === null) {
                console.error("Player position is invalid. Cannot move.");
                return false;
            }

            const newX = player.x + dx;
            const newY = player.y + dy;

            if (newX < 0 || newX >= dynamicMapWidth || newY < 0 || newY >= dynamicMapHeight) {
                return false;
            }

            const collidedEnemyIndex = enemies.findIndex(e => e.x === newX && e.y === newY);

            if (collidedEnemyIndex !== -1) {
                const attackedEnemy = enemies[collidedEnemyIndex];
                const enemyHealthBeforeHit = attackedEnemy.health; // Store health before hit
                const enemyInitialHealth = attackedEnemy.initialHealth; // Store initial health of this enemy

                let playerAttacksFirst = Math.random() < 0.5;

                let combatActionOccurred = false;
                let damageDealtToEnemy = 0; // Declare damageDealtToEnemy here
                let totalDamageDealtToEnemy = 0; // Track total damage dealt to enemy in this combat
                let totalDamageDealtToPlayer = 0; // Track total damage dealt to player in this combat

                combatOccurredThisTurn = true; // Mark that combat occurred this turn

                if (playerAttacksFirst) {
                    // Player attacks enemy
                    player.thrustAnimActive = true;
                    player.thrustAnimStartTime = performance.now();
                    player.thrustAnimDirectionX = dx;
                    player.thrustAnimDirectionY = dy;
                    const playerCurrentFlow = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0;
                    damageDealtToEnemy = getWeightedRandomInt(1, player.health, player.health, attackedEnemy.health, playerCurrentFlow); // Assign value
                    
                    // Critical Strike chance (e.g., 10% chance)
                    if (Math.random() < 0.1) {
                        damageDealtToEnemy = Math.floor(damageDealtToEnemy * CRITICAL_STRIKE_DAMAGE_MULTIPLIER);
                        addEventMessage("Critical Strike!");
                        eventFlags.criticalStrike = true; // Set flag for critical strike
                    } else {
                        eventFlags.criticalStrike = false; // Reset if no critical strike
                    }

                    damageDealtToEnemy = Math.min(damageDealtToEnemy, attackedEnemy.health);
                    player.thrustAnimMagnitude = Math.min(1, damageDealtToEnemy / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE); // Normalize damage for thrust magnitude

                    attackedEnemy.health = attackedEnemy.health - damageDealtToEnemy; // Explicit assignment
                    // MODIFIED: Enemy flow increases when attacked by player
                    attackedEnemy.totalDamageTakenByThisEnemy = (attackedEnemy.totalDamageTakenByThisEnemy || 0) + damageDealtToEnemy;
                    
                    hitsDealt = hitsDealt + 1; // Explicit assignment
                    totalDamageDealt = totalDamageDealt + damageDealtToEnemy; // Explicit assignment
                    damageDealtThisTurn = damageDealtThisTurn + damageDealtToEnemy; // Explicit assignment
                    addDamageAnimation(attackedEnemy.x, attackedEnemy.y, damageDealtToEnemy, VINTAGE_GREEN, dx, dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToEnemy - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));
                    combatActionOccurred = true;

                    if (attackedEnemy.health > 0) {
                        // Enemy counter-attacks player
                        attackedEnemy.thrustAnimActive = true;
                        attackedEnemy.thrustAnimStartTime = performance.now();
                        attackedEnemy.thrustAnimDirectionX = -dx; // Attack back towards player
                        attackedEnemy.thrustAnimDirectionY = -dy;
                        // Use enemy.totalDamageTakenByThisEnemy for enemy flow.
                        // If no damage taken yet, use enemy.flowLevel for initial flow.
                        const enemyCurrentFlow = attackedEnemy.totalDamageTakenByThisEnemy > 0
                            ? attackedEnemy.totalDamageTakenByThisEnemy / (attackedEnemy.stepsTakenByThisEnemy || 1)
                            : attackedEnemy.flowLevel;
                        let damageDealtToPlayer = getWeightedRandomInt(1, attackedEnemy.health, attackedEnemy.health, player.health, enemyCurrentFlow);
                        damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                        totalDamageDealtToPlayer = totalDamageDealtToPlayer + damageDealtToPlayer; // Track damage
                        attackedEnemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                        attackedEnemy.totalDamageDealtByThisEnemy = attackedEnemy.totalDamageDealtByThisEnemy + damageDealtToPlayer; // Explicit assignment

                        player.health = player.health - damageDealtToPlayer; // Explicit assignment
                        hitsTaken = hitsTaken + 1; // Explicit assignment
                        hitsTakenThisTurn = hitsTakenThisTurn + 1; // Explicit assignment
                        if (damageDealtToPlayer > 0) {
                            playerTookDamageInCombatThisTurn = true; // Player took damage in combat
                        }
                        addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, -dx, -dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)), 200);
                    }
                } else {
                    // Enemy attacks player first
                    attackedEnemy.thrustAnimActive = true;
                    attackedEnemy.thrustAnimStartTime = performance.now();
                    attackedEnemy.thrustAnimDirectionX = -dx;
                    attackedEnemy.thrustAnimDirectionY = -dy;
                    // Use enemy.totalDamageTakenByThisEnemy for enemy flow.
                    // If no damage taken yet, use enemy.flowLevel for initial flow.
                    const enemyCurrentFlow = attackedEnemy.totalDamageTakenByThisEnemy > 0
                        ? attackedEnemy.totalDamageTakenByThisEnemy / (attackedEnemy.stepsTakenByThisEnemy || 1)
                        : attackedEnemy.flowLevel;
                    let damageDealtToPlayer = getWeightedRandomInt(1, attackedEnemy.health, attackedEnemy.health, player.health, enemyCurrentFlow);
                    damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                    attackedEnemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                    attackedEnemy.totalDamageDealtByThisEnemy = attackedEnemy.totalDamageDealtByThisEnemy + damageDealtToPlayer; // Explicit assignment

                    player.health = player.health - damageDealtToPlayer; // Explicit assignment
                    hitsTaken = hitsTaken + 1; // Explicit assignment
                    hitsTakenThisTurn = hitsTakenThisTurn + 1; // Explicit assignment
                    if (damageDealtToPlayer > 0) {
                        playerTookDamageInCombatThisTurn = true; // Player took damage in combat
                    }
                    addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, -dx, -dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));
                    combatActionOccurred = true;

                    if (player.health > 0) {
                        // Player counter-attacks enemy
                        player.thrustAnimActive = true;
                        player.thrustAnimStartTime = performance.now();
                        player.thrustAnimDirectionX = dx;
                        player.thrustAnimDirectionY = dy;
                        const playerCurrentFlow = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0;
                                            damageDealtToEnemy = getWeightedRandomInt(1, player.health, player.health, attackedEnemy.health, playerCurrentFlow); // Assign value
                    
                    // Critical Strike chance (e.g., 10% chance)
                    if (Math.random() < 0.1) {
                        damageDealtToEnemy = Math.floor(damageDealtToEnemy * CRITICAL_STRIKE_DAMAGE_MULTIPLIER);
                        addEventMessage("Critical Strike!");
                        eventFlags.criticalStrike = true; // Set flag for critical strike
                    } else {
                        eventFlags.criticalStrike = false; // Reset if no critical strike
                    }

                    damageDealtToEnemy = Math.min(damageDealtToEnemy, attackedEnemy.health);
                    totalDamageDealtToEnemy = totalDamageDealtToEnemy + damageDealtToEnemy; // Track damage
                    player.thrustAnimMagnitude = Math.min(1, damageDealtToEnemy / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE); // Normalize damage for thrust magnitude

                    attackedEnemy.health = attackedEnemy.health - damageDealtToEnemy; // Explicit assignment
                        // MODIFIED: Enemy flow increases when attacked by player
                        attackedEnemy.totalDamageTakenByThisEnemy = (attackedEnemy.totalDamageTakenByThisEnemy || 0) + damageDealtToEnemy;
                        
                        hitsDealt = hitsDealt + 1; // Explicit assignment
                        totalDamageDealt = totalDamageDealt + damageDealtToEnemy; // Explicit assignment
                        damageDealtThisTurn = damageDealtThisTurn + damageDealtToEnemy; // Explicit assignment
                        addDamageAnimation(attackedEnemy.x, attackedEnemy.y, damageDealtToEnemy, VINTAGE_GREEN, dx, dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToEnemy - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)), 200);
                    }
                }

                if (attackedEnemy.health <= 0) {
                    // Calculate spread factor for explosion based on damage dealt
                    const explosionSpread = ENEMY_DEATH_EXPLOSION_BASE_SPREAD + (damageDealtToEnemy * ENEMY_DEATH_EXPLOSION_DAMAGE_SPREAD_MULTIPLIER);
                    addExplosionAnimation(attackedEnemy.x, attackedEnemy.y, FIXED_COLOR_ENEMY, enemyHealthBeforeHit, undefined, undefined, explosionSpread); // Pass explosionSpread

                    // MODIFIED: "One-Shot Kill" detection - only if enemy went from initial health to 0
                    if (attackedEnemy.initialHealth === enemyHealthBeforeHit && attackedEnemy.health <= 0) {
                        addEventMessage("One-Shot Kill!");
                        eventFlags.oneShotKill = true;
                    } else {
                        eventFlags.oneShotKill = false;
                    }

                    // Calculate pickup scatter magnitude based on damage dealt
                    const pickupScatterMagnitude = PICKUP_SCATTER_BASE_SPREAD + (damageDealtToEnemy * PICKUP_SCATTER_DAMAGE_MULTIPLIER);

                    // Enemy drops exactly the amount of health it had before the final hit
                    let remainingDroppedHealth = enemyHealthBeforeHit;

                    // Denominations for splitting
                    const denominations = [10, 5, 1]; // Prioritize larger denominations

                    while (remainingDroppedHealth > 0) {
                        const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * pickupScatterMagnitude;
                        const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * pickupScatterMagnitude;

                        let valueToDrop = 0;
                        for (const denom of denominations) {
                            if (remainingDroppedHealth >= denom) {
                                valueToDrop = denom;
                                break;
                            }
                        }
                        if (valueToDrop === 0 && remainingDroppedHealth > 0) {
                            valueToDrop = remainingDroppedHealth; // Drop remaining as a 1 if it's less than smallest denom
                        }

                        if (valueToDrop > 0) {
                            staticDamageNumbers.push({
                                x: attackedEnemy.x,
                                y: attackedEnemy.y,
                                parts: [{ content: { type: 'number', value: valueToDrop }, offsetX: randomOffsetX, offsetY: randomOffsetY }],
                                isEnemyDrop: true
                            });
                            remainingDroppedHealth -= valueToDrop;
                        } else {
                            break; // Should not happen if remainingDroppedHealth > 0
                        }
                    }

                    // Add activity log entry for the kill
                    addActivityLogEntry(player, attackedEnemy, totalDamageDealtToEnemy, totalDamageDealtToPlayer);
                    
                    enemies.splice(collidedEnemyIndex, 1);
                    enemiesKilledThisTurn = enemiesKilledThisTurn + 1; // Explicit assignment
                }

                // Sanity check for player health after combat
                if (isNaN(player.health)) {
                    console.error("Player health became NaN during combat! Forcing game over.");
                    player.health = 0; // Set to 0 to trigger game over
                }

                if (player.health <= 0) {
                    player.health = 0; // Ensure health doesn't go negative for display
                    handleGameOver();
                }
                // Always return true if combat occurred, regardless of outcome
                return true;
            }

            const obstaclesForPlayer = enemies;
            const playerMoved = moveEntityTowardsTarget(player, newX, newY, obstaclesForPlayer);

            if (playerMoved) {
                stepsTaken = stepsTaken + 1; // Explicit assignment
                // Mark current tile as visited for "Map Explorer"
                if (visitedTiles[player.y] && visitedTiles[player.y][player.x] !== undefined) {
                    visitedTiles[player.y][player.x] = true;
                }
                applyStepBasedHealthLoss();
                checkAndCollectPickups(); // Check for and collect pickups after moving

                if (player.x === stairs.x && player.y === stairs.y) {
                    nextLevel();
                }
                // Enemy turn is now called after player moves, regardless of combat
                enemyTurn();
                return false;
            }
            return false;
        }

        /**
         * Handles enemy turns. Each enemy moves based on its assigned role.
         */
        function enemyTurn() {
            // If game is over, enemies only swarm player remains
            if (gameOver) {
                enemies.forEach(enemy => {
                    const obstaclesForThisEnemy = enemies.filter(e => e !== enemy); // Enemies don't block each other if player is dead

                    // Find the closest player remains pickup
                    const closestPlayerRemains = getClosestEntity(staticDamageNumbers.filter(s => s.isPlayerRemains), enemy);

                    if (closestPlayerRemains) {
                        // Move towards the closest player remains
                        const moved = moveEntityTowardsTarget(enemy, closestPlayerRemains.x, closestPlayerRemains.y, obstaclesForThisEnemy, null);

                        // If enemy reached the remains, "eat" them
                        if (moved && enemy.x === closestPlayerRemains.x && enemy.y === closestPlayerRemains.y) {
                            const index = staticDamageNumbers.indexOf(closestPlayerRemains);
                            if (index > -1) {
                                staticDamageNumbers.splice(index, 1);
                                console.log(`Enemy ate player remains at (${closestPlayerRemains.x}, ${closestPlayerRemains.y})`);
                                // Increase enemy health by the amount of the eaten remains, only if it's a number
                                if (closestPlayerRemains.parts[0].content.type === 'number') {
                                    enemy.health = enemy.health + closestPlayerRemains.parts[0].content.value; // Explicit assignment
                                }
                            }
                        }
                    } else {
                        // If no more player remains, enemies can just wander or stay put
                        // For now, they'll just stand still if no remains are left.
                        // Could implement a random wander here if desired.
                    }
                });
                checkNotableEvents(); // Check events even if game over, for enemy swarm behavior
                // Reset per-turn stats after checkNotableEvents
                enemiesKilledThisTurn = 0;
                damageDealtThisTurn = 0;
                hitsTakenThisTurn = 0;
                totalPickupValueCollectedThisTurn = 0;
                combatOccurredThisTurn = false; // Reset for next turn
                playerTookDamageInCombatThisTurn = false; // Reset for next turn
                return; // Skip normal enemy turn logic if game over
            }

            const HUNTER_MOVE_CHANCE = 0.8;
            const GUARD_PATROL_RADIUS = 5;
            const GUARD_MOVE_CHANCE = 0.5;
            const TRACKER_AGGRO_RADIUS = 8;
            const GLOBAL_STOP_CHANCE = 0.2; // 20% chance for any enemy to stop

            enemies.forEach(enemy => {
                // Apply global random stop chance before any movement logic
                if (Math.random() < GLOBAL_STOP_CHANCE) {
                    // Enemy decided to stop this turn
                    return;
                }

                let enemyAttackedThisTurn = false; // Flag for this enemy's turn

                // Check for unprovoked attack if player is adjacent
                const isPlayerAdjacent = getDistance(enemy, player) <= 1.5; // Manhattan distance of 1 or diagonal
                if (isPlayerAdjacent) {
                    // Use enemy.totalDamageTakenByThisEnemy for enemy flow.
                    // If no damage taken yet, use enemy.flowLevel for initial flow.
                    const enemyCurrentFlow = enemy.totalDamageTakenByThisEnemy > 0
                        ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1)
                        : enemy.flowLevel;
                    const attackChance = Math.min(1.0, Math.max(0.0, enemyCurrentFlow)); // Clamp flow to 0-1 for probability

                    if (Math.random() < attackChance) {
                        // Enemy attacks unprovoked
                        enemy.thrustAnimActive = true;
                        enemy.thrustAnimStartTime = performance.now();
                        let dx = player.x - enemy.x; // Change to let
                        let dy = player.y - enemy.y; // Change to let
                        // Ensure attacks are cardinal only
                        if (Math.abs(dx) > 0 && Math.abs(dy) > 0) { // If diagonal, pick one axis
                            if (Math.random() < 0.5) dy = 0;
                            else dx = 0;
                        }

                        enemy.thrustAnimDirectionX = dx;
                        enemy.thrustAnimDirectionY = dy;

                        let damageDealtToPlayer = getWeightedRandomInt(1, enemy.health, enemy.health, player.health, enemyCurrentFlow);
                        damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                        enemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                        enemy.totalDamageDealtByThisEnemy = enemy.totalDamageDealtByThisEnemy + damageDealtToPlayer; // Explicit assignment

                        player.health = player.health - damageDealtToPlayer; // Explicit assignment
                        hitsTaken = hitsTaken + 1; // Explicit assignment
                        hitsTakenThisTurn = hitsTakenThisTurn + 1; // Explicit assignment
                        if (damageDealtToPlayer > 0) {
                            playerTookDamageInCombatThisTurn = true; // Player took damage in combat
                        }
                        addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, dx, dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));

                        // Sanity check for player health after combat
                        if (isNaN(player.health)) {
                            console.error("Player health became NaN during enemy unprovoked attack! Forcing game over.");
                            player.health = 0;
                        }
                        if (player.health <= 0) {
                            player.health = 0;
                            handleGameOver();
                            return; // Stop further enemy turns if game over
                        }
                        enemyAttackedThisTurn = true;
                    }
                }

                if (!enemyAttackedThisTurn) { // Only move if no unprovoked attack occurred
                    const obstaclesForThisEnemy = enemies.filter(e => e !== enemy).concat(player);
                    let moved = false; // Flag to track if enemy successfully moved

                    // New: Check enemy's flowLevel for following chance
                    // MODIFIED: Enemy flow is now based on totalDamageTakenByThisEnemy
                    if (Math.random() < (enemy.totalDamageTakenByThisEnemy > 0 ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1) : 0)) { // If random number is less than flowLevel, enemy follows
                        moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                    } else { // Otherwise, enemy performs its role-based movement
                        if (enemy.role === 'hunter') {
                            // Hunters always try to move towards the player if not following by flow
                            moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                        } else if (enemy.role === 'guard') {
                            if (stairs && stairs.x !== undefined && stairs.y !== undefined) {
                                const distToStairs = getDistance(enemy, stairs);

                                if (distToStairs > GUARD_PATROL_RADIUS) {
                                    moved = moveEntityTowardsTarget(enemy, stairs.x, stairs.y, obstaclesForThisEnemy, stairs);
                                } else {
                                    if (Math.random() < GUARD_MOVE_CHANCE) { // Guard-specific stop chance
                                        // Only cardinal directions for guard's random movement
                                        const cardinalDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                                        let bestMove = null;
                                        let minCombinedDistance = Infinity;

                                        for (const [dx, dy] of cardinalDirections) { // Iterate over cardinal directions
                                            const newX = enemy.x + dx;
                                            const newY = enemy.y + dy;

                                            if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                                                gameMap[newY][newX] === TILE_FLOOR && // Only move onto floor tiles
                                                !(newX === player.x && newY === player.y) &&
                                                !obstaclesForThisEnemy.some(o => o.x === newX && o.y === newY) &&
                                                (stairs && stairs.x !== undefined && stairs.y !== undefined && (newX !== stairs.x || newY !== stairs.y)) && // Explicitly avoid stairs
                                                (stairs && stairs.x !== undefined && stairs.y !== undefined && getDistance({x: newX, y: newY}, stairs) <= GUARD_PATROL_RADIUS + 1)) {

                                                const distToPlayer = getDistance({x: newX, y: newY}, player);
                                                const distToStairsFromNewPos = getDistance({x: newX, y: newY}, stairs);

                                                const combinedDistance = distToPlayer + distToStairsFromNewPos;

                                                if (combinedDistance < minCombinedDistance) {
                                                    minCombinedDistance = combinedDistance;
                                                    bestMove = {x: newX, y: newY};
                                                }
                                            }
                                        }

                                        if (bestMove) {
                                            enemy.x = bestMove.x;
                                            enemy.y = bestMove.y;
                                            moved = true; // Mark as moved
                                        }
                                    }
                                }
                            } else {
                                moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                            }
                        } else if (enemy.role === 'tracker') {
                            const distToPlayer = getDistance(enemy, player);
                            if (distToPlayer <= TRACKER_AGGRO_RADIUS) {
                                moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                            } else {
                                if (stairs && stairs.x !== undefined && stairs.y !== undefined) {
                                    moved = moveEntityTowardsTarget(enemy, stairs.x, stairs.y, obstaclesForThisEnemy, stairs);
                                } else {
                                    moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                                }
                            }
                        }
                    }
                }
            });

            checkNotableEvents(); // Check events after all entities have moved
            // Reset per-turn stats
            enemiesKilledThisTurn = 0;
            damageDealtThisTurn = 0;
            hitsTakenThisTurn = 0;
            combatOccurredThisTurn = false; // Reset for next turn
            playerTookDamageInCombatThisTurn = false; // Reset for next turn
            totalPickupValueCollectedThisTurn = 0;
        }

        /**
         * Adds an event message to be displayed on screen.
         * @param {string} text - The text of the event message.
         */
        function addEventMessage(text) {
            // Only add if not already active or recently shown (simple check for now)
            // Could add more sophisticated cooldowns per event type if needed
            if (!activeEventMessages.some(msg => msg.text === text)) {
                activeEventMessages.push({
                    text: text,
                    startTime: performance.now(),
                    duration: EVENT_TEXT_DURATION
                });
                addPlayerDialogue(text); // Call the new function to display player dialogue
            }
        }

        /**
         * Adds a new line of player dialogue to the dialogue area.
         * Function removed temporarily
         */
        function addPlayerDialogue(statusText) {
            // Dialogue system temporarily removed
            return;
        }

        /**
         * Counts the number of visited tiles in the `visitedTiles` grid.
         * @returns {number} The count of visited tiles.
         */
        function countVisitedTiles() {
            let count = 0;
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (visitedTiles[y] && visitedTiles[y][x]) {
                        count++;
                    }
                }
            }
            return count;
        }

        /**
         * Checks for notable game events based on current state and history.
         */
        function checkNotableEvents() {
            // 1. Store current state in history
            gameHistory.push({
                stepsTaken: stepsTaken,
                playerHealth: player.health,
                enemiesCount: enemies.length,
                hitsTaken: hitsTaken, // Global total
                totalDamageDealt: totalDamageDealt, // Global total
                playerX: player.x,
                playerY: player.y,
                enemiesPositions: enemies.map(e => ({ x: e.x, y: e.y })), // Store enemy positions
                pickupsOnMap: staticDamageNumbers.filter(s => !s.isPlayerRemains).map(p => ({ x: p.x, y: p.y, value: p.parts[0].content.value })),
                enemiesKilledThisTurn: enemiesKilledThisTurn,
                damageDealtThisTurn: damageDealtThisTurn,
                hitsTakenThisTurn: hitsTakenThisTurn,
                totalPickupValueCollectedThisTurn: totalPickupValueCollectedThisTurn,
                visitedTilesCount: countVisitedTiles(),
                combatOccurredThisTurn: combatOccurredThisTurn, // Store this turn's combat status
                playerTookDamageInCombatThisTurn: playerTookDamageInCombatThisTurn // Store if player took damage in combat this turn
            });

            if (gameHistory.length > HISTORY_LENGTH) {
                gameHistory.shift(); // Keep history size limited
            }

            const currentTurnState = gameHistory[gameHistory.length - 1];
            const previousTurnState = gameHistory.length > 1 ? gameHistory[gameHistory.length - 2] : null;

            // --- Event Detection Logic ---

            // 1. "Player Surrounded"
            let adjacentEnemiesCount = 0;
            const eightDirections = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dx, dy] of eightDirections) {
                const checkX = player.x + dx;
                const checkY = player.y + dy;
                if (enemies.some(e => e.x === checkX && e.y === checkY)) {
                    adjacentEnemiesCount = adjacentEnemiesCount + 1; // Explicit assignment
                }
            }
            if (adjacentEnemiesCount >= SURROUNDED_THRESHOLD && !eventFlags.playerSurrounded) {
                addEventMessage("Player Surrounded");
                eventFlags.playerSurrounded = true;
            } else if (adjacentEnemiesCount < SURROUNDED_THRESHOLD) {
                eventFlags.playerSurrounded = false; // Reset flag if no longer surrounded
            }

            // 2. "Near-Death Recovery"
            const wasLowHealthThreshold = PLAYER_VISUAL_HEALTH_THRESHOLD * NEAR_DEATH_HEALTH_RATIO;
            const recoveryThreshold = PLAYER_VISUAL_HEALTH_THRESHOLD * RECOVERY_HEALTH_GAIN_RATIO;

            if (player.health <= wasLowHealthThreshold && !player.wasLowHealth) {
                player.wasLowHealth = true;
                player.lowestHealthReached = player.health;
            } else if (player.wasLowHealth && player.health >= player.lowestHealthReached + recoveryThreshold) {
                if (!eventFlags.nearDeathRecovery) {
                    addEventMessage("Near-Death Recovery");
                    eventFlags.nearDeathRecovery = true;
                }
                player.wasLowHealth = false; // Reset for next low health event
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD; // Reset
            } else if (player.health > wasLowHealthThreshold && player.wasLowHealth && player.health < player.lowestHealthReached + recoveryThreshold) {
                // If health recovered but not enough for recovery event, reset low health flag
                player.wasLowHealth = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
                eventFlags.nearDeathRecovery = false; // Reset if conditions no longer met
            } else if (player.health > wasLowHealthThreshold && !player.wasLowHealth) {
                // If player health is healthy and was never low, ensure flag is false
                eventFlags.nearDeathRecovery = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
            }


            // 3. "Long Fight"
            if (gameHistory.length >= LONG_FIGHT_TURNS_THRESHOLD && enemies.length > 0) {
                let longFightDetected = true;
                const historySlice = gameHistory.slice(-LONG_FIGHT_TURNS_THRESHOLD); // Get the last N turns

                const initialEnemyCount = historySlice[0].enemiesCount;
                const initialHitsTakenInPeriod = historySlice[0].hitsTaken;
                const initialDamageDealtInPeriod = historySlice[0].totalDamageDealt;

                for (let i = 1; i < historySlice.length; i++) {
                    if (historySlice[i].enemiesCount !== initialEnemyCount ||
                        (historySlice[i].hitsTaken - initialHitsTakenInPeriod) === 0 || // No new hits taken
                        (historySlice[i].totalDamageDealt - initialDamageDealtInPeriod) === 0) { // No new damage dealt
                        longFightDetected = false;
                        break;
                    }
                }

                if (longFightDetected && !eventFlags.longFight) {
                    addEventMessage("Long Fight");
                    eventFlags.longFight = true;
                } else if (!longFightDetected) {
                    eventFlags.longFight = false;
                }
            } else {
                eventFlags.longFight = false;
            }

            // 4. "One-Shot Kill" - This is checked directly in movePlayer, no need to re-check here.

            // 5. "High-Value Pickups"
            let totalCollectedValueInRecentTurns = 0;
            for (let i = Math.max(0, gameHistory.length - PICKUP_SPREE_TURNS); i < gameHistory.length; i++) {
                totalCollectedValueInRecentTurns = totalCollectedValueInRecentTurns + (gameHistory[i].totalPickupValueCollectedThisTurn || 0); // Explicit assignment
            }
            if (totalCollectedValueInRecentTurns >= HIGH_VALUE_PICKUP_THRESHOLD && !eventFlags.highValuePickups) {
                addEventMessage("High-Value Pickups");
                eventFlags.highValuePickups = true;
            } else if (totalCollectedValueInRecentTurns < HIGH_VALUE_PICKUP_THRESHOLD) {
                eventFlags.highValuePickups = false;
            }

            // 6. "Enemy Overwhelm"
            let totalEnemyHealthAdjacent = 0;
            for (const [dx, dy] of eightDirections) {
                const checkX = player.x + dx;
                const checkY = player.y + dy;
                const adjacentEnemy = enemies.find(e => e.x === checkX && e.y === checkY);
                if (adjacentEnemy) {
                    totalEnemyHealthAdjacent = totalEnemyHealthAdjacent + adjacentEnemy.health; // Explicit assignment
                }
            }
            if (totalEnemyHealthAdjacent >= ENEMY_OVERWHELM_THRESHOLD && !eventFlags.enemyOverwhelm) {
                addEventMessage("Enemy Overwhelm");
                eventFlags.enemyOverwhelm = true;
            } else if (totalEnemyHealthAdjacent < ENEMY_OVERWHELM_THRESHOLD) {
                eventFlags.enemyOverwhelm = false;
            }

            // 7. "Strategic Retreat"
            if (gameHistory.length >= RETREAT_TURNS) {
                const stateBeforeRetreat = gameHistory[gameHistory.length - RETREAT_TURNS];
                const playerWasLowHealth = stateBeforeRetreat.playerHealth <= wasLowHealthThreshold;
                const playerIsNowHealthier = player.health > stateBeforeRetreat.playerHealth;
                const closestEnemyBefore = getClosestEntity(stateBeforeRetreat.enemiesPositions, {x: stateBeforeRetreat.playerX, y: stateBeforeRetreat.playerY});
                const closestEnemyNow = getClosestEntity(enemies, player);

                let distanceIncreased = false;
                if (closestEnemyBefore && closestEnemyNow) {
                    const distBefore = getDistance({x: stateBeforeRetreat.playerX, y: stateBeforeRetreat.playerY}, closestEnemyBefore);
                    const distNow = getDistance(player, closestEnemyNow);
                    distanceIncreased = distNow > distBefore + RETREAT_DISTANCE_INCREASE; // Moved at least X tiles further away
                }

                if (playerWasLowHealth && playerIsNowHealthier && distanceIncreased && !eventFlags.strategicRetreat) {
                    addEventMessage("Strategic Retreat");
                    eventFlags.strategicRetreat = true;
                } else if (!playerWasLowHealth || !playerIsNowHealthier || !distanceIncreased) {
                    eventFlags.strategicRetreat = false;
                }
            } else {
                eventFlags.strategicRetreat = false;
            }

            // 8. "Killing Spree"
            let enemiesKilledInRecentTurns = 0;
            for (let i = Math.max(0, gameHistory.length - KILLING_SPREE_COUNT); i < gameHistory.length; i++) {
                enemiesKilledInRecentTurns = enemiesKilledInRecentTurns + (gameHistory[i].enemiesKilledThisTurn || 0); // Explicit assignment
            }
            if (enemiesKilledInRecentTurns >= KILLING_SPREE_COUNT && !eventFlags.killingSpree) {
                addEventMessage("Killing Spree");
                eventFlags.killingSpree = true;
            } else if (enemiesKilledInRecentTurns < KILLING_SPREE_COUNT) {
                eventFlags.killingSpree = false;
            }

            // 9. "Unstoppable Force"
            if (gameHistory.length >= UNSTOPPABLE_TURNS) {
                const initialHitsTaken = gameHistory[gameHistory.length - UNSTOPPABLE_TURNS].hitsTaken;
                const initialDamageDealt = gameHistory[gameHistory.length - UNSTOPPABLE_TURNS].totalDamageDealt;

                const hitsTakenInPeriod = hitsTaken - initialHitsTaken;
                const damageDealtInPeriod = totalDamageDealt - initialDamageDealt;

                if (damageDealtInPeriod > 0 && hitsTakenInPeriod === 0 && !eventFlags.unstoppableForce) {
                    addEventMessage("Unstoppable Force");
                    eventFlags.unstoppableForce = true;
                } else if (hitsTakenInPeriod > 0 || damageDealtInPeriod === 0) {
                    eventFlags.unstoppableForce = false;
                }
            } else {
                eventFlags.unstoppableForce = false;
            }

            // 10. "Map Explorer"
            let newTilesVisitedInRecentTurns = 0;
            if (gameHistory.length >= EXPLORER_TURNS) {
                const initialVisitedCount = gameHistory[gameHistory.length - EXPLORER_TURNS].visitedTilesCount || 0;
                const currentVisitedCount = countVisitedTiles();
                newTilesVisitedInRecentTurns = currentVisitedCount - initialVisitedCount;
            }
            const totalMapTiles = dynamicMapWidth * dynamicMapHeight;
            const EXPLORER_THRESHOLD_TILES = totalMapTiles * EXPLORER_TILE_PERCENTAGE;

            if (newTilesVisitedInRecentTurns >= EXPLORER_THRESHOLD_TILES && !eventFlags.mapExplorer) {
                addEventMessage("Map Explorer");
                eventFlags.mapExplorer = true;
            } else if (newTilesVisitedInRecentTurns < EXPLORER_THRESHOLD_TILES) {
                eventFlags.mapExplorer = false;
            }

            // 11. "Cornered"
            let blockedDirections = 0;
            const allDirections = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dx, dy] of allDirections) {
                const checkX = player.x + dx;
                const checkY = player.y + dy;
                if (checkX < 0 || checkX >= dynamicMapWidth || checkY < 0 || checkY >= dynamicMapHeight ||
                    gameMap[checkY][checkX] === TILE_WALL ||
                    enemies.some(e => e.x === checkX && e.y === checkY)) {
                    blockedDirections = blockedDirections + 1; // Explicit assignment
                }
            }
            if (blockedDirections >= CORNERED_THRESHOLD && !eventFlags.cornered) {
                addEventMessage("Cornered");
                eventFlags.cornered = true;
            } else if (blockedDirections < CORNERED_THRESHOLD) {
                eventFlags.cornered = false;
            }

            // 12. "Stairs Blocked"
            if (stairs && stairs.x !== undefined && stairs.y !== undefined) {
                const path = findPathBasic(player.x, player.y, stairs.x, stairs.y, gameMap, dynamicMapWidth, dynamicMapHeight, enemies); // Enemies as strict obstacles
                if (!path && !eventFlags.stairsBlocked) {
                    addEventMessage("Stairs Blocked");
                    eventFlags.stairsBlocked = true;
                } else if (path) {
                    eventFlags.stairsBlocked = false;
                }
            } else {
                eventFlags.stairsBlocked = false; // Reset if stairs are not defined/valid
            }

            // NEW: 13. "Perfect Dodge"
            // Only check if combat occurred this turn and player took no damage from combat
            if (currentTurnState.combatOccurredThisTurn && !currentTurnState.playerTookDamageInCombatThisTurn && !eventFlags.perfectDodge) {
                addEventMessage("Perfect Dodge!");
                eventFlags.perfectDodge = true;
            } else if (!currentTurnState.combatOccurredThisTurn || currentTurnState.playerTookDamageInCombatThisTurn) {
                eventFlags.perfectDodge = false;
            }

            // NEW: 14. "Critical Strike!" - This is handled directly in movePlayer.

            // NEW: 15. "Flawless Victory" (for a level)
            // This needs to be checked when advancing to the next level, not every turn.
            // We'll add a check in `nextLevel()` or `initGame()` when `resetGameStats` is false.
        }

        /**
         * Advances the player to the next level.
         */
        function nextLevel() {
            // Check for "Flawless Victory" before resetting stats for the new level
            const previousLevelState = gameHistory.find(state => state.currentLevel === currentLevel); // Find state from the start of this level
            let totalDamageTakenThisLevel = 0;
            if (previousLevelState) {
                totalDamageTakenThisLevel = hitsTaken - previousLevelState.hitsTaken;
            }
            if (totalDamageTakenThisLevel === 0 && !eventFlags.flawlessVictory) {
                addEventMessage("Flawless Victory!");
                eventFlags.flawlessVictory = true;
            } else {
                eventFlags.flawlessVictory = false;
            }

            currentLevel = currentLevel + 1; // Explicit assignment
            initGame(false); // No overlay when progressing levels
        }

        /**
         * Stops all automated movement (P, E modes, or Tab-based full auto-move).
         */
        function stopAutomatedMovement() {
            if (autoMoveTimeoutId) {
                clearTimeout(autoMoveTimeoutId);
                autoMoveTimeoutId = null;
            }
            autoMode = null;
            autoMovePath = [];
            currentPathIndex = 0;
        }

        /**
         * Finds the closest entity from a list to the player, optionally within a radius.
         * @param {object[]} entities - The list of entities ({x, y}).
         * @param {object} playerPos - The player's current position {x, y}.
         * @param {number} radius - Optional maximum distance to consider. Defaults to Infinity.
         * @returns {object|null} The closest entity, or null if none found within radius.
         */
        function getClosestEntity(entities, playerPos, radius = Infinity) {
            let closest = null;
            let minDist = Infinity;
            entities.forEach(entity => {
                if (entity && typeof entity.x === 'number' && typeof entity.y === 'number') {
                    const dist = getDistance(playerPos, entity);
                    if (dist <= radius && dist < minDist) {
                        minDist = dist;
                        closest = entity;
                    }
                }
            });
            return closest;
        }

        /**
         * Starts the appropriate automated movement mode (P or E).
         * This function determines the target based on the active autoMode and initiates the pathfinding.
         */
        function startAutomatedMovement() {
            if (gameOver) {
                stopAutomatedMovement();
                return;
            }
            if (autoMode === null) return;

            if (autoMoveTimeoutId) {
                clearTimeout(autoMoveTimeoutId);
                autoMoveTimeoutId = null;
            }

            autoMovePath = [];
            currentPathIndex = 0;

            let targetDestination = null;
            let pathFunction = findPathBasic;
            let pathPenaltyEntities = [];

            const allEnemies = enemies;
            const allPickups = staticDamageNumbers.filter(s => !s.isPlayerRemains); // Only actual pickups, not player remains

            if (autoMode === 'stairs') {
                targetDestination = stairs;
                pathFunction = findPathWithProximityPenalty;
                pathPenaltyEntities = allEnemies;
            } else if (autoMode === 'enemies') {
                const closestGlobalEnemy = getClosestEntity(allEnemies, player);

                if (closestGlobalEnemy) {
                    const localEnemies = allEnemies.filter(e => getDistance(player, e) <= PICKUP_COLLECTION_RADIUS);
                    const closestLocalEnemy = getClosestEntity(localEnemies, player);

                    if (closestLocalEnemy) {
                        targetDestination = closestLocalEnemy;
                    } else {
                        const localPickups = allPickups.filter(p => getDistance(player, p) <= PICKUP_COLLECTION_RADIUS);
                        const closestLocalPickup = getClosestEntity(localPickups, player);

                        if (closestLocalPickup) {
                            targetDestination = closestGlobalEnemy;
                        } else {
                            targetDestination = closestGlobalEnemy;
                        }
                    }
                } else {
                    const localPickups = allPickups.filter(p => getDistance(player, p) <= PICKUP_COLLECTION_RADIUS);
                    const closestLocalPickup = getClosestEntity(localPickups, player);

                    if (closestLocalPickup) {
                        targetDestination = closestLocalPickup;
                    } else {
                        targetDestination = stairs;
                    }
                }
                pathFunction = findPathWithProximityPenalty; // Use proximity penalty for enemies mode too
                pathPenaltyEntities = allEnemies; // Avoid enemies even when targeting them, to path around.
            } else if (autoMode === 'highScore') {
                const isPlayerLowHealth = player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * HIGH_SCORE_LOW_HEALTH_THRESHOLD_RATIO;
                const allEnemiesPresent = enemies.length > 0;
                const allEnemiesAreStrong = allEnemies.every(e => e.health > player.health * HIGH_SCORE_WEAK_ENEMY_THRESHOLD_RATIO);

                const closestPickup = getClosestEntity(allPickups, player);
                const closestWeakEnemy = getClosestEntity(allEnemies.filter(e => e.health <= player.health * HIGH_SCORE_WEAK_ENEMY_THRESHOLD_RATIO), player);

                if (isPlayerLowHealth && closestPickup) {
                    targetDestination = closestPickup;
                    pathFunction = findPathWithProximityPenalty; // Use proximity penalty
                    pathPenaltyEntities = allEnemies; // Avoid all enemies
                } else if (closestWeakEnemy) {
                    targetDestination = closestWeakEnemy;
                    pathFunction = findPathWithProximityPenalty; // Use proximity penalty
                    pathPenaltyEntities = allEnemies.filter(e => e !== closestWeakEnemy); // Avoid other enemies
                } else if (closestPickup) { // Not low health, no weak enemies, but there are pickups
                    targetDestination = closestPickup;
                    pathFunction = findPathWithProximityPenalty; // Use proximity penalty
                    pathPenaltyEntities = allEnemies; // Avoid all enemies
                } else if (allEnemiesPresent && allEnemiesAreStrong) { // All enemies are strong, no pickups
                    targetDestination = stairs;
                    pathFunction = findPathWithProximityPenalty; // Use proximity penalty
                    pathPenaltyEntities = allEnemies; // Even if no enemies, this is fine.
                } else { // No enemies, no pickups, or all enemies are strong and we're heading to stairs
                    targetDestination = stairs;
                    pathFunction = findPathWithProximityPenalty; // Use proximity penalty
                    pathPenaltyEntities = allEnemies; // Even if no enemies, this is fine.
                }
            }


            if (targetDestination) {
                // For auto-movement, entities should avoid certain obstacles.
                // If the target is stairs, stairs should NOT be an obstacle.
                const entitiesToAvoidForAutoMove = [...pathPenaltyEntities];
                if (targetDestination !== stairs && stairs) { // Only add stairs to avoid if stairs are NOT the target
                    entitiesToAvoidForAutoMove.push(stairs);
                }
                const path = pathFunction(player.x, player.y, targetDestination.x, targetDestination.y, gameMap, dynamicMapWidth, dynamicMapHeight, entitiesToAvoidForAutoMove);
                if (path && path.length > 1) {
                    autoMovePath = path;
                    executeAutoMoveStep();
                } else {
                    console.warn(`No clear path found to target (${targetDestination.x}, ${targetDestination.y}). Stopping auto-movement.`);
                    stopAutomatedMovement();
                }
            } else {
                console.warn("No target destination for auto-movement. Stopping auto-movement.");
                stopAutomatedMovement();
            }
        }

        /**
         * Executes one step of the automated movement path for P/E modes.
         * This function is called recursively by setTimeout.
         */
        function executeAutoMoveStep() {
            if (gameOver || autoMode === null) {
                stopAutomatedMovement();
                return;
            }

            if (!autoMovePath || autoMovePath.length === 0 || currentPathIndex >= autoMovePath.length) {
                // If path is exhausted or invalid, try to find a new path (e.g., if new enemies spawned)
                autoMoveTimeoutId = setTimeout(startAutomatedMovement, AUTO_MOVE_SPEED);
                return;
            }

            const nextPos = autoMovePath[currentPathIndex];
            const dx = nextPos.x - player.x;
            const dy = nextPos.y - player.y;

            const combatOccurred = movePlayer(dx, dy);

            if (gameOver) {
                stopAutomatedMovement();
                return;
            }

            const delay = combatOccurred ? COMBAT_MOVE_DELAY : AUTO_MOVE_SPEED;

            // If player didn't move to the intended next position (e.g., blocked by a newly spawned enemy),
            // or if we are in 'stairs' mode and combat occurred (meaning we didn't reach stairs),
            // then recalculate path by calling startAutomatedMovement.
            // For 'highScore' mode, if combat occurred, we also want to re-evaluate the target.
            if (player.x !== nextPos.x || player.y !== nextPos.y || combatOccurred) { // Simplified condition
                autoMoveTimeoutId = setTimeout(startAutomatedMovement, delay);
                return;
            }

            currentPathIndex = currentPathIndex + 1; // Explicit assignment
            autoMoveTimeoutId = setTimeout(executeAutoMoveStep, delay);
        }

        /**
         * Handles keyboard input for player movement.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDown(event) {
            // If the game start overlay is active, any key press will dismiss it
            if (gameStartedOverlayActive) {
                gameStartedOverlayActive = false;
                event.preventDefault(); // Prevent default action for the key press
                return;
            }

            // Only process game input if the game is running (which it always is now after initial load)
            if (!isGameRunning) {
                return;
            }

            if (event.key === 'p' || event.key === 'P') {
                event.preventDefault();
                if (autoMode === 'stairs') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'stairs';
                    startAutomatedMovement();
                }
                return;
            }

            if (event.key === 'e' || event.key === 'E') {
                event.preventDefault();
                if (autoMode === 'enemies') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'enemies';
                    startAutomatedMovement();
                }
                return;
            }

            if (event.key === 'h' || event.key === 'H') {
                event.preventDefault();
                if (autoMode === 'highScore') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'highScore';
                    startAutomatedMovement();
                }
                return;
            }

            if (gameOver || autoMode !== null) {
                event.preventDefault();
                return;
            }

            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    movePlayer(1, 0);
                    break;
            }
        }

        /**
         * The main animation loop.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function animate(currentTime) {
            try {
                animationFrameId = requestAnimationFrame(animate);
                drawGame();
            }
            catch (error) {
                console.error("Error in animation loop:", error);
                stopAnimationLoop(); // Stop the loop to prevent further errors
                handleGameOver(); // Attempt to gracefully end the game
            }
        }

        /**
         * Starts the animation loop.
         */
        function startAnimationLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(animate);
        }

        /**
         * Stops the animation loop.
         */
        function stopAnimationLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        /**
         * Calculates the current score.
         */
        function calculateScore() {
            let score = 0;
            if (stepsTaken > 0) {
                const averageDamagePerTurn = totalDamageDealt / stepsTaken;
                score = Math.floor(totalDamageDealt * averageDamagePerTurn);
            }
            return score;
        }

        /**
         * Loads high scores from local storage. (Function kept for potential future use, not currently displayed)
         */
        function loadHighScores() {
            const storedScores = localStorage.getItem(HIGH_SCORES_STORAGE_KEY);
            if (storedScores) {
                highScores = JSON.parse(storedScores);
            } else {
                highScores = [];
            }
        }

        /**
         * Saves high scores to local storage. (Function kept for potential future use, not currently displayed)
         */
        function saveHighScores() {
            localStorage.setItem(HIGH_SCORES_STORAGE_KEY, JSON.stringify(highScores));
        }

        /**
         * Adds a new score to the high scores list. (Function kept for potential future use, not currently displayed)
         * @param {string} name - Player's name.
         * @param {number} score - Player's score.
         */
        function addHighScore(name, score) {
            highScores.push({ name: name, score: score });
            highScores.sort((a, b) => b.score - a.score); // Sort descending
            highScores = highScores.slice(0, MAX_HIGH_SCORES); // Keep only top N
            saveHighScores();
        }

        /**
         * Calculates the target dynamicTileSize for a given level based on current canvas dimensions.
         * @param {number} level - The level for which to calculate the target tile size.
         * @returns {number} The calculated target tile size.
         */
        function calculateTargetTileSize(level) {
            const initialMaxTileSize = Math.floor(Math.min(gameCanvas.width / MAX_VISIBLE_TILES_LEVEL1, gameCanvas.height / MAX_VISIBLE_TILES_LEVEL1));
            const finalMinTileSize = Math.floor(Math.min(gameCanvas.width / MIN_VISIBLE_TILES_MAX_LEVEL, gameCanvas.height / MIN_VISIBLE_TILES_MAX_LEVEL));
            let calculated = initialMaxTileSize - ((Math.min(level, ZOOM_LEVELS_EFFECTIVE) - 1) * (initialMaxTileSize - finalMinTileSize) / (ZOOM_LEVELS_EFFECTIVE - 1));
            return Math.max(finalMinTileSize, Math.floor(calculated));
        }

        /**
         * Initializes the game for a new level or a new game.
         * @param {boolean} resetGameStats - Whether to reset all game statistics.
         * @param {boolean} showGameStartOverlay - Whether to show the "HARD DIVISION" overlay.
         */
        function initGame(resetGameStats = true, showGameStartOverlay = false) {
            const wasGameOver = gameOver; // Capture state before resetting gameOver
            gameOver = false;
            window.addEventListener('keydown', handleKeyDown);
            
            // Ensure currentLevel has a valid value before using it
            if (resetGameStats || currentLevel === undefined || currentLevel === null) {
                currentLevel = 1; // Initialize currentLevel first
            }
            
            // Set initial map dimensions based on current level
            const BASE_MAP_DIMENSION = 7;
            dynamicMapWidth = BASE_MAP_DIMENSION + Math.floor((currentLevel - 1) * 0.5);
            dynamicMapHeight = BASE_MAP_DIMENSION + Math.floor((currentLevel - 1) * 0.5);
            
            const MAX_MAP_DIMENSION = 60;
            dynamicMapWidth = Math.min(dynamicMapWidth, MAX_MAP_DIMENSION);
            dynamicMapHeight = Math.min(dynamicMapHeight, MAX_MAP_DIMENSION);

            // Initialize visited tiles grid
            visitedTiles = Array(dynamicMapHeight).fill(null).map(() => Array(dynamicMapWidth).fill(false));
            
            // Initialize core game objects
            if (!player) {
                player = { 
                    x: 0, 
                    y: 0, 
                    health: 1, 
                    name: generateAgentName(), 
                    healthAnimScale: 1, 
                    healthAnimStartTime: 0, 
                    thrustAnimActive: false, 
                    thrustAnimStartTime: 0, 
                    thrustAnimDirectionX: 0, 
                    thrustAnimDirectionY: 0, 
                    thrustAnimMagnitude: 0, 
                    lowestHealthReached: PLAYER_VISUAL_HEALTH_THRESHOLD, 
                    wasLowHealth: false, 
                    thrustAnimDuration: 200 
                };
            }
            
            if (!stairs) {
                stairs = { x: 0, y: 0 };
            }
            
            if (!enemies) {
                enemies = [];
            }
            
            if (resetGameStats) {
                player.x = 0; // Reset player position
                player.y = 0;
                // currentLevel already set above
                player.health = 1; // Set player health to 1 for new game/restart
                hitsDealt = 0;
                hitsTaken = 0;
                stepsTaken = 0;
                totalDamageDealt = 0;
                autoMode = null;
                // Reset death animation states
                deathAnimationActive = false;
                deathAnimationStartTime = 0;
                timeScale = 1;
                gameStartedOverlayActive = showGameStartOverlay; // This controls the fading overlay
                if (showGameStartOverlay) {
                    gameStartedOverlayStartTime = performance.now();
                }

                // IMPORTANT: Do NOT reset restartTextAnimationActive or restartTextParticles here
                // if we are coming from a game over state, as the animation needs to play out.
                // The drawGame loop will clear them once the animation duration is over.
                if (!wasGameOver) { // Only clear if it's a fresh start, not a restart from game over
                    restartTextAnimationActive = false;
                    restartTextParticles = [];
                }

                // Reset event tracking flags and history for a new game
                for (const key in eventFlags) {
                    eventFlags[key] = false;
                }
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
                player.wasLowHealth = false;

                // Reset activity log for new game
                activityLog = [];
                updateActivityLogDisplay();

            } else {
                // Heal player by current level number when advancing to a new level
                player.health = player.health + currentLevel; // Explicit assignment
                player.healthAnimScale = 1.5; // Trigger health animation
                player.healthAnimStartTime = performance.now();
                gameStartedOverlayActive = false; // Ensure it's off for level progression
            }
            player.healthAnimScale = 1;
            player.healthAnimStartTime = 0;
            activeDamageTextAnimations = [];
            activeExplosions = [];
            activePickupAnimations = []; // Reset pickup animations for new level
            staticDamageNumbers = []; // Clear all static pickups for new level/game
            activeEventMessages = []; // Clear active event messages

            // Reset per-turn stats
            enemiesKilledThisTurn = 0;
            damageDealtThisTurn = 0;
            hitsTakenThisTurn = 0;
            totalPickupValueCollectedThisTurn = 0;
            combatOccurredThisTurn = false; // Reset for new level
            playerTookDamageInCombatThisTurn = false; // Reset for new level

            const targetDynamicTileSizeForLevel = calculateTargetTileSize(currentLevel);

            if (resetGameStats) {
                // For a new game/restart, start zoomed in
                // Increase GAME_START_INITIAL_ZOOM_FACTOR for more zoom
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel * GAME_START_INITIAL_ZOOM_FACTOR);
                gameStartZoomActive = true;
                gameStartZoomStartTime = performance.now();
            } else {
                // For level progression, just set to the target size immediately
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel);
                gameStartZoomActive = false; // Ensure it's off for level progression
            }

            // Update map dimensions based on current level (using constants defined earlier)
            dynamicMapWidth = Math.min(
                BASE_MAP_DIMENSION + Math.floor((currentLevel - 1) * 0.5),
                MAX_MAP_DIMENSION
            );
            dynamicMapHeight = Math.min(
                BASE_MAP_DIMENSION + Math.floor((currentLevel - 1) * 0.5),
                MAX_MAP_DIMENSION
            );

            // Initialize visitedTiles grid
            visitedTiles = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(false));


            console.log(`Initializing Level ${currentLevel}. Map dimensions: ${dynamicMapWidth}x${dynamicMapHeight}`);

            let attempts = 0;
            const MAX_ATTEMPTS = 1000; // Max attempts to generate a connected map
            let mapGeneratedSuccessfully = false;

            // Map generation always happens now, as the game starts directly
            do {
                console.log(`Level ${currentLevel} - Map generation attempt: ${attempts + 1}`);
                initializeMap();
                generatePaths(dynamicMapWidth * dynamicMapHeight * 0.5);

                // Validate map has floor tiles
                let floorTilesFound = false;
                for (let y = 0; y < dynamicMapHeight; y++) {
                    for (let x = 0; x < dynamicMapWidth; x++) {
                        if (gameMap[y][x] === TILE_FLOOR) {
                            floorTilesFound = true;
                            break;
                        }
                    }
                    if (floorTilesFound) break;
                }
                
                if (!floorTilesFound) {
                    console.error("No floor tiles generated - retrying map generation");
                    continue;
                }

                // Place player
                findPlayerStartInCorner(); // This function now ensures player is on a floor tile
                
                // Validate player position
                if (player.x === undefined || player.y === undefined || 
                    player.x === null || player.y === null ||
                    !gameMap[player.y] || gameMap[player.y][player.x] !== TILE_FLOOR) {
                    console.error("Invalid player placement - retrying map generation");
                    continue;
                }

                // Mark player's starting tile as visited
                if (visitedTiles[player.y] && visitedTiles[player.y][player.x] !== undefined) {
                    visitedTiles[player.y][player.x] = true;
                }
                console.log(`Player placed at (${player.x}, ${player.y})`);

                // Place stairs
                placeStairsOppositeCorner(); // This function now ensures stairs are on a stairs tile
                console.log(`Stairs placed at (${stairs.x}, ${stairs.y})`);

                // Calculate player's average flow for new enemies
                const playerAverageFlowForNewEnemies = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0;

                // Spawn enemies
                // For level 1, pass 0 as levelHealthBonus to ensure enemy starts with 1 health
                // For other levels, pass player.health as before
                spawnEnemies(currentLevel === 1 ? 0 : player.health, playerAverageFlowForNewEnemies);

                // Spawn pickups for the current level
                spawnPickups();

                // Check path from player to stairs
                if (player.x !== undefined && player.y !== undefined && stairs.x !== undefined && stairs.y !== undefined) {
                    mapGeneratedSuccessfully = findPathBasic(player.x, player.y, stairs.x, stairs.y, gameMap, dynamicMapWidth, dynamicMapHeight, enemies) !== null;
                    console.log(`Path from player to stairs exists: ${mapGeneratedSuccessfully}`);
                } else {
                    mapGeneratedSuccessfully = false; // Cannot check path if player/stairs not valid
                    console.warn("Player or stairs not valid, map generation considered unsuccessful.");
                }

                attempts = attempts + 1; // Explicit assignment
                if (!mapGeneratedSuccessfully && attempts >= MAX_ATTEMPTS) {
                    console.warn(`Max map generation attempts (${MAX_ATTEMPTS}) reached for Level ${currentLevel}. Attempting to force a path.`);
                    // Force a path by creating a direct line of floor tiles from player to stairs
                    let currentPathX = player.x;
                    let currentPathY = player.y;
                    let pathSteps = 0;
                    const MAX_PATH_FORCING_STEPS = dynamicMapWidth * dynamicMapHeight * 2; // Safeguard

                    while ((currentPathX !== stairs.x || currentPathY !== stairs.y) && pathSteps < MAX_PATH_FORCING_STEPS) {
                        // Ensure current position is floor
                        if (gameMap[currentPathY] && gameMap[currentPathY][currentPathX] !== undefined) {
                            gameMap[currentPathY][currentPathX] = TILE_FLOOR;
                        }

                        const dx = stairs.x - currentPathX;
                        const dy = stairs.y - currentPathY;

                        if (dx !== 0 && dy !== 0) { // If both X and Y need to change
                            if (Math.abs(dx) > Math.abs(dy)) {
                                currentPathX = currentPathX + Math.sign(dx); // Explicit assignment
                            } else {
                                currentPathY = currentPathY + Math.sign(dy); // Explicit assignment
                            }
                        } else if (dx !== 0) { // Only X needs to change
                            currentPathX = currentPathX + Math.sign(dx); // Explicit assignment
                        } else if (dy !== 0) { // Only Y needs to change
                            currentPathY = currentPathY + Math.sign(dy); // Explicit assignment
                        }

                        // Ensure bounds for forced path
                        currentPathX = Math.max(0, Math.min(dynamicMapWidth - 1, currentPathX));
                        currentPathY = Math.max(0, Math.min(dynamicMapHeight - 1, currentPathY));

                        // Ensure the new step is floor, unless it's the stairs
                        if (currentPathX === stairs.x && currentPathY === stairs.y) {
                             gameMap[currentPathY][currentPathX] = TILE_STAIRS;
                        } else if (gameMap[currentPathY] && gameMap[currentPathY][currentPathX] !== undefined) {
                             gameMap[currentPathY][currentPathX] = TILE_FLOOR;
                        }
                        pathSteps = pathSteps + 1; // Explicit assignment
                    }
                    if (pathSteps >= MAX_PATH_FORCING_STEPS) {
                        console.error("Forced path generation hit max steps, likely stuck in an infinite loop logic. This should not happen with the new logic.");
                        // Fallback: Ensure stairs is at least TILE_STAIRS if loop exited prematurely
                        if (gameMap[stairs.y] && gameMap[stairs.y][stairs.x] !== undefined) {
                            gameMap[stairs.y][stairs.x] = TILE_STAIRS;
                        }
                    } else {
                        gameMap[stairs.y][stairs.x] = TILE_STAIRS; // Ensure stairs are still stairs at the end
                    }
                    mapGeneratedSuccessfully = true; // Path is now guaranteed
                    console.log("Forced a path from player to stairs.");
                }
            } while (!mapGeneratedSuccessfully);

            setupColors();
            // Animation loop is already started, no need to call startAnimationLoop() here.
            // It's continuously drawing the game.

            // If an auto-mode was active before initGame, restart it for the new level
            if (autoMode !== null) {
                startAutomatedMovement();
            }
        }

        // Handle canvas resizing for responsiveness
        function resizeCanvas() {
            // Get container dimensions
            const gameContainer = document.getElementById('gameContainer');
            const canvas = document.getElementById('gameCanvas');
            
            if (!gameContainer || !canvas) {
                console.error('Required elements not found:', { 
                    gameContainer: !!gameContainer, 
                    canvas: !!canvas 
                });
                return;
            }

            // Calculate the square size based on window dimensions - making it larger
            const maxSize = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.9);
            
            // Set the container dimensions
            gameContainer.style.width = `${maxSize}px`;
            gameContainer.style.height = `${maxSize}px`;
            
            // Set the canvas dimensions
            canvas.width = maxSize;
            canvas.height = maxSize;

            // Calculate new tile size
            const targetDynamicTileSizeForLevel = calculateTargetTileSize(currentLevel);

            // Update the tile size
            if (gameStartZoomActive) {
                // Let the zoom animation handle the tile size
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel * GAME_START_INITIAL_ZOOM_FACTOR);
            } else {
                // Set tile size directly
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel);
            }

            // Force a redraw
            drawGame();
        }

        // Wait for the DOM to be fully loaded before initializing
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded - Initializing game...');
            
            // Get canvas element and context
            gameCanvas = document.getElementById('gameCanvas');
            if (!gameCanvas) {
                console.error('Canvas element not found!');
                return;
            }
            
            ctx = gameCanvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context!');
                return;
            }
            
            console.log('Canvas and context successfully obtained');
            
            // Initialize the game
            initGame(true, true); // Reset game stats and show overlay
            
            // Set up event listeners
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('resize', resizeCanvas);
            
            // Initial canvas resize
            resizeCanvas();
            
            // Start the animation loop
            startAnimationLoop();
            
            console.log('Game initialization complete');
        });
    </script>
</body>
</html>
