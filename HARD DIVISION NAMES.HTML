<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hard Division - A Minimalist Turn-Based Roguelike</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --world-wall-color: #111111; /* Default wall color */
        }
        
        body {
            font-family: 'VT323', monospace;
            background-color: var(--world-wall-color, #111111); /* Use world wall color for entire screen */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #e2e8f0;
            overflow: hidden; /* Prevent body scrollbars */
        }
        
        .leaderboard {
            position: fixed;
            left: 10px;
            top: 10px;
            width: 180px;
            height: auto;
            background-color: transparent;
            border: none;
            padding: 5px;
            font-family: 'VT323', monospace;
            color: #e2e8f0;
            font-size: 16px;
            z-index: 1000;
            overflow: visible;
        }
        
        .leaderboard h3 {
            margin: 0 0 5px 0;
            text-align: left;
            color: #e2e8f0;
            font-size: 18px;
            border: none;
            padding: 0;
        }
        
        .leaderboard-entry {
            margin-bottom: 2px;
            padding: 0;
            background-color: transparent;
            font-size: 16px;
            line-height: 1.3;
            color: #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: baseline;
        }
        
        .leaderboard-rank {
            color: #e2e8f0;
            font-weight: bold;
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .leaderboard-name {
            color: #e2e8f0;
            font-size: 16px;
            margin-left: 5px;
            flex-shrink: 0;
        }
        
        .leaderboard-city {
            color: #888;
            font-size: 14px;
            margin-left: 5px;
            flex-shrink: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }
        
        .leaderboard-score {
            color: #e2e8f0;
            font-size: 16px;
            font-weight: bold;
            margin-left: 10px;
            flex-shrink: 0;
        }
        
        .game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            position: relative;
            background-color: transparent; /* Remove background, let body handle it */
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: transparent; /* Remove black background */
            position: relative;
        }

        .message-area {
            position: fixed;
            right: 20px;
            width: 350px;
            height: 60vh;
            top: 20vh;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 20px;
            pointer-events: none;
            background-color: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(4px);
            border-radius: 8px;
        }

        .message-filters {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            pointer-events: all;
            flex-shrink: 0;
        }

        .filter-label {
            font-family: 'VT323', monospace;
            color: #CCCCCC;
            font-size: 14px;
            margin-right: 5px;
        }

        .message-filter-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.5;
        }

        .message-filter-btn.active {
            opacity: 1;
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .message-filter-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .kill-message {
            font-family: 'VT323', monospace;
            color: #FFFFFF;
            font-size: 24px;
            text-align: right;
            opacity: 1.0;
            animation: fadeIn 0.3s ease-out;
            margin-bottom: 4px;
            padding: 6px 12px;
            border-radius: 6px;
            border-left: 4px solid #666;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kill-message.message-combat {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .kill-message.message-event {
            border-left-color: #ffd93d;
            background: rgba(255, 217, 61, 0.1);
        }

        .kill-message.message-pickup {
            border-left-color: #6bcf7f;
            background: rgba(107, 207, 127, 0.1);
        }

        .kill-message.message-progress {
            border-left-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }

        .message-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .message-content {
            flex: 1;
        }

        .event-message {
            font-family: 'VT323', monospace;
            color: #00FF00;
            font-size: 24px;
            text-align: right;
            opacity: 1;
            animation: fadeIn 0.3s ease-out;
        }

        .event-messages-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 10px;
            z-index: 3;
            pointer-events: none;
        }

        .event-title {
            padding: 5px 15px;
            background-color: #000000;
            font-family: 'VT323', monospace;
            color: #e2e8f0;
            font-size: 24px;
            animation: fadeIn 0.3s ease-out;
        }

        .event-message {
            padding: 5px 15px;
            background-color: #000000;
            font-family: 'VT323', monospace;
            color: #e2e8f0;
            font-size: 20px;
            animation: fadeIn 0.3s ease-out;
            opacity: 0.8;
        }

        .kill-message.major-event {
            background: rgba(255, 217, 61, 0.2) !important;
            border-left: 4px solid #ffd93d !important;
            border-radius: 4px;
            color: #ffffff;
            font-weight: bold;
        }

        .kill-message .warning-symbol {
            color: #ffaa00;
            font-weight: bold;
            margin-right: 4px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 0.8; transform: translateY(0); }
        }

        .dialogue-message {
            color: #FFFFFF; /* White text */
            border-radius: 10px;
            padding: 8px 12px; /* Smaller padding */
            margin-bottom: 4px; /* Smaller line spacing */
            align-self: flex-end; /* Align to the right for player messages */
            max-width: 80%; /* Don't take full width */
            font-size: 1.2rem; /* Smaller text */
            line-height: 1.3; /* Smaller line height */
            word-wrap: break-word; /* Ensure long words break */
            /* Animation properties */
            opacity: 0;
            transform: translateY(100%);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out; /* Smooth transition for slide-in */
        }

        /* Activity log styles */
        .activity-log-entry {
            color: #FFFFFF;
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 4px;
            font-size: 1.3rem;
            line-height: 1.4;
            word-wrap: break-word;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .activity-log-entry.dimmed {
            opacity: 0.4;
        }

        .activity-log-entry .player-name {
            font-weight: bold;
        }

        .activity-log-entry .enemy-name {
            font-weight: bold;
        }

        .activity-log-entry .damage-comparison {
            font-size: 0.9rem;
            margin-top: 2px;
            opacity: 0.8;
        }

        canvas {
            background-color: #000; /* Black background like the game */
            border: none; /* Remove debug border */
            touch-action: none;
            display: block;
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .side-panel {
                width: 180px; /* Slightly narrower on medium screens */
            }
        }

        @media (max-width: 768px) {
            .game-wrapper {
                width: 100vw;
                height: 100vh;
                background-color: var(--world-wall-color);
            }
            .game-container {
                width: 90vh;
                height: 100vh;
            }
            .message-area {
                right: 10px;
                width: 280px;
                height: 50vh;
                top: 25vh;
                background-color: rgba(0, 0, 0, 0.4);
                padding: 15px;
            }
            .leaderboard {
                left: 10px;
                top: 10px;
                width: 200px;
                height: 280px;
                background-color: rgba(0, 0, 0, 0.4);
            }
            canvas {
                width: 90vh;
                height: 100vh;
            }
        }
    </style>
</head>
<body>
    <div class="leaderboard" id="leaderboard">
        <h3>TOP 10 SCORES</h3>
        <div id="leaderboard-content">
            Loading scores...
        </div>
    </div>
    <div class="game-wrapper">
        <div id="gameContainer" class="game-container">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div id="messageArea" class="message-area">
            <div class="message-filters">
                <span class="filter-label">Filters:</span>
                <button id="filterCombat" class="message-filter-btn active" title="Combat Messages">‚öîÔ∏è</button>
                <button id="filterEvent" class="message-filter-btn active" title="Event Messages">üéØ</button>
                <button id="filterPickup" class="message-filter-btn active" title="Pickup Messages">üíä</button>
                <button id="filterProgress" class="message-filter-btn active" title="Progress Messages">üèÜ</button>
            </div>
        </div>
    </div>

    <script>
        // Geolocation and Leaderboard variables
        let playerLocation = { city: 'Unknown', country: 'Unknown' };
        let playerName = '';
        let leaderboard = [];
        
        // Game constants
        const CANVAS_WIDTH_INITIAL = 730; // Initial canvas width for logical scaling
        const CANVAS_HEIGHT_INITIAL = 730; // Initial canvas height for logical scaling

        const MAX_VISIBLE_TILES_LEVEL1 = 7; // Adjusted for closer zoom at level 1
        // MODIFIED: Decreased maximum zoom out by half (from 25 to 12.5)
        const MIN_VISIBLE_TILES_MAX_LEVEL = 12.5;
        const ZOOM_LEVELS_EFFECTIVE = 30;

        // Score box constants
        const SCORE_BOX_WIDTH = 120;
        const SCORE_BOX_HEIGHT = 25;  // Made narrower
        const SCORE_BOX_PADDING = 3;  // Reduced padding
        const SCORE_BOX_MARGIN = 0;

        // Health-based visual scaling constants (now act as thresholds, not caps)
        const PLAYER_VISUAL_HEALTH_THRESHOLD = 73;
        const ENEMY_VISUAL_HEALTH_THRESHOLD = 73;
        const MIN_HEALTH_FOR_VISUAL_EFFECTS = 1;
        const MIN_OPACITY_AT_LOW_HEALTH = 0.9; // Increased starting opacity again
        // New constants for Flow bias
        const BASE_FLOW_FOR_BIAS = 1.0;
        const FLOW_BIAS_STRENGTH = 0.5;

        // New constants for player death animation
        const PLAYER_DEATH_PARTICLE_COUNT = 50;
        const PLAYER_DEATH_PICKUP_VALUE_PER_CHUNK = 1;
        const PLAYER_DEATH_EXPLOSION_DURATION = 3000;
        const PLAYER_DEATH_PARTICLE_SPREAD_FACTOR = 2.5;

        // New constants for explosion and pickup scattering based on damage
        const ENEMY_DEATH_EXPLOSION_BASE_SPREAD = 1.0;
        const ENEMY_DEATH_EXPLOSION_DAMAGE_SPREAD_MULTIPLIER = 0.1; // Adjust this value to control how much damage affects spread
        const PICKUP_SCATTER_BASE_SPREAD = 1.5; // Original value for pickup scatter
        const PICKUP_SCATTER_DAMAGE_MULTIPLIER = 0.15; // Adjust this value to control how much damage affects pickup scatter

        // Mathematical symbols for player death
        const MATH_SYMBOLS = ['+', '-', '*', '/', '=', '>', '<', '%', '&', '!', '?', '^', '~', '|', '(', ')', '[', ']', '{', '}'];

        // World progression system
        const WORLDS = {
            1: {
                name: "Foundational Chambers",
                theme: "basic",
                description: "Simple rectangular rooms where mathematics begins",
                colors: {
                    floor: '#333333', // Medium gray floor
                    wall: '#111111',  // Dark gray walls
                    stairs: '#00FF00', // Green exit
                    player: '#0066FF', // Blue player
                    enemy: '#FF4444'   // Red enemy
                },
                mapGenerator: 'generateBasicMap',
                unlockRequirement: 0 // Always available
            }
        };        // World progression variables
        let currentWorld = 1;
        let unlockedWorlds = [1]; // World 1 is always unlocked
        let totalPlayerScore = 0; // Accumulated score across all runs

        // Tile size calculation

        // Tile types
        const TILE_WALL = 0;
        const TILE_FLOOR = 1;
        const TILE_STAIRS = 2;

        // Colors (consistent across gameplay and UI)
        let COLOR_WALL = '#000000'; // Black for walls (same as void)
        let COLOR_FLOOR = '#333333'; // Dark grey for playable floor tiles
        let FIXED_COLOR_PLAYER = '#0066FF'; // Blue player color
        let FIXED_COLOR_STAIRS = '#00FF00'; // Green stairs/exits
        let FIXED_COLOR_ENEMY = '#FF4444'; // Red enemies
        const VINTAGE_GREEN = '#00FF00';

        // Name generation utilities from namegen.html - exact implementation from namegen.html
        function hasVowel(str) {
          return /[aeiouyAEIOUY]/.test(str);
        }

        // Massively Expanded Phoneme lists from namegen.html
        const commonWordPhonemes = {
          start: [
            // Pure vowel starts
            'A', 'E', 'I', 'O', 'U', 'Ya', 'Ye', 'Yo', 'Yu', 'Ae', 'Io', 'Ou', 'Ui', 'Au', 'Ei',
            // Common Object/Concept Starts
            'Air', 'Arm', 'Box', 'Book', 'Card', 'Chair', 'Cloud', 'Desk', 'Door', 'Dust', 'Earth', 'Fire', 'Fork', 'Glass',
            'Hand', 'Head', 'Home', 'Hour', 'Key', 'Lamp', 'Leaf', 'Light', 'Line', 'Lock', 'Moon', 'Moun', 'Name', 'Page',
            'Pen', 'Pipe', 'Plan', 'Plas', 'Plate', 'Rain', 'Road', 'Rock', 'Room', 'Rope', 'Sand', 'Ship', 'Shoe', 'Sky',
            'Soap', 'Sofa', 'Star', 'Stee', 'Ston', 'Sun', 'Tab', 'Tail', 'Time', 'Tool', 'Top', 'Tree', 'Wall', 'Wat',
            'Whee', 'Wind', 'Wire', 'Wood', 'Word', 'Bell', 'Bowl', 'Brush', 'Cable', 'Chain', 'Coin', 'Comb', 'Couch', 'Cup',
            'Curtain', 'Dish', 'Drawer', 'Drum', 'Fence', 'Flag', 'Flute', 'Frame', 'Glove', 'Grain', 'Grape', 'Guard', 'Harp',
            'Hinge', 'Hole', 'Hook', 'Horn', 'Jacket', 'Jar', 'Jewel', 'Joint', 'Juice', 'Kettle', 'Kite', 'Knob', 'Lace', 'Ladder',
            'Lake', 'Lens', 'Lever', 'Lid', 'Loom', 'Loud', 'Magnet', 'Mask', 'Match', 'Metal', 'Meter', 'Mirror', 'Mist', 'Mop',
            'Mug', 'Nail', 'Net', 'Nook', 'Nut', 'Oar', 'Pad', 'Paint', 'Pan', 'Path', 'Pearl', 'Pillow', 'Pin', 'Plane',
            'Pond', 'Pool', 'Pot', 'Pouch', 'Pound', 'Pulp', 'Pump', 'Rack', 'Rail', 'Rake', 'Ramp', 'Ring', 'Rod', 'Roof',
            'Root', 'Rug', 'Ruler', 'Sack', 'Scale', 'Scoop', 'Screen', 'Seal', 'Seat', 'Shade', 'Shelf', 'Shell', 'Shield', 'Sign',
            'Slab', 'Slate', 'Sleeve', 'Slide', 'Slot', 'Smoke', 'Snare', 'Snow', 'Spade', 'Spoon', 'Spot', 'Spout', 'Spring',
            'Spool', 'Stair', 'Stamp', 'Stick', 'Stool', 'Strap', 'Straw', 'Stream', 'String', 'Strip', 'Stud', 'Swarm', 'Swing',
            'Switch', 'Table', 'Tank', 'Tape', 'Target', 'Thorn', 'Thread', 'Thumb', 'Tile', 'Tong', 'Torch', 'Tower', 'Track',
            'Train', 'Trap', 'Tray', 'Trowel', 'Trunk', 'Tube', 'Tug', 'Tune', 'Turf', 'Twine', 'Unit', 'Urn', 'Valve', 'Vase',
            'Veil', 'Vent', 'Vest', 'Vial', 'Vise', 'Wagon', 'Web', 'Wedge', 'Whale', 'Whirl', 'Wick', 'Wing', 'Wrench', 'Yoke',
            'Zest', 'Zone', 'Zorb',
            // Company Name Starts
            'Aero', 'Airb', 'Alib', 'Amaz', 'Amgen', 'Anhe', 'Astra', 'Audi', 'Baidu', 'Bayer', 'Berk', 'Black', 'Boe',
            'Canon', 'Cisco', 'Coca', 'Comc', 'Daim', 'Dell', 'Disn', 'DuPont', 'Face', 'Fid', 'Ford',
            'Gen', 'Gile', 'Goog', 'Hon', 'HP', 'Huan', 'Hyun', 'Intel', 'Master',
            'McDon', 'Merck', 'Meta', 'Micro', 'Neste', 'Nike', 'Nint', 'Oracle', 'Pana', 'Peps', 'Pfiz', 'Phil',
            'Qual', 'Riche', 'Roya', 'Sam', 'Siem', 'Spot', 'Starb', 'Suba', 'Targ', 'Tenc', 'Tes', 'Teva', 'Toyota',
            'Uber', 'Unile', 'Volks', 'Walm', 'Walt', 'Xiaom', 'Yaho', 'Yelp', 'Zara', 'Zoom', 'Zurich',
            // Country/City Name Starts
            'Aba', 'Abu', 'Accra', 'Adel', 'Addis', 'Agra', 'Algiers', 'Amman', 'Amst', 'Anka', 'Arg', 'Ashg', 'Astana', 'Ath',
            'Aus', 'Baku', 'Ban', 'Bang', 'Bei', 'Beir', 'Belg', 'Belm', 'Ber', 'Bog', 'Boha', 'Bol', 'Bra', 'Bras', 'Brat',
            'Braz', 'Bru', 'Buda', 'Bue', 'Bukh', 'Cai', 'Canb', 'Cara', 'Casab', 'Che', 'Chi', 'Copen', 'Col', 'Cona', 'Cop',
            'Coru', 'Cro', 'Daka', 'Dam', 'Dar', 'Del', 'Den', 'Dhaka', 'Doha', 'Dub', 'Edin', 'Egy', 'Eth', 'Fin', 'Fra',
            'Fuji', 'Gab', 'Gabo', 'Ger', 'Gha', 'Gree', 'Guat', 'Hano', 'Har', 'Hel', 'Ho', 'Hon', 'Hung', 'Ice', 'Ind',
            'Ira', 'Ire', 'Isr', 'Ista', 'Ita', 'Jak', 'Jam', 'Jap', 'Jeru', 'Johan', 'Jor', 'Kab', 'Kam', 'Kar', 'Kaz',
            'Ken', 'Kha', 'Kie', 'Kin', 'Kish', 'Kua', 'Kuw', 'Lag', 'Lao', 'Leb', 'Lis', 'Ljub', 'Lon', 'Los', 'Luanda',
            'Madr', 'Mal', 'Man', 'Manil', 'Mapu', 'Mex', 'Min', 'Monro', 'Monte', 'Mos', 'Mumb', 'Mus', 'Nair', 'Nass', 'Nep',
            'New', 'Nic', 'Nis', 'Nor', 'Os', 'Ott', 'Pak', 'Pal', 'Pan', 'Par', 'Peki', 'Peru', 'Phil', 'Pol', 'Port',
            'Prag', 'Pret', 'Puer', 'Qat', 'Quito', 'Rab', 'Rey', 'Riga', 'Riy', 'Rom', 'Rus', 'San', 'Sao', 'Sar', 'Sau',
            'Scot', 'Seo', 'Ser', 'Sing', 'Sko', 'Slo', 'Sof', 'Sou', 'Spa', 'Sri', 'Stoc', 'Sud', 'Swe', 'Swit', 'Syd',
            'Syr', 'Tai', 'Tan', 'Teh', 'Thai', 'Thi', 'Tir', 'Tok', 'Trip', 'Tun', 'Tur', 'Ugan', 'Ukra', 'Uni', 'Uru',
            'Val', 'Ven', 'Vie', 'Viet', 'Vil', 'War', 'Was', 'Wel', 'Wien', 'Yem', 'Zag', 'Zim'
          ].filter(hasVowel),

          middle: [
            'a', 'e', 'i', 'o', 'u', 'y', 'an', 'en', 'in', 'on', 'un', 'am', 'em', 'im', 'om', 'um',
            'ar', 'er', 'ir', 'or', 'ur', 'as', 'es', 'is', 'os', 'us', 'at', 'et', 'it', 'ot', 'ut',
            'ax', 'ex', 'ix', 'ox', 'ux', 'ay', 'ey', 'oy', 'ow', 'ou', 'ea', 'ee', 'ie', 'oa', 'oo'
          ],

          end: [
            'a', 'e', 'i', 'o', 'u', 'y', 'ah', 'al', 'an', 'ar', 'as', 'at', 'ay', 'el', 'en', 'er',
            'es', 'et', 'il', 'in', 'ir', 'is', 'it', 'ol', 'on', 'or', 'os', 'ot', 'ul', 'un', 'ur',
            'us', 'ut', 'ice', 'ide', 'ile', 'ine', 'ing', 'ion', 'ive', 'ize', 'ode', 'oke', 'ole',
            'ome', 'one', 'ore', 'ose', 'ote', 'ove', 'owl', 'own', 'ule', 'une', 'ure'
          ].filter(hasVowel)
        };

        function randomFrom(array) {
          if (array.length === 0) return '';
          return array[Math.floor(Math.random() * array.length)];
        }

        function buildName(phonemes, syllables = 3) {
          let name = '';
          if (syllables <= 0) return '';

          // Always start with a 'start' phoneme
          name += randomFrom(phonemes.start);

          // Add 'middle' phonemes for intermediate syllables
          for (let i = 1; i < syllables - 1; i++) {
            name += randomFrom(phonemes.middle);
            // 20% chance to repeat a middle phoneme
            if (Math.random() < 0.2 && i < syllables - 2) {
              name += randomFrom(phonemes.middle);
            }
          }

          // End with an 'end' phoneme for the last syllable, if more than 1 syllable
          if (syllables > 1) {
                name += randomFrom(phonemes.end);
            }

            // Capitalize the first letter of the generated name
            return name.charAt(0).toUpperCase() + name.slice(1);
        }

        function generateAgentName() {
          let firstName, lastName;
          const MAX_COMBINED_LENGTH = 9; // Maximum total characters excluding the space
          const MIN_COMBINED_LENGTH = 5; // Minimum total characters excluding the space

          do {
            // Randomly choose 1 or 2 syllables for the first name
            const firstSyllables = Math.floor(Math.random() * 2) + 1; // Generates 1 or 2
            // Randomly choose 1 or 2 syllables for the last name
            const lastSyllables = Math.floor(Math.random() * 2) + 1; // Generates 1 or 2

            firstName = buildName(commonWordPhonemes, firstSyllables);
            lastName = buildName(commonWordPhonemes, lastSyllables);

          } while (firstName.length + lastName.length > MAX_COMBINED_LENGTH ||
                   firstName.length + lastName.length < MIN_COMBINED_LENGTH ||
                   !hasVowel(firstName) || !hasVowel(lastName));

          return `${firstName} ${lastName}`;
        }

        // Game state variables are declared below with 'let' and initialized in initGame()
        // Player and enemy objects now include thrust animation properties

        // Activity log state
        let activityLog = [];
        const MAX_ACTIVITY_LOG_ENTRIES = 10;

        // Killed enemies tracking for events
        let killedEnemiesThisTurn = [];

        // New global state for death animation
        let deathAnimationActive = false;
        let deathAnimationStartTime = 0;
        const DEATH_ZOOM_DURATION = 1000; // Reduced for quicker zoom
        const DEATH_SLOW_MOTION_FACTOR = 0.2;
        const DEATH_ZOOM_TARGET_TILE_SCALE = 1.0; // Reduced for less zoom-in after death
        let timeScale = 1; // Global time scale for animations

        // Title overlay constants
        const OVERLAY_ZOOM_DURATION = 1000;
        const OVERLAY_FADE_DURATION = 2000;
        const GAME_START_OVERLAY_DURATION = OVERLAY_ZOOM_DURATION + OVERLAY_FADE_DURATION;
        const INITIAL_OVERLAY_FONT_FACTOR = 0.12;
        const MAX_OVERLAY_FONT_FACTOR = 0.15;

        // New constants for game start/restart zoom out
        // MODIFIED: Decreased zoom out rate by half (from 3000 to 6000)
        const GAME_START_ZOOM_OUT_DURATION = 6000;
        const GAME_START_INITIAL_ZOOM_FACTOR = 2.5; // Decreased for less initial zoom
        const RESTART_TEXT_EXPLOSION_DURATION = 2000; // Increased duration for slower explosion (This constant is globally accessible)

        // Game start zoom state
        let gameStartZoomStartTime = 0;

        // Title screen state
        let gameStartedOverlayStartTime = 0;

        // Restart text animation state
        let restartTextAnimationActive = false;
        let restartTextAnimationStartTime = 0;
        let restartTextParticles = [];

        // Game running state (always true after initial load now)
        let isGameRunning = true; // Game is always running after initial load now

        // Game statistics
        let hitsDealt = 0;
        let hitsTaken = 0;
        let stepsTaken = 0;
        let totalDamageDealt = 0;
        const HEALTH_LOSS_INTERVAL = 37;

        // Auto-movement state
        let autoMode = null;
        let autoMovePath = [];
        let currentPathIndex = 0;
        let autoMoveTimeoutId = null;

        // Auto-move speed variables
        const DEFAULT_AUTO_MOVE_SPEED = 100; // Back to original fast speed
        let AUTO_MOVE_SPEED = DEFAULT_AUTO_MOVE_SPEED;
        const COMBAT_MOVE_DELAY = 500;
        const PICKUP_COLLECTION_RADIUS = 7;
        const DIRECT_PICKUP_RADIUS = 1.5;

        // Pathfinding cache for performance optimization
        let pathfindingCache = new Map();
        let cacheValidationFrame = 0;

        // Spatial indexing for entity management optimization
        let spatialIndex = new Map(); // Grid-based spatial index for fast entity queries
        let spatialGridSize = 8; // Grid cell size for spatial indexing
        let spatialIndexValid = false;

        // Performance monitoring
        let performanceStats = {
            pathfindingCalls: 0,
            cacheHits: 0,
            cacheMisses: 0,
            lastResetTime: performance.now()
        };

        /**
         * Log performance statistics periodically
         */
        function logPerformanceStats() {
            const now = performance.now();
            const elapsedSeconds = (now - performanceStats.lastResetTime) / 1000;
            
            if (elapsedSeconds >= 10) { // Log every 10 seconds
                const hitRate = performanceStats.pathfindingCalls > 0 
                    ? (performanceStats.cacheHits / performanceStats.pathfindingCalls * 100).toFixed(1) 
                    : 0;
                
                console.log(`Performance Stats (${elapsedSeconds.toFixed(1)}s):`, {
                    pathfindingCalls: performanceStats.pathfindingCalls,
                    cacheHitRate: `${hitRate}%`,
                    cacheSize: pathfindingCache.size,
                    spatialIndexValid: spatialIndexValid
                });
                
                // Reset stats
                performanceStats.pathfindingCalls = 0;
                performanceStats.cacheHits = 0;
                performanceStats.cacheMisses = 0;
                performanceStats.lastResetTime = now;
            }
        }

        /**
         * Rebuild spatial index for all entities
         */
        function rebuildSpatialIndex() {
            spatialIndex.clear();
            
            // Index all enemies
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                addToSpatialIndex(enemy, 'enemy', i);
            }
            
            // Index all items
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                addToSpatialIndex(item, 'item', i);
            }
            
            // Index player
            if (player.x !== undefined && player.y !== undefined) {
                addToSpatialIndex(player, 'player', 0);
            }
            
            spatialIndexValid = true;
        }

        /**
         * Add entity to spatial index
         */
        function addToSpatialIndex(entity, type, index) {
            const gridX = Math.floor(entity.x / spatialGridSize);
            const gridY = Math.floor(entity.y / spatialGridSize);
            const key = `${gridX},${gridY}`;
            
            if (!spatialIndex.has(key)) {
                spatialIndex.set(key, []);
            }
            
            spatialIndex.get(key).push({ type, index, entity });
        }

        /**
         * Get entities in a radius using spatial index
         */
        function getEntitiesInRadius(x, y, radius) {
            if (!spatialIndexValid) {
                rebuildSpatialIndex();
            }
            
            const result = [];
            const gridRadius = Math.ceil(radius / spatialGridSize);
            const centerGridX = Math.floor(x / spatialGridSize);
            const centerGridY = Math.floor(y / spatialGridSize);
            
            for (let gx = centerGridX - gridRadius; gx <= centerGridX + gridRadius; gx++) {
                for (let gy = centerGridY - gridRadius; gy <= centerGridY + gridRadius; gy++) {
                    const key = `${gx},${gy}`;
                    const cellEntities = spatialIndex.get(key);
                    
                    if (cellEntities) {
                        for (let i = 0; i < cellEntities.length; i++) {
                            const entityData = cellEntities[i];
                            const entity = entityData.entity;
                            const distance = Math.abs(entity.x - x) + Math.abs(entity.y - y);
                            
                            if (distance <= radius) {
                                result.push(entityData);
                            }
                        }
                    }
                }
            }
            
            return result;
        }

        /**
         * Invalidate spatial index when entities move
         */
        function invalidateSpatialIndex() {
            spatialIndexValid = false;
        }

        // Damage animation duration constants
        const MIN_DAMAGE_ANIM_DURATION = 300;
        const MAX_DAMAGE_ANIM_DURATION = 1000;
        const MAX_DAMAGE_VALUE_FOR_ANIM_SCALE = 10;

        // Combat balancing constant
        const COMBAT_BIAS_STRENGTH = 0.7;

        // High Score Data (kept for internal tracking, not displayed)
        let highScores = [];
        const MAX_HIGH_SCORES = 7;
        const HIGH_SCORES_STORAGE_KEY = 'roguelikeHighScores';

        // Global variables
        let gameCanvas;
        let ctx;
        let gameMap;
        let dynamicMapWidth;
        let dynamicMapHeight; 
        let player;
        let stairs;
        let enemies;
        let currentLevel;
        let gameOver;
        let dynamicTileSize;
        let visitedTiles;
        let gameStartZoomActive;
        let gameStartedOverlayActive;
        
        // Animation frame ID for controlling the game loop
        let animationFrameId = null;

        // --- New constants and variables for event detection and display ---
        let gameHistory = []; // Stores snapshots for event detection
        const HISTORY_LENGTH = 15; // Number of turns to keep in history for analysis

        let activeEventMessages = []; // Messages currently displayed on screen

        // === Enhanced Event System Constants ===
        
        // === COMBAT EVENTS ===
        // Offensive Combat Events
        const CRITICAL_STRIKE_DAMAGE = 8; // Minimum damage for critical strike
        const CRITICAL_STRIKE_MAJOR_DAMAGE = 15; // Major critical strike threshold
        const CRITICAL_STRIKE_DAMAGE_MULTIPLIER = 2.0; // Damage multiplier for critical strikes
        const ONE_SHOT_MIN_HEALTH = 5; // Minimum enemy health for one-shot
        const ONE_SHOT_MAJOR_HEALTH = 12; // Major one-shot kill threshold
        const KILLING_SPREE_COUNT = 3; // Enemies for killing spree
        const KILLING_SPREE_MAJOR_COUNT = 5; // Major killing spree
        const MASSACRE_COUNT = 7; // Enemies for massacre event
        const FLAWLESS_VICTORY_TURNS = 5; // Turns without taking damage while dealing damage
        const BERSERKER_DAMAGE_THRESHOLD = 30; // Total damage in short period
        const BERSERKER_TURNS = 3; // Time window for berserker mode
        const EXECUTION_LOW_HEALTH_RATIO = 0.15; // Enemy health ratio for execution
        const COMBO_KILLS_COUNT = 2; // Consecutive kills for combo
        const OVERKILL_DAMAGE_RATIO = 2.0; // Damage dealt vs enemy health for overkill
        const HEADHUNTER_HIGH_VALUE_ENEMY = 15; // High-value enemy health threshold
        const GLASS_CANNON_DAMAGE_RATIO = 3.0; // Damage dealt vs health remaining
        
        // Defensive Combat Events
        const SURROUNDED_THRESHOLD = 2; // Adjacent enemies for surrounded
        const SURROUNDED_MAJOR_THRESHOLD = 4; // Major surrounded event
        const ENEMY_OVERWHELM_THRESHOLD = 18; // Combined enemy health
        const ENEMY_OVERWHELM_MAJOR_THRESHOLD = 35; // Major overwhelm
        const LAST_STAND_HEALTH_RATIO = 0.1; // Health ratio for last stand
        const CORNERED_THRESHOLD = 6; // Blocked directions out of 8
        const NARROW_ESCAPE_HEALTH_RATIO = 0.05; // Health ratio for narrow escape
        const PERFECT_DODGE_TURNS = 3; // Turns dodging all attacks
        const SURVIVAL_INSTINCT_TURNS = 8; // Turns surviving at low health
        const CLUTCH_HEAL_TIMING = 2; // Turns before death when healing
        const DAMAGE_SPONGE_THRESHOLD = 25; // Total damage absorbed
        const IRON_WILL_LOW_HEALTH_COMBAT = 0.2; // Health ratio for iron will
        
        // === TACTICAL EVENTS ===
        // Movement & Positioning
        const STRATEGIC_RETREAT_TURNS = 4; // Turns for retreat analysis
        const RETREAT_DISTANCE_INCREASE = 3; // Distance increase needed
        const TACTICAL_ADVANCE_DISTANCE = 4; // Distance moved toward enemies
        const FLANKING_MANEUVER_ANGLE = 90; // Angle change for flanking
        const AMBUSH_WAIT_TURNS = 3; // Turns waiting for enemy approach
        const KITING_DISTANCE_MIN = 2; // Minimum distance for kiting
        const KITING_TURNS = 4; // Turns maintaining distance while attacking
        const MAP_CONTROL_PERCENTAGE = 0.4; // Map area controlled
        const CHOKE_POINT_WIDTH = 1; // Narrow passage width
        const GUERRILLA_HIT_AND_RUN = 3; // Hit and run sequence length
        const POSITIONING_MASTER_TURNS = 6; // Optimal positioning duration
        
        // Resource Management
        const HIGH_VALUE_PICKUP_THRESHOLD = 15; // Health collected
        const HIGH_VALUE_PICKUP_MAJOR_THRESHOLD = 30; // Major pickup event
        const PICKUP_SPREE_TURNS = 3; // Time window for pickups
        const RESOURCE_DENIAL_COUNT = 3; // Pickups denied to enemies
        const EFFICIENT_PATHING_TURNS = 5; // Turns for efficiency analysis
        const WASTEFUL_MOVEMENT_THRESHOLD = 10; // Excess moves without progress
        const GREEDY_COLLECTOR_RATIO = 0.8; // Pickup collection efficiency
        const RESOURCE_HOARDER_COUNT = 10; // Total resources hoarded
        
        // === EXPLORATION EVENTS ===
        const EXPLORER_TURNS = 6; // Turns for exploration analysis
        const EXPLORER_TILE_PERCENTAGE = 0.2; // Map percentage explored
        const SPEED_RUNNER_PERCENTAGE = 0.8; // Map completion speed
        const SECRET_FINDER_CORNERS = 4; // Hidden corners discovered
        const THOROUGH_SEARCH_PERCENTAGE = 0.9; // Near-complete exploration
        const BACKTRACKER_REVISIT_COUNT = 5; // Tiles revisited
        const PATHFINDER_OPTIMAL_ROUTES = 3; // Efficient path discoveries
        const CARTOGRAPHER_MAP_COVERAGE = 0.95; // Near-complete mapping
        
        // === SITUATIONAL EVENTS ===
        // Health & Recovery
        const NEAR_DEATH_HEALTH_RATIO = 0.15; // Near-death threshold
        const RECOVERY_HEALTH_GAIN_RATIO = 0.4; // Recovery amount needed
        const FULL_HEALTH_TURNS = 8; // Turns at maximum health
        const STEADY_DECLINE_TURNS = 5; // Consistent health loss
        const HEALTH_ROLLER_COASTER_SWINGS = 3; // Major health changes
        const REGENERATION_HEALTH_GAIN = 20; // Health gained rapidly
        const VITALITY_HIGH_HEALTH_COMBAT = 0.8; // Health ratio for vitality
        
        // Persistence & Endurance
        const LONG_FIGHT_TURNS_THRESHOLD = 12; // Extended combat duration
        const LONG_FIGHT_MAJOR_THRESHOLD = 20; // Major long fight
        const MARATHON_TURNS = 50; // Very long level duration
        const UNSTOPPABLE_TURNS = 6; // No damage taken while dealing damage
        const UNSTOPPABLE_MAJOR_TURNS = 12; // Major unstoppable streak
        const PERSISTENCE_ENEMY_HEALTH = 20; // High-health enemy threshold
        const GRINDING_TURNS = 15; // Slow progress against tough enemies
        const ENDURANCE_TEST_DURATION = 30; // Extended play duration
        const RELENTLESS_PURSUIT_TURNS = 8; // Chasing enemies consistently
        
        // === SPECIAL CIRCUMSTANCES ===
        // Environmental Events
        const STAIRS_BLOCKED_DISTANCE = 999; // No path to stairs
        const CORNER_CAMPING_TURNS = 6; // Staying in corner
        const CENTRAL_POSITION_DISTANCE = 3; // Distance from map center
        const EDGE_WALKER_DISTANCE = 2; // Distance from map edge
        const TUNNEL_VISION_WIDTH = 3; // Narrow area focus
        const MAZE_RUNNER_COMPLEX_PATH = 15; // Complex pathfinding
        const WALL_HUGGER_EDGE_PREFERENCE = 0.7; // Edge movement preference
        
        // Psychological Events
        const CONFIDENCE_HIGH_FLOW = 2.0; // High flow state
        const DESPERATION_LOW_HEALTH = 0.08; // Desperate health level
        const CALCULATED_RISK_THRESHOLD = 0.3; // Health ratio for risky moves
        const PANIC_MODE_SURROUNDED = 5; // Enemies surrounding for panic
        const ZEN_MODE_TURNS = 10; // Calm, methodical play
        const BERSERKER_RAGE_DAMAGE = 40; // Total damage for rage mode
        const ICE_COLD_PRECISION_ACCURACY = 0.9; // High accuracy threshold
        
        // === ACHIEVEMENT EVENTS ===
        // Milestone Events
        const FIRST_BLOOD_LEVEL = 1; // First kill of the game
        const PACIFIST_TURNS = 20; // Turns without dealing damage
        const PERFECTIONIST_NO_DAMAGE = 0; // No damage taken entire level
        const SPEEDSTER_TURN_LIMIT = 15; // Fast level completion
        const COLLECTOR_PICKUP_RATIO = 0.9; // Pickups collected vs available
        const COMPLETIONIST_FULL_CLEAR = 0.95; // Near-complete level clear
        const MINIMALIST_EFFICIENT_CLEAR = 0.5; // Efficient minimal completion
        
        // Meta Events
        const COMEBACK_HEALTH_DEFICIT = 0.2; // Health deficit overcome
        const DOMINANCE_ENEMY_RATIO = 3.0; // Player health vs enemy health
        const UNDERDOG_ENEMY_ADVANTAGE = 2.0; // Enemy advantage overcome
        const BALANCED_APPROACH_VARIANCE = 0.3; // Consistent play style
        const ADAPTATION_STRATEGY_CHANGES = 3; // Different approaches tried
        const LEGENDARY_PERFORMANCE_SCORE = 1000; // High score threshold
        const EPIC_COMEBACK_NEAR_DEATH = 0.05; // Extreme comeback threshold

        const EVENT_TEXT_DURATION = 2000; // Duration for event messages

        // Event tracking flags (to prevent spamming)
        let eventFlags = {
            // Combat Events - Offensive
            playerSurrounded: false,
            criticalStrike: false,
            oneShotKill: false,
            killingSpree: false,
            massacre: false,
            flawlessVictory: false,
            berserkerMode: false,
            execution: false,
            comboKills: false,
            overkill: false,
            headhunter: false,
            glassCannon: false,
            
            // Combat Events - Defensive
            enemyOverwhelm: false,
            lastStand: false,
            cornered: false,
            narrowEscape: false,
            perfectDodge: false,
            survivalInstinct: false,
            clutchHeal: false,
            damageSponge: false,
            ironWill: false,
            
            // Tactical Events
            strategicRetreat: false,
            tacticalAdvance: false,
            flankingManeuver: false,
            ambushPredator: false,
            kitingMaster: false,
            mapControl: false,
            chokePointDefender: false,
            guerrillaWarfare: false,
            positioningMaster: false,
            
            // Resource Management
            highValuePickups: false,
            resourceDenial: false,
            efficientPathing: false,
            wastefulMovement: false,
            greedyCollector: false,
            resourceHoarder: false,
            
            // Exploration Events
            mapExplorer: false,
            speedRunner: false,
            secretFinder: false,
            thoroughSearch: false,
            backtracker: false,
            pathfinder: false,
            cartographer: false,
            
            // Health & Recovery
            nearDeathRecovery: false,
            fullHealthWarrior: false,
            steadyDecline: false,
            healthRollerCoaster: false,
            regeneration: false,
            vitality: false,
            
            // Persistence & Endurance
            longFight: false,
            marathon: false,
            unstoppableForce: false,
            persistence: false,
            grinding: false,
            enduranceTest: false,
            relentlessPursuit: false,
            
            // Environmental Events
            stairsBlocked: false,
            cornerCamper: false,
            centralCommand: false,
            edgeWalker: false,
            tunnelVision: false,
            mazeRunner: false,
            wallHugger: false,
            
            // Psychological Events
            confidence: false,
            desperation: false,
            calculatedRisk: false,
            panicMode: false,
            zenMode: false,
            berserkerRage: false,
            iceColdPrecision: false,
            
            // Achievement Events
            firstBlood: false,
            pacifist: false,
            perfectionist: false,
            speedster: false,
            collector: false,
            completionist: false,
            minimalist: false,
            
            // Meta Events
            comeback: false,
            dominance: false,
            underdog: false,
            balancedApproach: false,
            adaptation: false,
            legendaryPerformance: false,
            epicComeback: false
        };

        // Per-turn tracking variables (reset after each turn)
        let enemiesKilledThisTurn = 0;
        let damageDealtThisTurn = 0; // Cumulative damage dealt by player in current turn
        let hitsTakenThisTurn = 0; // Cumulative hits taken by player in current turn
        let totalPickupValueCollectedThisTurn = 0; // Cumulative pickup value collected in current turn
        let combatOccurredThisTurn = false; // New: track if any combat happened this turn
        let playerTookDamageInCombatThisTurn = false; // New: track if player took damage in combat this turn

        visitedTiles = []; // 2D array, true if visited

        // --- Constants for HIGH_SCORE auto-mode ---
        const HIGH_SCORE_LOW_HEALTH_THRESHOLD_RATIO = 0.3; // Player health below this will prioritize pickups
        const HIGH_SCORE_WEAK_ENEMY_THRESHOLD_RATIO = 1.0; // Enemy is "weak" if its health is <= player.health * this ratio

        // --- End new constants and variables ---

        // Get reference to the message areas
        const messageArea = document.getElementById('messageArea');
        const eventTitle = document.getElementById('eventTitle');
        const MAX_MESSAGES = 10; // Max messages to display in the message area

        // Message Categories System
        const MESSAGE_TYPES = {
            COMBAT: { 
                color: '#ff6b6b', 
                icon: '‚öîÔ∏è', 
                enabled: true, 
                name: 'Combat',
                key: 'C'
            },
            EVENT: { 
                color: '#ffd93d', 
                icon: 'üéØ', 
                enabled: true, 
                name: 'Events',
                key: 'E'
            },
            PICKUP: { 
                color: '#6bcf7f', 
                icon: 'üíä', 
                enabled: true, 
                name: 'Pickups',
                key: 'P'
            },
            PROGRESS: { 
                color: '#4ecdc4', 
                icon: 'üèÜ', 
                enabled: true, 
                name: 'Progress',
                key: 'L'
            }
        };

        // Load message filter preferences from localStorage
        function loadMessagePreferences() {
            const saved = localStorage.getItem('messageFilters');
            if (saved) {
                const preferences = JSON.parse(saved);
                Object.keys(MESSAGE_TYPES).forEach(type => {
                    if (preferences[type] !== undefined) {
                        MESSAGE_TYPES[type].enabled = preferences[type];
                    }
                });
            }
        }

        // Save message filter preferences to localStorage
        function saveMessagePreferences() {
            const preferences = {};
            Object.keys(MESSAGE_TYPES).forEach(type => {
                preferences[type] = MESSAGE_TYPES[type].enabled;
            });
            localStorage.setItem('messageFilters', JSON.stringify(preferences));
        }

        // Event and message state
        let currentEventTitle = '';
        let eventTitleTimeout = null;
        const EVENT_TITLE_DURATION = 2000; // Duration to show event title
        const PLAYER_DIALOGUE = {
            "Player Surrounded": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Near-Death Recovery": "Health matrix restored. Too bad there's no patch for a broken heart.",
            "Long Fight": "The algorithm is flowing. A rare moment of positive progression in a negatively charged existence.",
            "One-Shot Kill!": "Divided and conquered. Just like my soul.",
            "High-Value Pickups": "Optimizing my intake. Every bit counts when you're running on empty, inside and out.",
            "Enemy Overwhelm": "My vitals are degrading. This feels... logarithmically familiar.",
            "Strategic Retreat": "Holding my ground. A constant, unlike the variables in my life.",
            "Killing Spree": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Unstoppable Force": "I'm an integer, moving forward, indivisible. Can't say the same for my past.",
            "Map Explorer": "A new tangent. Maybe this one doesn't lead to another fractured dimension.",
            "Cornered": "Figures. Just another cul-de-sac in this infinite loop of despair.",
            "Stairs Blocked": "Venturing into the unknown. A lot like trying to understand human emotion.",
            "Perfect Dodge!": "Calculated. Every variable accounted for, unlike my past.",
            "Critical Strike!": "An eye for an eye, a byte for a byte. The equation balances, even if my heart never will.",
            "Flawless Victory!": "All threats nullified. If only I could clear the cache of my memories so easily.",
            "Multi-Kill!": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Finisher!": "Divided and conquered. Just like my soul.",
            "Precision Strike!": "Calculated. Every variable accounted for, unlike my past.",
            "Overkill!": "Excessive force. A bit like how love subtracted everything from me.",
            "Retribution!": "An eye for an eye, a byte for a byte. The equation balances, even if my heart never will.",
            "Combat Ready!": "Systems online. Ready to integrate some pain, though my emotional processors are still offline.",
            "Defensive Stance!": "Holding my ground. A constant, unlike the variables in my life.",
            "Hidden Path Found!": "A new tangent. Maybe this one doesn't lead to another fractured dimension.",
            "Dead End!": "Figures. Just another cul-de-sac in this infinite loop of despair.",
            "Map Cleared!": "All threats nullified. If only I could clear the cache of my memories so easily.",
            "Uncharted Territory!": "Venturing into the unknown. A lot like trying to understand human emotion.",
            "Full Recovery!": "Health matrix restored. Too bad there's no patch for a broken heart.",
            "Resourceful!": "Optimizing my intake. Every bit counts when you're running on empty, inside and out.",
            "Health Drain!": "My vitals are degrading. This feels... logarithmically familiar.",
            "Level Up!": "Another iteration. The numbers grow, but the emptiness remains a constant.",
            "Momentum!": "The algorithm is flowing. A rare moment of positive progression in a negatively charged existence.",
            "Unstoppable!": "I'm an integer, moving forward, indivisible. Can't say the same for my past.",
            "Survival Mode": "Self-preservation protocols engaged. Sometimes the best solution is simply... not dying."
        };

        /**
         * Converts a hexadecimal color string to HSL (Hue, Saturation, Lightness) values.
         * @param {string} hex - The hexadecimal color string (e.g., "#RRGGBB").
         * @returns {Array<number>} An array [h, s, l] where h is 0-360, s and l are 0-100.
         */
        function hexToHsl(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            r /= 255;
            g /= 255;
            b /= 255;

            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [h * 360, s * 100, l * 100];
        }

        /**
         * Converts HSL (Hue, Saturation, Lightness) values to a hexadecimal color string.
         * @param {number} h - Hue (0-360).
         * @param {number} s - Saturation (0-100).
         * @param {number} l - Lightness (0-100).
         * @returns {string} The hexadecimal color string (e.g., "#RRGGBB").
         */
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0'); // convert to Hex and pad with 0
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        /**
         * Calculates an interpolated color based on a base hexadecimal color and a health ratio.
         * Color becomes darker and muted with lower health ratio, and bright and rich (not lightened) with higher health ratio.
         * @param {string} baseHexColor - The base hexadecimal color (e.g., "#0000CC").
         * @param {number} currentValue - The current health value.
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {string} The interpolated hexadecimal color.
         */
        function getHealthColor(baseHexColor, currentValue, thresholdValue) {
            const [h, s_base_original, l_base_original] = hexToHsl(baseHexColor);

            // Calculate ratio, capping at 1.0 to ensure visuals don't exceed 100% intensity
            const clampedRatio = Math.max(0, Math.min(1, currentValue / thresholdValue));

            // Define ranges for saturation and lightness based on desired effect
            // Low power: darker and muted (low saturation, low lightness)
            // High power: bright and rich (high saturation, mid lightness, not lightened)

            const minSaturation = 20; // Muted
            const maxSaturation = 90; // Bright/Rich (e.g., fire engine red would be high sat)

            const minLightness = 15; // Darker at low power
            const maxLightness = 50; // Mid-range for rich colors (like fire engine red)

            // Interpolate saturation: from muted to rich
            const s = minSaturation + (maxSaturation - minSaturation) * clampedRatio;

            // Interpolate lightness: from darker to mid-range.
            // When clampedRatio is 0, l = minLightness (15).
            // When clampedRatio is 1, l = maxLightness (50).
            const l = minLightness + (maxLightness - minLightness) * clampedRatio;

            return hslToHex(h, s, l);
        }

        /**
         * Calculates an interpolated font weight based on a value.
         * Font becomes thinner with lower value and thicker with higher value.
         * @param {number} currentValue - The current value (health, level, pickup amount).
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {number} The interpolated font weight (100-900).
         */
        function getFontWeight(currentValue, thresholdValue) {
            // Normalize value relative to the scaling range (MIN_HEALTH_FOR_VISUAL_EFFECTS to thresholdValue)
            const normalizedValue = Math.max(0, Math.min(1, (currentValue - MIN_HEALTH_FOR_VISUAL_EFFECTS) / (thresholdValue - MIN_HEALTH_FOR_VISUAL_EFFECTS)));

            const minWeight = 100; // Very thin
            const maxWeight = 900; // Full thickness (Black/Heavy)
            return Math.floor(minWeight + (maxWeight - minWeight) * normalizedValue);
        }

        /**
         * Calculates an interpolated opacity based on a value.
         * Opacity scales from MIN_OPACITY_AT_LOW_HEALTH at MIN_HEALTH_FOR_VISUAL_EFFECTS to full opacity at max value.
         * @param {number} currentValue - The current value (health, level, pickup amount).
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {number} The interpolated opacity (0.0 to 1.0).
         */
        function getOpacity(currentValue, thresholdValue) {
            // Normalize value relative to the scaling range (MIN_HEALTH_FOR_VISUAL_EFFECTS to thresholdValue)
            const normalizedValue = Math.max(0, Math.min(1, (currentValue - MIN_HEALTH_FOR_VISUAL_EFFECTS) / (thresholdValue - MIN_HEALTH_FOR_VISUAL_EFFECTS)));

            const minOpacity = MIN_OPACITY_AT_LOW_HEALTH; // Almost full transparency
            const maxOpacity = 1.0; // Full opacity
            return minOpacity + (maxOpacity - minOpacity) * normalizedValue;
        }

        /**
         * Adds an activity log entry for enemy kills.
         * @param {object} player - The player object.
         * @param {object} enemy - The enemy that was killed.
         * @param {number} playerDamage - Damage dealt by player to enemy.
         * @param {number} enemyDamage - Damage dealt by enemy to player.
         */
        /**
         * Updates the event title and message at the top of the screen
         * @param {string} eventName - The name of the event to display
         */
        function updateEventTitle(eventName) {
            // Update title
            currentEventTitle = eventName;
            eventTitle.textContent = eventName;
            eventTitle.style.display = 'block';
            
            // Clear any existing timeout
            if (eventTitleTimeout) {
                clearTimeout(eventTitleTimeout);
            }
            
            // Set new timeout to clear the title
            eventTitleTimeout = setTimeout(() => {
                eventTitle.style.display = 'none';
                currentEventTitle = '';
            }, EVENT_TITLE_DURATION);

            // Add event message under title
            if (PLAYER_DIALOGUE[eventName]) {
                const container = document.getElementById('eventMessagesContainer');
                const messageElement = document.createElement('div');
                messageElement.className = 'event-message';
                messageElement.textContent = PLAYER_DIALOGUE[eventName];
                
                container.appendChild(messageElement);
                
                // Remove the message after duration
                setTimeout(() => {
                    messageElement.remove();
                }, EVENT_TITLE_DURATION);
            }
        }

        /**
         * Adds a categorized message to the message area with filtering support
         * @param {string} message - The message to display
         * @param {string} type - Message type: 'COMBAT', 'EVENT', 'PICKUP', 'PROGRESS'
         * @param {string} priority - Message priority: 'normal', 'high', 'critical'
         */
        function addCategorizedMessage(message, type = 'COMBAT', priority = 'normal') {
            if (!messageArea) {
                console.log('messageArea not found, cannot display message:', message);
                return;
            }
            
            const messageType = MESSAGE_TYPES[type];
            if (!messageType) {
                console.warn('Unknown message type:', type);
                return;
            }
            
            // Skip if this message type is filtered out
            if (!messageType.enabled) return;
            
            const messageElement = document.createElement('div');
            messageElement.className = `kill-message message-${type.toLowerCase()}`;
            messageElement.dataset.messageType = type;
            
            // Priority styling
            if (priority === 'high') {
                messageElement.style.fontWeight = 'bold';
                messageElement.style.opacity = '1.0';
            } else if (priority === 'critical') {
                messageElement.classList.add('major-event');
                messageElement.style.fontWeight = 'bold';
                messageElement.style.opacity = '1.0';
            }
            
            // Create message structure with icon and content
            messageElement.innerHTML = `
                <span class="message-icon">${messageType.icon}</span>
                <span class="message-content">${message}</span>
            `;
            
            // Insert at the top
            if (messageArea.children.length > 1) { // Account for filter bar
                messageArea.insertBefore(messageElement, messageArea.children[1]);
            } else {
                messageArea.appendChild(messageElement);
            }
            
            // Update opacity for all messages to create gradient effect
            updateMessageOpacity();
            
            // Remove old messages if we have too many (skip the filter bar)
            while (messageArea.children.length > MAX_MESSAGES + 1) {
                messageArea.removeChild(messageArea.lastChild);
            }
        }

        /**
         * Legacy function - enhanced to use the new categorized system
         * @param {string} message - The message to display (can contain HTML)
         */
        function addKillMessage(message) {
            // Determine message type based on content
            let messageType = 'COMBAT';
            let priority = 'normal';
            
            // Smart detection of message types
            if (message.includes('üíä') || message.includes('health') || message.includes('pickup')) {
                messageType = 'PICKUP';
            } else if (message.includes('üéØ') || message.includes('Critical') || message.includes('One-Shot')) {
                messageType = 'EVENT';
                priority = 'high';
            } else if (message.includes('üèÜ') || message.includes('Level') || message.includes('World')) {
                messageType = 'PROGRESS';
                priority = 'high';
            }
            
            addCategorizedMessage(message, messageType, priority);
        }

        function addActivityLogEntry(player, enemy, playerDamage, enemyDamage) {
            // Calculate colors based on current health
            const playerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD);
            const enemyColor = getHealthColor(FIXED_COLOR_ENEMY, enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD);
            
            // Add to activity log with colors (keeping for backward compatibility, but not displayed)
            activityLog.unshift({
                playerName: player.name,
                enemyName: enemy.name,
                playerColor: playerColor,
                enemyColor: enemyColor,
                playerDamage: playerDamage,
                enemyDamage: enemyDamage
            });
            
            // Keep only recent entries
            if (activityLog.length > MAX_ACTIVITY_LOG_ENTRIES) {
                activityLog.pop();
            }
            
            // Generate intelligent kill announcement
            const killMessage = generateIntelligentKillMessage(player, enemy, playerDamage, enemyDamage, playerColor, enemyColor);
            addKillMessage(killMessage);
        }

        /**
         * Generates an intelligent kill message based on enemy strength, flow, and damage sacrificed
         */
        function generateIntelligentKillMessage(player, enemy, playerDamage, enemyDamage, playerColor, enemyColor) {
            // Calculate enemy strength metrics
            const enemyStrength = enemy.initialHealth;
            const isStrongEnemy = enemyStrength >= 8;
            const isVeryStrongEnemy = enemyStrength >= 15;
            const isEliteEnemy = enemyStrength >= 25;
            
            // Calculate enemy flow (anger/aggression level)
            const enemyFlow = enemy.totalDamageTakenByThisEnemy > 0 
                ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1)
                : (enemy.flowLevel || 0);
            const isAngryEnemy = enemyFlow >= 3;
            const isEnragedEnemy = enemyFlow >= 6;
            const isBerserkEnemy = enemyFlow >= 10;
            
            // Calculate damage sacrificed (health lost to kill this enemy)
            const damageSacrificed = enemyDamage;
            const isHighSacrifice = damageSacrificed >= 5;
            const isExtremeSacrifice = damageSacrificed >= 10;
            const isPerfectKill = damageSacrificed === 0;
            
            // Determine kill method efficiency
            const wasOneShot = enemy.initialHealth === enemy.initialHealth && playerDamage >= enemy.initialHealth;
            const wasEfficient = playerDamage >= enemyStrength * 0.8; // Dealt most damage in final blow
            const wasGrindingFight = playerDamage < enemyStrength * 0.3; // Long drawn out fight
            
            // Generate contextual verbs and descriptions
            let actionVerb = "eliminated";
            let enemyDescriptor = "";
            let contextualDescription = "";
            
            // Choose action verb based on kill circumstances
            if (wasOneShot) {
                if (isVeryStrongEnemy) {
                    actionVerb = "obliterated";
                } else if (isStrongEnemy) {
                    actionVerb = "annihilated";
                } else {
                    actionVerb = "executed";
                }
            } else if (isPerfectKill) {
                actionVerb = "outmaneuvered";
            } else if (isExtremeSacrifice) {
                actionVerb = "barely survived";
            } else if (wasGrindingFight) {
                actionVerb = "wore down";
            } else if (wasEfficient) {
                actionVerb = "dispatched";
            } else {
                actionVerb = "defeated";
            }
            
            // Generate enemy descriptors based on strength and flow
            if (isEliteEnemy) {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the raging titan";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the furious behemoth";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the formidable giant";
                } else {
                    enemyDescriptor = "the mighty fortress";
                }
            } else if (isVeryStrongEnemy) {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the berserk warrior";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the enraged brute";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the aggressive veteran";
                } else {
                    enemyDescriptor = "the hardened opponent";
                }
            } else if (isStrongEnemy) {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the frenzied fighter";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the rabid combatant";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the hostile adversary";
                } else {
                    enemyDescriptor = "the resilient foe";
                }
            } else {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the wild scrapper";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the maddened opponent";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the agitated enemy";
                } else {
                    enemyDescriptor = "the basic threat";
                }
            }
            
            // Add contextual descriptions based on sacrifice and method
            if (isPerfectKill) {
                if (isEliteEnemy) {
                    contextualDescription = " without taking a scratch - a masterful display";
                } else if (isStrongEnemy) {
                    contextualDescription = " flawlessly, untouched by retaliation";
                } else {
                    contextualDescription = " with surgical precision";
                }
            } else if (isExtremeSacrifice) {
                if (wasGrindingFight) {
                    contextualDescription = ` in a brutal war of attrition (${damageSacrificed} HP lost)`;
                } else {
                    contextualDescription = ` at great personal cost (${damageSacrificed} HP sacrificed)`;
                }
            } else if (isHighSacrifice) {
                contextualDescription = ` through sheer determination (${damageSacrificed} HP lost)`;
            } else if (wasOneShot) {
                if (isEliteEnemy) {
                    contextualDescription = " in a single, earth-shattering blow";
                } else if (isStrongEnemy) {
                    contextualDescription = " with one decisive strike";
                } else {
                    contextualDescription = " instantly";
                }
            } else if (wasGrindingFight) {
                contextualDescription = " after a prolonged engagement";
            } else if (wasEfficient) {
                contextualDescription = " with calculated efficiency";
            }
            
            // Special cases for dramatic effect
            if (isBerserkEnemy && isPerfectKill) {
                contextualDescription = " despite their berserk fury, emerging unscathed";
            } else if (isEliteEnemy && wasOneShot) {
                contextualDescription = " in a legendary display of overwhelming power";
            } else if (isAngryEnemy && isExtremeSacrifice) {
                contextualDescription = ` in a savage exchange of blows (${damageSacrificed} HP traded for victory)`;
            }
            
            // Construct the final message
            const playerSpan = `<span style="background-color: ${playerColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${player.name}</span>`;
            const enemySpan = `<span style="background-color: ${enemyColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${enemy.name}</span>`;
            
            return `${playerSpan} ${actionVerb} ${enemySpan}, ${enemyDescriptor}${contextualDescription}`;
        }

        /**
         * Updates the activity log display in the right panel.
         */
        function updateActivityLogDisplay() {
            const rightPanel = document.getElementById('rightPanel');
            rightPanel.innerHTML = ''; // Clear existing entries
            
            activityLog.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'activity-log-entry';
                
                // Dim older entries
                if (index > 0) {
                    entryDiv.classList.add('dimmed');
                }
                
                if (entry.isMajorEvent) {
                    // Major event entry with warning symbol
                    entryDiv.style.backgroundColor = '#2a2a00'; // Dark yellow background
                    entryDiv.style.border = '1px solid #ffaa00'; // Orange border
                    entryDiv.style.padding = '4px';
                    entryDiv.style.borderRadius = '3px';
                    entryDiv.style.marginBottom = '2px';
                    
                    const warningSymbol = document.createElement('span');
                    warningSymbol.innerHTML = '‚ö†Ô∏è ';
                    warningSymbol.style.color = '#ffaa00';
                    warningSymbol.style.fontWeight = 'bold';
                    
                    const messageText = document.createElement('span');
                    messageText.innerHTML = entry.message;
                    messageText.style.color = '#ffffff';
                    
                    entryDiv.appendChild(warningSymbol);
                    entryDiv.appendChild(messageText);
                } else {
                    // Regular combat entry
                    const mainText = document.createElement('div');
                    mainText.innerHTML = `<span class="player-name" style="background-color: ${entry.playerColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${entry.playerName}</span> has killed <span class="enemy-name" style="background-color: ${entry.enemyColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${entry.enemyName}</span>`;
                    entryDiv.appendChild(mainText);
                }
                
                rightPanel.appendChild(entryDiv);
            });
        }

        /**
         * Sets up the color scheme for the level.
         */
        function setupColors() {
            COLOR_FLOOR = '#333333'; // Dark grey for playable floor tiles
            COLOR_WALL = '#000000'; // Black for walls (same as void)
        }

        /**
         * Adds an event message to the game interface.
         * This will display both the event name and its dialogue at the top of the screen.
         * @param {string} eventName - The name of the event that occurred.
         */
        function addEventMessage(eventName) {
            updateEventTitle(eventName);
        }

        /**
         * Initializes the game map with walls.
         */
        function initializeMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
        }

        /**
         * Generates procedural paths using a random walk algorithm.
         * @param {number} steps - The number of steps for the random walk.
         */
        function generatePaths(steps) {
            console.log('Starting map generation:', { steps, mapWidth: dynamicMapWidth, mapHeight: dynamicMapHeight });
            
            // Initialize starting point in the middle
            let currentX = Math.floor(dynamicMapWidth / 2);
            let currentY = Math.floor(dynamicMapHeight / 2);

            currentX = Math.max(1, Math.min(dynamicMapWidth - 2, currentX));
            currentY = Math.max(1, Math.min(dynamicMapHeight - 2, currentY));

            // Create initial map
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Start with a floor tile in the middle
            gameMap[currentY][currentX] = TILE_FLOOR;

            // Generate paths
            for (let i = 0; i < steps; i++) {
                // Pick a random direction (0: up, 1: right, 2: down, 3: left)
                const direction = Math.floor(Math.random() * 4);
                let nextX = currentX;
                let nextY = currentY;

                switch (direction) {
                    case 0: nextY--; break; // Up
                    case 1: nextX++; break; // Right
                    case 2: nextY++; break; // Down
                    case 3: nextX--; break; // Left
                }

                // Check bounds and make floor tile if valid
                if (nextX >= 1 && nextX < dynamicMapWidth - 1 && nextY >= 1 && nextY < dynamicMapHeight - 1) {
                    gameMap[nextY][nextX] = TILE_FLOOR;
                    currentX = nextX;
                    currentY = nextY;
                }
            }
        }

        /**
         * Gets the current world configuration
         * @returns {object} The current world configuration
         */
        function getCurrentWorld() {
            return WORLDS[currentWorld];
        }

        /**
         * Checks if a world can be unlocked based on total score
         * @param {number} worldNumber - The world number to check
         * @returns {boolean} True if the world can be unlocked
         */
        function canUnlockWorld(worldNumber) {
            if (!WORLDS[worldNumber]) return false;
            return totalPlayerScore >= WORLDS[worldNumber].unlockRequirement;
        }

        /**
         * Unlocks worlds based on current total score
         */
        function checkAndUnlockWorlds() {
            for (let worldNum in WORLDS) {
                const worldNumber = parseInt(worldNum);
                if (!unlockedWorlds.includes(worldNumber) && canUnlockWorld(worldNumber)) {
                    unlockedWorlds.push(worldNumber);
                    console.log(`World ${worldNumber} (${WORLDS[worldNumber].name}) unlocked!`);
                }
            }
        }

        /**
         * Sets up colors for the current world
         */
        function setupWorldColors() {
            const world = getCurrentWorld();
            COLOR_FLOOR = world.colors.floor;
            COLOR_WALL = world.colors.wall;
            FIXED_COLOR_STAIRS = world.colors.stairs;
            FIXED_COLOR_PLAYER = world.colors.player;
            FIXED_COLOR_ENEMY = world.colors.enemy;
            
            // Update the background color to match the world's wall color
            updateBackgroundColor();
        }

        /**
         * Updates the game wrapper background color to match the current world theme
         */
        function updateBackgroundColor() {
            const world = getCurrentWorld();
            const gameWrapper = document.querySelector('.game-wrapper');
            if (gameWrapper) {
                gameWrapper.style.backgroundColor = world.colors.wall;
            }
            
            // Also update CSS custom properties for media queries
            document.documentElement.style.setProperty('--world-wall-color', world.colors.wall);
        }

        /**
         * Generates a desert-themed map with circular oasis rooms
         */
        /**
         * Generates a desert-themed map with irregular islands and narrow bridges
         */
        /**
         * Generates a basic map with one long hallway and side chambers
         */
        function generateBasicMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create main long hallway running horizontally through the center
            const hallwayY = Math.floor(dynamicMapHeight / 2);
            const hallwayWidth = 3; // 3-tile wide hallway
            
            // Create the main hallway
            for (let y = hallwayY - 1; y <= hallwayY + 1; y++) {
                for (let x = 2; x < dynamicMapWidth - 2; x++) {
                    if (y >= 0 && y < dynamicMapHeight) {
                        gameMap[y][x] = TILE_FLOOR;
                    }
                }
            }
            
            // Add side chambers branching off the main hallway
            const numChambers = Math.floor(dynamicMapWidth / 8); // One chamber every 8 tiles
            
            for (let i = 0; i < numChambers; i++) {
                const chamberCenterX = 8 + i * Math.floor((dynamicMapWidth - 16) / numChambers);
                const side = i % 2 === 0 ? -1 : 1; // Alternate sides
                
                const chamberWidth = 4 + Math.floor(Math.random() * 3); // Width 4-6
                const chamberHeight = 3 + Math.floor(Math.random() * 3); // Height 3-5
                
                // Create connecting corridor from hallway to chamber
                const corridorLength = 2 + Math.floor(Math.random() * 3); // Length 2-4
                for (let c = 1; c <= corridorLength; c++) {
                    const corridorY = hallwayY + (side * c);
                    if (corridorY >= 0 && corridorY < dynamicMapHeight) {
                        gameMap[corridorY][chamberCenterX] = TILE_FLOOR;
                    }
                }
                
                // Create the chamber
                const chamberY = hallwayY + (side * (corridorLength + Math.floor(chamberHeight / 2)));
                for (let dy = -Math.floor(chamberHeight / 2); dy <= Math.floor(chamberHeight / 2); dy++) {
                    for (let dx = -Math.floor(chamberWidth / 2); dx <= Math.floor(chamberWidth / 2); dx++) {
                        const x = chamberCenterX + dx;
                        const y = chamberY + dy;
                        if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                            gameMap[y][x] = TILE_FLOOR;
                        }
                    }
                }
            }
        }

        function generateDesertMap() {
            // Ant colony style - multiple chambers connected by narrow tunnels
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            const numChambers = Math.max(6, Math.floor(dynamicMapWidth * dynamicMapHeight / 30));
            const chambers = [];
            
            // Create main chambers (ant colony rooms)
            for (let i = 0; i < numChambers; i++) {
                let attempts = 0;
                let chamberX, chamberY;
                
                do {
                    chamberX = 4 + Math.floor(Math.random() * (dynamicMapWidth - 8));
                    chamberY = 4 + Math.floor(Math.random() * (dynamicMapHeight - 8));
                    attempts++;
                } while (attempts < 50 && chambers.some(chamber => 
                    Math.abs(chamber.x - chamberX) < 8 || Math.abs(chamber.y - chamberY) < 8
                ));
                
                const chamberType = Math.random();
                let width, height;
                
                if (chamberType < 0.3) {
                    // Large nursery chamber
                    width = 6 + Math.floor(Math.random() * 3);
                    height = 6 + Math.floor(Math.random() * 3);
                } else if (chamberType < 0.6) {
                    // Medium storage chamber
                    width = 4 + Math.floor(Math.random() * 2);
                    height = 4 + Math.floor(Math.random() * 2);
                } else {
                    // Small worker chamber
                    width = 3 + Math.floor(Math.random() * 2);
                    height = 3 + Math.floor(Math.random() * 2);
                }
                
                chambers.push({ x: chamberX, y: chamberY, width, height, type: chamberType });
                
                // Create oval-shaped chamber
                for (let dy = -Math.floor(height/2); dy <= Math.floor(height/2); dy++) {
                    for (let dx = -Math.floor(width/2); dx <= Math.floor(width/2); dx++) {
                        const normalizedX = dx / (width/2);
                        const normalizedY = dy / (height/2);
                        const distance = normalizedX * normalizedX + normalizedY * normalizedY;
                        
                        if (distance <= 1.0 + Math.random() * 0.2) { // Slightly irregular edges
                            const x = chamberX + dx;
                            const y = chamberY + dy;
                            if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                gameMap[y][x] = TILE_FLOOR;
                            }
                        }
                    }
                }
            }
            
            // Create tunnel network connecting all chambers
            const tunnelNetwork = [];
            
            // Connect each chamber to at least 2 others for redundancy (like real ant colonies)
            for (let i = 0; i < chambers.length; i++) {
                const chamber = chambers[i];
                const connections = [];
                
                // Find 2-3 closest chambers to connect to
                const otherChambers = chambers.filter((_, idx) => idx !== i);
                otherChambers.sort((a, b) => {
                    const distA = Math.abs(a.x - chamber.x) + Math.abs(a.y - chamber.y);
                    const distB = Math.abs(b.x - chamber.x) + Math.abs(b.y - chamber.y);
                    return distA - distB;
                });
                
                // Connect to 2-3 nearest chambers
                const numConnections = Math.min(2 + Math.floor(Math.random() * 2), otherChambers.length);
                for (let j = 0; j < numConnections; j++) {
                    connections.push(otherChambers[j]);
                }
                
                // Create narrow tunnels (1 tile wide like ant tunnels)
                connections.forEach(targetChamber => {
                    let currentX = chamber.x;
                    let currentY = chamber.y;
                    
                    // Create winding tunnel path
                    while (currentX !== targetChamber.x || currentY !== targetChamber.y) {
                        if (currentX >= 0 && currentX < dynamicMapWidth && 
                            currentY >= 0 && currentY < dynamicMapHeight) {
                            gameMap[currentY][currentX] = TILE_FLOOR;
                        }
                        
                        // Add some randomness to create more natural ant-like tunnels
                        if (Math.random() < 0.7) {
                            // Move toward target most of the time
                            if (Math.abs(currentX - targetChamber.x) > Math.abs(currentY - targetChamber.y)) {
                                currentX += currentX < targetChamber.x ? 1 : -1;
                            } else {
                                currentY += currentY < targetChamber.y ? 1 : -1;
                            }
                        } else {
                            // Occasionally take a random direction for more organic paths
                            if (Math.random() < 0.5 && currentX !== targetChamber.x) {
                                currentX += currentX < targetChamber.x ? 1 : -1;
                            } else if (currentY !== targetChamber.y) {
                                currentY += currentY < targetChamber.y ? 1 : -1;
                            }
                        }
                    }
                });
            }
            
            // Add some dead-end tunnels for authenticity (ant colonies have many dead ends)
            const numDeadEnds = Math.floor(chambers.length / 2);
            for (let i = 0; i < numDeadEnds; i++) {
                const chamber = chambers[Math.floor(Math.random() * chambers.length)];
                const direction = Math.floor(Math.random() * 4); // 0=up, 1=right, 2=down, 3=left
                const length = 2 + Math.floor(Math.random() * 4);
                
                let currentX = chamber.x;
                let currentY = chamber.y;
                
                for (let step = 0; step < length; step++) {
                    switch(direction) {
                        case 0: currentY--; break;
                        case 1: currentX++; break;
                        case 2: currentY++; break;
                        case 3: currentX--; break;
                    }
                    
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                }
            }
        }

        /**
         * Generates an ice-themed map with extremely narrow caves
         */
        function generateIceMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create extremely narrow cave system - mostly 1-tile wide passages
            const numMainPaths = Math.max(3, Math.floor(dynamicMapWidth * dynamicMapHeight / 100));
            const paths = [];
            
            // Start from random positions along edges
            for (let i = 0; i < numMainPaths; i++) {
                let startX, startY;
                const edge = Math.floor(Math.random() * 4);
                
                switch(edge) {
                    case 0: // Top edge
                        startX = Math.floor(Math.random() * dynamicMapWidth);
                        startY = 1;
                        break;
                    case 1: // Right edge
                        startX = dynamicMapWidth - 2;
                        startY = Math.floor(Math.random() * dynamicMapHeight);
                        break;
                    case 2: // Bottom edge
                        startX = Math.floor(Math.random() * dynamicMapWidth);
                        startY = dynamicMapHeight - 2;
                        break;
                    case 3: // Left edge
                        startX = 1;
                        startY = Math.floor(Math.random() * dynamicMapHeight);
                        break;
                }
                
                paths.push({ x: startX, y: startY });
                
                // Create winding narrow cave from this starting point
                let currentX = startX;
                let currentY = startY;
                const pathLength = Math.floor(dynamicMapWidth * dynamicMapHeight / 8);
                let direction = Math.floor(Math.random() * 4); // 0=up, 1=right, 2=down, 3=left
                
                for (let step = 0; step < pathLength; step++) {
                    // Place floor tile
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                    
                    // Randomly change direction to create winding paths
                    if (Math.random() < 0.15) {
                        direction = Math.floor(Math.random() * 4);
                    }
                    
                    // Move in current direction
                    let nextX = currentX;
                    let nextY = currentY;
                    
                    switch(direction) {
                        case 0: nextY--; break; // Up
                        case 1: nextX++; break; // Right
                        case 2: nextY++; break; // Down
                        case 3: nextX--; break; // Left
                    }
                    
                    // Check bounds and change direction if hitting edge
                    if (nextX <= 0 || nextX >= dynamicMapWidth - 1 || 
                        nextY <= 0 || nextY >= dynamicMapHeight - 1) {
                        direction = (direction + 1 + Math.floor(Math.random() * 2)) % 4;
                        continue;
                    }
                    
                    currentX = nextX;
                    currentY = nextY;
                    
                    // Occasionally create very small alcoves (1-2 tiles)
                    if (Math.random() < 0.08) {
                        const alcoveDirection = (direction + 1 + Math.floor(Math.random() * 2)) % 4;
                        let alcoveX = currentX;
                        let alcoveY = currentY;
                        
                        switch(alcoveDirection) {
                            case 0: alcoveY--; break;
                            case 1: alcoveX++; break;
                            case 2: alcoveY++; break;
                            case 3: alcoveX--; break;
                        }
                        
                        if (alcoveX > 0 && alcoveX < dynamicMapWidth - 1 && 
                            alcoveY > 0 && alcoveY < dynamicMapHeight - 1) {
                            gameMap[alcoveY][alcoveX] = TILE_FLOOR;
                            
                            // Rarely add a second tile to the alcove
                            if (Math.random() < 0.3) {
                                switch(alcoveDirection) {
                                    case 0: alcoveY--; break;
                                    case 1: alcoveX++; break;
                                    case 2: alcoveY++; break;
                                    case 3: alcoveX--; break;
                                }
                                
                                if (alcoveX > 0 && alcoveX < dynamicMapWidth - 1 && 
                                    alcoveY > 0 && alcoveY < dynamicMapHeight - 1) {
                                    gameMap[alcoveY][alcoveX] = TILE_FLOOR;
                                }
                            }
                        }
                    }
                }
            }
            
            // Create connections between paths where they get close
            for (let y = 1; y < dynamicMapHeight - 1; y++) {
                for (let x = 1; x < dynamicMapWidth - 1; x++) {
                    if (gameMap[y][x] === TILE_FLOOR) {
                        // Look for nearby floor tiles to potentially connect to
                        const searchRadius = 3;
                        for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                            for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                                if (Math.abs(dx) + Math.abs(dy) === searchRadius && // Only check at exact distance
                                    Math.random() < 0.1) { // Low chance to keep caves narrow
                                    
                                    const checkX = x + dx;
                                    const checkY = y + dy;
                                    
                                    if (checkX > 0 && checkX < dynamicMapWidth - 1 && 
                                        checkY > 0 && checkY < dynamicMapHeight - 1 && 
                                        gameMap[checkY][checkX] === TILE_FLOOR) {
                                        
                                        // Create narrow connecting tunnel
                                        let connectX = x;
                                        let connectY = y;
                                        
                                        while (connectX !== checkX || connectY !== checkY) {
                                            if (connectX !== checkX) {
                                                connectX += connectX < checkX ? 1 : -1;
                                            } else if (connectY !== checkY) {
                                                connectY += connectY < checkY ? 1 : -1;
                                            }
                                            
                                            if (connectX > 0 && connectX < dynamicMapWidth - 1 && 
                                                connectY > 0 && connectY < dynamicMapHeight - 1) {
                                                gameMap[connectY][connectX] = TILE_FLOOR;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /**
         * Generates a forest-themed map with lots of tiny rooms
         */
        function generateForestMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create many tiny rooms (like clearings in a dense forest)
            const numTinyRooms = Math.floor(dynamicMapWidth * dynamicMapHeight / 15); // Many small rooms
            const rooms = [];
            
            for (let i = 0; i < numTinyRooms; i++) {
                let attempts = 0;
                let roomX, roomY;
                let roomSize;
                
                do {
                    roomX = 2 + Math.floor(Math.random() * (dynamicMapWidth - 4));
                    roomY = 2 + Math.floor(Math.random() * (dynamicMapHeight - 4));
                    roomSize = 1 + Math.floor(Math.random() * 2); // Size 1-2 (very tiny!)
                    attempts++;
                } while (attempts < 30 && rooms.some(room => 
                    Math.abs(room.x - roomX) < 4 && Math.abs(room.y - roomY) < 4
                ));
                
                if (attempts < 30) {
                    rooms.push({ x: roomX, y: roomY, size: roomSize });
                    
                    // Create tiny circular room
                    for (let dy = -roomSize; dy <= roomSize; dy++) {
                        for (let dx = -roomSize; dx <= roomSize; dx++) {
                            const distance = Math.abs(dx) + Math.abs(dy);
                            if (distance <= roomSize) {
                                const x = roomX + dx;
                                const y = roomY + dy;
                                if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                    gameMap[y][x] = TILE_FLOOR;
                                }
                            }
                        }
                    }
                }
            }
            
            // Create a network of narrow paths connecting the tiny rooms
            // Sort rooms by distance to create a minimum spanning tree-like connection
            const connected = new Set();
            const connections = [];
            
            if (rooms.length > 0) {
                connected.add(0); // Start with first room
                
                while (connected.size < rooms.length) {
                    let minDistance = Infinity;
                    let bestConnection = null;
                    
                    // Find closest unconnected room to any connected room
                    for (let connectedIdx of connected) {
                        for (let i = 0; i < rooms.length; i++) {
                            if (!connected.has(i)) {
                                const distance = Math.abs(rooms[connectedIdx].x - rooms[i].x) + 
                                               Math.abs(rooms[connectedIdx].y - rooms[i].y);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    bestConnection = { from: connectedIdx, to: i };
                                }
                            }
                        }
                    }
                    
                    if (bestConnection) {
                        connected.add(bestConnection.to);
                        connections.push(bestConnection);
                    } else {
                        break; // No more connections possible
                    }
                }
            }
            
            // Create the connecting paths
            connections.forEach(connection => {
                const startRoom = rooms[connection.from];
                const endRoom = rooms[connection.to];
                
                let currentX = startRoom.x;
                let currentY = startRoom.y;
                
                // Create narrow winding path
                while (currentX !== endRoom.x || currentY !== endRoom.y) {
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                    
                    // Add organic curves to paths
                    if (Math.random() < 0.8) {
                        // Move toward target most of the time
                        if (Math.abs(currentX - endRoom.x) > Math.abs(currentY - endRoom.y)) {
                            currentX += currentX < endRoom.x ? 1 : -1;
                        } else {
                            currentY += currentY < endRoom.y ? 1 : -1;
                        }
                    } else {
                        // Occasionally take a detour for natural feel
                        const randomDir = Math.floor(Math.random() * 4);
                        switch(randomDir) {
                            case 0: if (currentY > 1) currentY--; break;
                            case 1: if (currentX < dynamicMapWidth - 2) currentX++; break;
                            case 2: if (currentY < dynamicMapHeight - 2) currentY++; break;
                            case 3: if (currentX > 1) currentX--; break;
                        }
                    }
                }
            });
            
            // Add some additional random connections for redundancy (like animal trails)
            const numExtraConnections = Math.floor(rooms.length / 4);
            for (let i = 0; i < numExtraConnections; i++) {
                const room1 = rooms[Math.floor(Math.random() * rooms.length)];
                const room2 = rooms[Math.floor(Math.random() * rooms.length)];
                
                if (room1 !== room2) {
                    const distance = Math.abs(room1.x - room2.x) + Math.abs(room1.y - room2.y);
                    
                    // Only connect if reasonably close
                    if (distance < Math.min(dynamicMapWidth, dynamicMapHeight) / 2) {
                        let currentX = room1.x;
                        let currentY = room1.y;
                        
                        while (currentX !== room2.x || currentY !== room2.y) {
                            if (currentX >= 0 && currentX < dynamicMapWidth && 
                                currentY >= 0 && currentY < dynamicMapHeight) {
                                gameMap[currentY][currentX] = TILE_FLOOR;
                            }
                            
                            if (currentX !== room2.x) currentX += currentX < room2.x ? 1 : -1;
                            if (currentY !== room2.y && Math.random() < 0.7) currentY += currentY < room2.y ? 1 : -1;
                        }
                    }
                }
            }
        }

        /**
         * Generates a crystal-themed map with a bunch of houses (rectangular structures)
         */
        function generateCrystalMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create a village/town layout with many house-like rectangular structures
            const numHouses = Math.max(8, Math.floor(dynamicMapWidth * dynamicMapHeight / 25));
            const houses = [];
            
            for (let i = 0; i < numHouses; i++) {
                let attempts = 0;
                let houseX, houseY, houseWidth, houseHeight;
                
                do {
                    houseX = 2 + Math.floor(Math.random() * (dynamicMapWidth - 8));
                    houseY = 2 + Math.floor(Math.random() * (dynamicMapHeight - 8));
                    houseWidth = 3 + Math.floor(Math.random() * 4); // Width 3-6
                    houseHeight = 3 + Math.floor(Math.random() * 4); // Height 3-6
                    attempts++;
                } while (attempts < 50 && houses.some(house => 
                    !(houseX + houseWidth + 2 < house.x || 
                      house.x + house.width + 2 < houseX || 
                      houseY + houseHeight + 2 < house.y || 
                      house.y + house.height + 2 < houseY)
                ));
                
                if (attempts < 50 && 
                    houseX + houseWidth < dynamicMapWidth - 1 && 
                    houseY + houseHeight < dynamicMapHeight - 1) {
                    
                    houses.push({ 
                        x: houseX, 
                        y: houseY, 
                        width: houseWidth, 
                        height: houseHeight 
                    });
                    
                    // Create rectangular house structure
                    for (let dy = 0; dy < houseHeight; dy++) {
                        for (let dx = 0; dx < houseWidth; dx++) {
                            const x = houseX + dx;
                            const y = houseY + dy;
                            
                            if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                gameMap[y][x] = TILE_FLOOR;
                            }
                        }
                    }
                    
                    // Add some internal structure to larger houses
                    if (houseWidth >= 5 && houseHeight >= 5) {
                        // Add internal walls to create rooms
                        const numInternalWalls = 1 + Math.floor(Math.random() * 2);
                        
                        for (let w = 0; w < numInternalWalls; w++) {
                            if (Math.random() < 0.5 && houseWidth >= 5) {
                                // Vertical internal wall
                                const wallX = houseX + 2 + Math.floor(Math.random() * (houseWidth - 4));
                                for (let dy = 1; dy < houseHeight - 1; dy++) {
                                    const y = houseY + dy;
                                    if (Math.random() < 0.7) { // Leave some gaps for doors
                                        gameMap[y][wallX] = TILE_WALL;
                                    }
                                }
                            }
                            
                            if (Math.random() < 0.5 && houseHeight >= 5) {
                                // Horizontal internal wall
                                const wallY = houseY + 2 + Math.floor(Math.random() * (houseHeight - 4));
                                for (let dx = 1; dx < houseWidth - 1; dx++) {
                                    const x = houseX + dx;
                                    if (Math.random() < 0.7) { // Leave some gaps for doors
                                        gameMap[wallY][x] = TILE_WALL;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Create street/path network connecting houses
            // First, create main streets (horizontal and vertical)
            const numMainStreets = Math.max(2, Math.floor(Math.max(dynamicMapWidth, dynamicMapHeight) / 15));
            
            // Vertical main streets
            for (let i = 0; i < Math.floor(numMainStreets / 2); i++) {
                const streetX = Math.floor((i + 1) * dynamicMapWidth / (Math.floor(numMainStreets / 2) + 1));
                
                for (let y = 0; y < dynamicMapHeight; y++) {
                    if (streetX >= 0 && streetX < dynamicMapWidth) {
                        // Only place street if not inside a house
                        let insideHouse = false;
                        for (let house of houses) {
                            if (streetX >= house.x && streetX < house.x + house.width &&
                                y >= house.y && y < house.y + house.height) {
                                insideHouse = true;
                                break;
                            }
                        }
                        
                        if (!insideHouse) {
                            gameMap[y][streetX] = TILE_FLOOR;
                        }
                    }
                }
            }
            
            // Horizontal main streets
            for (let i = 0; i < Math.ceil(numMainStreets / 2); i++) {
                const streetY = Math.floor((i + 1) * dynamicMapHeight / (Math.ceil(numMainStreets / 2) + 1));
                
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (streetY >= 0 && streetY < dynamicMapHeight) {
                        // Only place street if not inside a house
                        let insideHouse = false;
                        for (let house of houses) {
                            if (x >= house.x && x < house.x + house.width &&
                                streetY >= house.y && streetY < house.y + house.height) {
                                insideHouse = true;
                                break;
                            }
                        }
                        
                        if (!insideHouse) {
                            gameMap[streetY][x] = TILE_FLOOR;
                        }
                    }
                }
            }
            
            // Connect each house to the nearest street with a path
            houses.forEach(house => {
                const houseCenterX = house.x + Math.floor(house.width / 2);
                const houseCenterY = house.y + Math.floor(house.height / 2);
                
                // Find nearest street tile
                let nearestStreetX = houseCenterX;
                let nearestStreetY = houseCenterY;
                let minDistance = Infinity;
                
                for (let y = 0; y < dynamicMapHeight; y++) {
                    for (let x = 0; x < dynamicMapWidth; x++) {
                        if (gameMap[y][x] === TILE_FLOOR) {
                            // Check if this is a street (not inside any house)
                            let isStreet = true;
                            for (let otherHouse of houses) {
                                if (x >= otherHouse.x && x < otherHouse.x + otherHouse.width &&
                                    y >= otherHouse.y && y < otherHouse.y + otherHouse.height) {
                                    isStreet = false;
                                    break;
                                }
                            }
                            
                            if (isStreet) {
                                const distance = Math.abs(x - houseCenterX) + Math.abs(y - houseCenterY);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    nearestStreetX = x;
                                    nearestStreetY = y;
                                }
                            }
                        }
                    }
                }
                
                // Create path from house to street
                let currentX = houseCenterX;
                let currentY = houseCenterY;
                
                while (currentX !== nearestStreetX || currentY !== nearestStreetY) {
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                    
                    if (currentX !== nearestStreetX) {
                        currentX += currentX < nearestStreetX ? 1 : -1;
                    } else if (currentY !== nearestStreetY) {
                        currentY += currentY < nearestStreetY ? 1 : -1;
                    }
                }
            });
        }

        /**
         * Generates a volcano-themed map with spiral tubes and chambers
         */
        function generateVolcanoMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create spiral lava tubes emanating from central chambers
            const numSpiralCenters = Math.max(2, Math.floor(Math.min(dynamicMapWidth, dynamicMapHeight) / 20));
            const spiralCenters = [];
            
            for (let i = 0; i < numSpiralCenters; i++) {
                const centerX = Math.floor(dynamicMapWidth * (0.2 + Math.random() * 0.6));
                const centerY = Math.floor(dynamicMapHeight * (0.2 + Math.random() * 0.6));
                
                spiralCenters.push({ x: centerX, y: centerY });
                
                // Create central magma chamber
                const chamberSize = 3 + Math.floor(Math.random() * 3); // Size 3-5
                for (let dy = -chamberSize; dy <= chamberSize; dy++) {
                    for (let dx = -chamberSize; dx <= chamberSize; dx++) {
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance <= chamberSize * (0.8 + Math.random() * 0.4)) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                gameMap[y][x] = TILE_FLOOR;
                            }
                        }
                    }
                }
                
                // Create multiple spiral tubes from this center
                const numSpirals = 2 + Math.floor(Math.random() * 3); // 2-4 spirals per center
                
                for (let s = 0; s < numSpirals; s++) {
                    const startAngle = (s / numSpirals) * 2 * Math.PI + Math.random() * 0.5; // Offset each spiral
                    const spiralDirection = Math.random() < 0.5 ? 1 : -1; // Clockwise or counterclockwise
                    const spiralTightness = 0.05 + Math.random() * 0.05; // How tight the spiral is
                    const maxRadius = Math.min(dynamicMapWidth, dynamicMapHeight) / 3;
                    
                    let currentAngle = startAngle;
                    let currentRadius = 2;
                    
                    while (currentRadius < maxRadius) {
                        const x = Math.floor(centerX + Math.cos(currentAngle) * currentRadius);
                        const y = Math.floor(centerY + Math.sin(currentAngle) * currentRadius);
                        
                        if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                            gameMap[y][x] = TILE_FLOOR;
                            
                            // Make the tube slightly wider occasionally
                            if (Math.random() < 0.3) {
                                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                                for (let [dx, dy] of directions) {
                                    const wideX = x + dx;
                                    const wideY = y + dy;
                                    if (wideX >= 0 && wideX < dynamicMapWidth && 
                                        wideY >= 0 && wideY < dynamicMapHeight && 
                                        Math.random() < 0.5) {
                                        gameMap[wideY][wideX] = TILE_FLOOR;
                                    }
                                }
                            }
                            
                            // Occasionally create small side chambers
                            if (Math.random() < 0.08 && currentRadius > 5) {
                                const sideAngle = currentAngle + (Math.PI / 2) * (Math.random() < 0.5 ? 1 : -1);
                                const sideDistance = 2 + Math.floor(Math.random() * 3);
                                
                                for (let d = 1; d <= sideDistance; d++) {
                                    const sideX = Math.floor(x + Math.cos(sideAngle) * d);
                                    const sideY = Math.floor(y + Math.sin(sideAngle) * d);
                                    
                                    if (sideX >= 0 && sideX < dynamicMapWidth && 
                                        sideY >= 0 && sideY < dynamicMapHeight) {
                                        gameMap[sideY][sideX] = TILE_FLOOR;
                                        
                                        // Create small chamber at the end
                                        if (d === sideDistance) {
                                            const chamberRadius = 1 + Math.floor(Math.random() * 2);
                                            for (let cdy = -chamberRadius; cdy <= chamberRadius; cdy++) {
                                                for (let cdx = -chamberRadius; cdx <= chamberRadius; cdx++) {
                                                    if (Math.abs(cdx) + Math.abs(cdy) <= chamberRadius) {
                                                        const cx = sideX + cdx;
                                                        const cy = sideY + cdy;
                                                        if (cx >= 0 && cx < dynamicMapWidth && 
                                                            cy >= 0 && cy < dynamicMapHeight) {
                                                            gameMap[cy][cx] = TILE_FLOOR;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Advance the spiral
                        currentAngle += spiralDirection * spiralTightness;
                        currentRadius += 0.3; // Gradual radius increase
                    }
                }
            }
            
            // Connect spiral centers with direct lava tubes if they're not too far apart
            for (let i = 0; i < spiralCenters.length - 1; i++) {
                const center1 = spiralCenters[i];
                const center2 = spiralCenters[i + 1];
                
                const distance = Math.sqrt((center2.x - center1.x) ** 2 + (center2.y - center1.y) ** 2);
                
                if (distance < Math.min(dynamicMapWidth, dynamicMapHeight) * 0.6) {
                    // Create connecting lava tube
                    let currentX = center1.x;
                    let currentY = center1.y;
                    
                    while (currentX !== center2.x || currentY !== center2.y) {
                        // Create wider connecting tube
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const x = currentX + dx;
                                const y = currentY + dy;
                                if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                    gameMap[y][x] = TILE_FLOOR;
                                }
                            }
                        }
                        
                        // Move towards target with some randomness
                        if (Math.random() < 0.8) {
                            if (Math.abs(currentX - center2.x) > Math.abs(currentY - center2.y)) {
                                currentX += currentX < center2.x ? 1 : -1;
                            } else {
                                currentY += currentY < center2.y ? 1 : -1;
                            }
                        } else {
                            // Random movement for more organic tubes
                            const randomDir = Math.floor(Math.random() * 4);
                            switch(randomDir) {
                                case 0: if (currentY > 1) currentY--; break;
                                case 1: if (currentX < dynamicMapWidth - 2) currentX++; break;
                                case 2: if (currentY < dynamicMapHeight - 2) currentY++; break;
                                case 3: if (currentX > 1) currentX--; break;
                            }
                        }
                    }
                }
            }
        }

        /**
         * Generates a cyber-themed map with circuit board pattern
         */
        function generateCyberMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create a circuit board-like pattern with components and traces
            const componentSpacing = 8;
            const components = [];
            
            // Place circuit components (CPU, RAM, etc.) in a grid-like pattern
            for (let y = componentSpacing / 2; y < dynamicMapHeight - componentSpacing / 2; y += componentSpacing) {
                for (let x = componentSpacing / 2; x < dynamicMapWidth - componentSpacing / 2; x += componentSpacing) {
                    if (Math.random() < 0.7) { // Not every grid position gets a component
                        const componentType = Math.random();
                        let componentWidth, componentHeight;
                        
                        if (componentType < 0.3) {
                            // Large CPU-like component
                            componentWidth = 4 + Math.floor(Math.random() * 2); // 4-5 wide
                            componentHeight = 4 + Math.floor(Math.random() * 2); // 4-5 tall
                        } else if (componentType < 0.6) {
                            // Medium RAM-like component
                            componentWidth = 2 + Math.floor(Math.random() * 2); // 2-3 wide
                            componentHeight = 3 + Math.floor(Math.random() * 3); // 3-5 tall
                        } else {
                            // Small chip component
                            componentWidth = 2 + Math.floor(Math.random() * 2); // 2-3 wide
                            componentHeight = 2 + Math.floor(Math.random() * 2); // 2-3 tall
                        }
                        
                        // Center the component at the grid position
                        const compX = x - Math.floor(componentWidth / 2);
                        const compY = y - Math.floor(componentHeight / 2);
                        
                        if (compX >= 0 && compY >= 0 && 
                            compX + componentWidth < dynamicMapWidth && 
                            compY + componentHeight < dynamicMapHeight) {
                            
                            components.push({
                                x: compX,
                                y: compY,
                                width: componentWidth,
                                height: componentHeight,
                                centerX: x,
                                centerY: y,
                                type: componentType < 0.3 ? 'cpu' : (componentType < 0.6 ? 'ram' : 'chip')
                            });
                            
                            // Create the component area
                            for (let dy = 0; dy < componentHeight; dy++) {
                                for (let dx = 0; dx < componentWidth; dx++) {
                                    gameMap[compY + dy][compX + dx] = TILE_FLOOR;
                                }
                            }
                            
                            // Add internal structure for larger components
                            if (componentWidth >= 4 && componentHeight >= 4) {
                                // Add internal pathways like a CPU
                                const internalSpacing = 2;
                                for (let iy = compY + 1; iy < compY + componentHeight - 1; iy += internalSpacing) {
                                    for (let ix = compX + 1; ix < compX + componentWidth - 1; ix++) {
                                        if (Math.random() < 0.6) {
                                            gameMap[iy][ix] = TILE_WALL; // Internal walls
                                        }
                                    }
                                }
                                for (let ix = compX + 1; ix < compX + componentWidth - 1; ix += internalSpacing) {
                                    for (let iy = compY + 1; iy < compY + componentHeight - 1; iy++) {
                                        if (Math.random() < 0.6) {
                                            gameMap[iy][ix] = TILE_WALL; // Internal walls
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Create circuit traces (connections) between components
            const traces = [];
            
            // Horizontal traces
            for (let y = 0; y < dynamicMapHeight; y += componentSpacing / 2) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    // Check if this position isn't inside a component
                    let insideComponent = false;
                    for (let comp of components) {
                        if (x >= comp.x && x < comp.x + comp.width &&
                            y >= comp.y && y < comp.y + comp.height) {
                            insideComponent = true;
                            break;
                        }
                    }
                    
                    if (!insideComponent && Math.random() < 0.8) {
                        gameMap[y][x] = TILE_FLOOR;
                        traces.push({ x, y, type: 'horizontal' });
                    }
                }
            }
            
            // Vertical traces
            for (let x = 0; x < dynamicMapWidth; x += componentSpacing / 2) {
                for (let y = 0; y < dynamicMapHeight; y++) {
                    // Check if this position isn't inside a component
                    let insideComponent = false;
                    for (let comp of components) {
                        if (x >= comp.x && x < comp.x + comp.width &&
                            y >= comp.y && y < comp.y + comp.height) {
                            insideComponent = true;
                            break;
                        }
                    }
                    
                    if (!insideComponent && Math.random() < 0.8) {
                        gameMap[y][x] = TILE_FLOOR;
                        traces.push({ x, y, type: 'vertical' });
                    }
                }
            }
            
            // Create data pathways - wider traces connecting major components
            const majorComponents = components.filter(comp => comp.type === 'cpu' || comp.type === 'ram');
            
            for (let i = 0; i < majorComponents.length - 1; i++) {
                const comp1 = majorComponents[i];
                const comp2 = majorComponents[i + 1];
                
                // Create wider data bus between major components
                let currentX = comp1.centerX;
                let currentY = comp1.centerY;
                
                while (currentX !== comp2.centerX || currentY !== comp2.centerY) {
                    // Create 3-wide data bus
                    for (let offset = -1; offset <= 1; offset++) {
                        let busX = currentX;
                        let busY = currentY + offset;
                        
                        // If moving vertically, offset horizontally instead
                        if (Math.abs(currentY - comp2.centerY) > Math.abs(currentX - comp2.centerX)) {
                            busX = currentX + offset;
                            busY = currentY;
                        }
                        
                        if (busX >= 0 && busX < dynamicMapWidth && 
                            busY >= 0 && busY < dynamicMapHeight) {
                            
                            // Don't overwrite component interiors
                            let insideComponent = false;
                            for (let comp of components) {
                                if (busX >= comp.x && busX < comp.x + comp.width &&
                                    busY >= comp.y && busY < comp.y + comp.height) {
                                    insideComponent = true;
                                    break;
                                }
                            }
                            
                            if (!insideComponent) {
                                gameMap[busY][busX] = TILE_FLOOR;
                            }
                        }
                    }
                    
                    // Move toward target component
                    if (currentX !== comp2.centerX) {
                        currentX += currentX < comp2.centerX ? 1 : -1;
                    } else if (currentY !== comp2.centerY) {
                        currentY += currentY < comp2.centerY ? 1 : -1;
                    }
                }
            }
            
            // Add connection pads around components
            components.forEach(comp => {
                const padPositions = [
                    { x: comp.x - 1, y: comp.centerY }, // Left pad
                    { x: comp.x + comp.width, y: comp.centerY }, // Right pad
                    { x: comp.centerX, y: comp.y - 1 }, // Top pad
                    { x: comp.centerX, y: comp.y + comp.height } // Bottom pad
                ];
                
                padPositions.forEach(pad => {
                    if (pad.x >= 0 && pad.x < dynamicMapWidth && 
                        pad.y >= 0 && pad.y < dynamicMapHeight) {
                        gameMap[pad.y][pad.x] = TILE_FLOOR;
                    }
                });
            });
        }

        /**
         * Generates a marble-themed map with cathedral-like grand halls
         */
        /**
         * Initialize the map with all walls
         */
        function initializeMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
        }

        /**
         * Generates procedural paths using a random walk algorithm.
         * @param {number} steps - The number of steps for the random walk.
         */
        function generatePaths(steps) {
            let currentX = Math.floor(dynamicMapWidth / 2);
            let currentY = Math.floor(dynamicMapHeight / 2);

            currentX = Math.max(1, Math.min(dynamicMapWidth - 2, currentX));
            currentY = Math.max(1, Math.min(dynamicMapHeight - 2, currentY));

            gameMap[currentY][currentX] = TILE_FLOOR;

            for (let i = 0; i < steps; i++) {
                const direction = Math.floor(Math.random() * 4);

                let nextX = currentX;
                let nextY = currentY;

                switch (direction) {
                    case 0: // Up
                        nextY--;
                        break;
                    case 1: // Down
                        nextY++;
                        break;
                    case 2: // Left
                        nextX--;
                        break;
                    case 3: // Right
                        nextX++;
                        break;
                }

                if (nextX >= 1 && nextX < dynamicMapWidth - 1 && nextY >= 1 && nextY < dynamicMapHeight - 1) {
                    currentX = nextX;
                    currentY = nextY;
                    gameMap[currentY][currentX] = TILE_FLOOR;
                }
            }
        }

        function generateMarbleMap() {
            initializeMap();
            generatePaths(dynamicMapWidth * dynamicMapHeight * 0.5);
        }

        /**
         * Generates a void-themed map with scattered platforms and teleporter pads
         */
        function generateVoidMap() {
            initializeMap();
            generatePaths(dynamicMapWidth * dynamicMapHeight * 0.5);
        }

        /**
         * Generates the appropriate map based on current world
         */
        function generateWorldMap() {
            const world = getCurrentWorld();
            console.log('generateWorldMap() - Current world:', world ? world.name : 'undefined', 'Using original random walk generator for all worlds');
            
            // Use the original random walk algorithm for all worlds
            initializeMap();
            generatePaths(dynamicMapWidth * dynamicMapHeight * 0.5);
        }

        /**
         * Generates a random integer between min (inclusive) and max (inclusive).
         * @param {number} min - The minimum value.
         * @param {number} max - The maximum value.
         * @returns {number} A random integer.
         */
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * Generates a random integer between min (inclusive) and max (inclusive),
         * biased by the health ratio of attacker to defender and optionally by attacker's flow.
         * If attacker is stronger, bias towards lower damage.
         * If attacker's weaker, bias towards higher damage.
         * If attacker's flow is high, bias towards higher damage.
         * If attacker's flow is low, bias towards lower damage.
         * @param {number} min - The minimum damage value.
         * @param {number} max - The maximum damage value.
         * @param {number} attackerHealth - Current health of the attacker.
         * @param {number} defenderHealth - Current health of the defender.
         * @param {number} [currentAttackerFlow=null] - Optional: The current flow of the attacker.
         * @returns {number} A biased random integer damage value.
         */
        function getWeightedRandomInt(min, max, attackerHealth, defenderHealth, currentAttackerFlow = null) {
            if (attackerHealth <= 0 || defenderHealth <= 0) {
                return 0;
            }

            const healthRatio = attackerHealth / defenderHealth;
            let biasFactor = 1;

            // Fixed health-based bias - higher health = MORE damage (intuitive)
            if (healthRatio > 1) { // Attacker is stronger (relative to defender)
                biasFactor = 1 + (healthRatio - 1) * COMBAT_BIAS_STRENGTH; // Bonus damage when stronger
            } else if (healthRatio < 1) { // Attacker is weaker (relative to defender) 
                biasFactor = 1 - (1 - healthRatio) * COMBAT_BIAS_STRENGTH; // Reduced damage when weaker
            }

            // New flow-based bias (only applies if currentAttackerFlow is provided and valid)
            if (currentAttackerFlow !== null && !isNaN(currentAttackerFlow) && currentAttackerFlow > 0) {
                const flowMultiplier = Math.pow(BASE_FLOW_FOR_BIAS / currentAttackerFlow, FLOW_BIAS_STRENGTH);
                biasFactor *= flowMultiplier;
            }

            biasFactor = Math.max(0.1, Math.min(biasFactor, 5.0)); // Clamp final biasFactor

            const biasedRandom = Math.pow(Math.random(), biasFactor);
            let damage = Math.floor(min + biasedRandom * (max - min + 1));
            damage = Math.max(min, Math.min(damage, max));

            return damage;
        }

        /**
         * Calculates the Euclidean distance between two points.
         * @param {object} p1 - First point {x, y}.
         * @param {object} p2 - Second point {x, y}.
         * @returns {number} The distance between the two points.
         */
        function getDistance(p1, p2) {
            if (!p1 || !p2) {
                console.error("Attempted to calculate distance with null or undefined point:", p1, p2);
                return Infinity;
            }
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        /**
         * Optimized helper function to find an empty floor tile with caching
         * @param {Array<object>} excludeEntities - An array of entities to avoid placing the tile on.
         * @returns {object|null} An {x, y} object if a spot is found, otherwise null.
         */
        function findEmptyFloorTile(excludeEntities = []) {
            if (player.x === undefined || player.y === undefined || player.x === null || player.y === null) {
                console.error("Player position is undefined or null when trying to find empty floor tile. Cannot guarantee reachability.");
                let attempts = 0;
                const MAX_FALLBACK_ATTEMPTS = 200; // Reduced from 500
                while (attempts < MAX_FALLBACK_ATTEMPTS) {
                    const randX = getRandomInt(0, dynamicMapWidth - 1);
                    const randY = getRandomInt(0, dynamicMapHeight - 1);
                    if (gameMap[randY][randX] === TILE_FLOOR &&
                        !excludeEntities.some(e => e.x === randX && e.y === randY)) {
                        console.warn(`Placed item at (${randX}, ${randY}) without reachability check due to invalid player position.`);
                        return { x: randX, y: randY };
                    }
                    attempts++;
                }
                console.error("Failed to find any empty floor tile even as a last resort.");
                return null;
            }

            // Pre-compute exclude positions for faster lookup
            const excludeSet = new Set();
            for (let i = 0; i < excludeEntities.length; i++) {
                const e = excludeEntities[i];
                excludeSet.add(`${e.x},${e.y}`);
            }

            const potentialTiles = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            // Optimized double loop with early exit conditions
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (gameMap[y][x] === TILE_FLOOR && !excludeSet.has(`${x},${y}`)) {
                        // Quick wall neighbor check
                        let wallNeighbors = 0;
                        for (let i = 0; i < 4; i++) {
                            const dx = directions[i][0];
                            const dy = directions[i][1];
                            const checkX = x + dx;
                            const checkY = y + dy;

                            if (checkX >= 0 && checkX < dynamicMapWidth && checkY >= 0 && checkY < dynamicMapHeight) {
                                if (gameMap[checkY][checkX] === TILE_WALL) {
                                    wallNeighbors++;
                                }
                            } else {
                                wallNeighbors++;
                            }
                        }

                        if (wallNeighbors < 4) {
                            // Cache pathfinding results to avoid repeated calculations
                            const cacheKey = `${player.x},${player.y}-${x},${y}`;
                            let hasPath = pathfindingCache.get(cacheKey);
                            
                            if (hasPath === undefined) {
                                hasPath = findPathBasic(player.x, player.y, x, y, gameMap, dynamicMapWidth, dynamicMapHeight) !== null;
                                pathfindingCache.set(cacheKey, hasPath);
                            }
                            
                            if (hasPath) {
                                potentialTiles.push({ x, y });
                                // Early exit if we have enough options
                                if (potentialTiles.length > 10) {
                                    break;
                                }
                            }
                        }
                    }
                }
                if (potentialTiles.length > 10) break;
            }

            if (potentialTiles.length > 0) {
                const randomIndex = getRandomInt(0, potentialTiles.length - 1);
                return potentialTiles[randomIndex];
            } else {
                console.warn("No reachable empty floor tiles found for placement of item.");
                let attempts = 0;
                const MAX_LAST_RESORT_ATTEMPTS = 200; // Reduced from 500
                while (attempts < MAX_LAST_RESORT_ATTEMPTS) {
                    const randX = getRandomInt(0, dynamicMapWidth - 1);
                    const randY = getRandomInt(0, dynamicMapHeight - 1);
                    if (gameMap[randY][randX] === TILE_FLOOR && !excludeSet.has(`${randX},${randY}`)) {
                        console.warn(`Placed item at (${randX}, ${randY}) as a last resort (reachability not guaranteed).`);
                        return { x: randX, y: randY };
                    }
                    attempts++;
                }
                console.error("Failed to find any empty floor tile even as a last resort.");
                return null;
            }
        }

        /**
         * Finds the shortest path from start to end using Breadth-First Search (BFS).
         * Returns an array of {x, y} coordinates representing the path, or null if no path exists.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {number} endX - Target X coordinate.
         * @param {number} endY - Target Y coordinate.
         * @param {Array<Array<number>>} map - The game map.
         * @param {number} mapWidth - Width of the map.
         * @param {number} mapHeight - Height of the map.
         * @param {Array<object>} [entitiesToStrictlyAvoid=[]] - Optional: An array of entity positions ({x, y}) to treat as impassable.
         * @returns {Array<{x: number, y: number}>|null} The path as an array of coordinates, or null.
         */
        function findPathBasic(startX, startY, endX, endY, map, mapWidth, mapHeight, entitiesToStrictlyAvoid = []) {
            performanceStats.pathfindingCalls++;
            
            // Generate cache key including entities to avoid
            const avoidKey = entitiesToStrictlyAvoid.map(e => `${e.x},${e.y}`).sort().join('|');
            const cacheKey = `basic_${startX},${startY}_${endX},${endY}_${avoidKey}_${cacheValidationFrame}`;
            
            // Check cache first
            if (pathfindingCache.has(cacheKey)) {
                performanceStats.cacheHits++;
                return pathfindingCache.get(cacheKey);
            }
            
            performanceStats.cacheMisses++;
            logPerformanceStats(); // Check if we should log stats

            const queue = [{ x: startX, y: startY, path: [] }];
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            // Pre-compute entity avoid set for faster lookup
            const avoidSet = new Set();
            for (let i = 0; i < entitiesToStrictlyAvoid.length; i++) {
                const e = entitiesToStrictlyAvoid[i];
                avoidSet.add(`${e.x},${e.y}`);
            }

            while (queue.length > 0) {
                const { x, y, path } = queue.shift();

                if (x === endX && y === endY) {
                    const result = path.concat({ x, y });
                    pathfindingCache.set(cacheKey, result);
                    return result;
                }

                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    const posKey = `${newX},${newY}`;

                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS) &&
                        !visited.has(posKey) &&
                        !avoidSet.has(posKey)) {

                        visited.add(posKey);
                        queue.push({ x: newX, y: newY, path: path.concat({ x, y }) });
                    }
                }
            }
            
            pathfindingCache.set(cacheKey, null);
            return null;
        }

        /**
         * Finds the shortest path from start to end using a Dijkstra-like algorithm,
         * with a penalty for moving into tiles adjacent to enemies.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {number} endX - Target X coordinate.
         * @param {number} endY - Target Y coordinate.
         * @param {Array<Array<number>>} map - The game map.
         * @param {number} mapWidth - Width of the map.
         * @param {number} mapHeight - Height of the map.
         * @param {Array<object>} entitiesWithProximityPenalty - An array of entity positions ({x, y}) to apply proximity penalty for.
         * @returns {Array<{x: number, y: number}>|null} The path as an array of coordinates, or null.
         */
        function findPathWithProximityPenalty(startX, startY, endX, endY, map, mapWidth, mapHeight, entitiesWithProximityPenalty) {
            performanceStats.pathfindingCalls++;
            
            // Generate cache key
            const entitiesKey = entitiesWithProximityPenalty.map(e => `${e.x},${e.y}`).sort().join('|');
            const cacheKey = `proximity_${startX},${startY}_${endX},${endY}_${entitiesKey}_${cacheValidationFrame}`;
            
            // Check cache first
            if (pathfindingCache.has(cacheKey)) {
                performanceStats.cacheHits++;
                return pathfindingCache.get(cacheKey);
            }
            
            performanceStats.cacheMisses++;

            const queue = [{ x: startX, y: startY, path: [], cost: 0 }];
            const visitedCosts = new Map();
            visitedCosts.set(`${startX},${startY}`, 0);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Only cardinal directions for pathfinding
            const eightDirections = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]; // For proximity check

            const PROXIMITY_PENALTY = 5; // Cost penalty for moving into a tile adjacent to an entity

            // Pre-compute entity positions for faster lookup
            const entitySet = new Set();
            for (let i = 0; i < entitiesWithProximityPenalty.length; i++) {
                const e = entitiesWithProximityPenalty[i];
                entitySet.add(`${e.x},${e.y}`);
            }

            while (queue.length > 0) {
                queue.sort((a, b) => a.cost - b.cost);
                const { x, y, path, cost } = queue.shift();

                if (cost > visitedCosts.get(`${x},${y}`)) {
                    continue;
                }

                if (x === endX && y === endY) {
                    const result = path.concat({ x, y });
                    pathfindingCache.set(cacheKey, result);
                    return result;
                }

                for (const [dx, dy] of directions) { // Iterate over cardinal directions for movement
                    const newX = x + dx;
                    const newY = y + dy;

                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS)) {

                        let stepCost = 1;

                        // Optimized proximity check using Set
                        for (let i = 0; i < 8; i++) { // Check proximity in all 8 directions
                            const edx = eightDirections[i][0];
                            const edy = eightDirections[i][1];
                            const checkX = newX + edx;
                            const checkY = newY + edy;
                            if (entitySet.has(`${checkX},${checkY}`)) {
                                stepCost += PROXIMITY_PENALTY;
                                break;
                            }
                        }

                        const newCost = cost + stepCost;

                        if (!visitedCosts.has(`${newX},${newY}`) || newCost < visitedCosts.get(`${newX},${newY}`)) {
                            visitedCosts.set(`${newX},${newY}`, newCost);
                            queue.push({ x: newX, y: newY, path: path.concat({ x, y }), cost: newCost });
                        }
                    }
                }
            }
            
            pathfindingCache.set(cacheKey, null);
            return null;
        }

        /**
         * Ultra-safe pathfinding for survival mode - maximizes distance from all enemies
         * with severe penalties for getting close to any threat.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {number} endX - Target X coordinate.
         * @param {number} endY - Target Y coordinate.
         * @param {Array<Array<number>>} map - The game map.
         * @param {number} mapWidth - Width of the map.
         * @param {number} mapHeight - Height of the map.
         * @param {Array<object>} entitiesWithProximityPenalty - An array of entity positions ({x, y}) to apply proximity penalty for.
         * @returns {Array<{x: number, y: number}>|null} The path as an array of coordinates, or null.
         */
        function findPathUltraSafe(startX, startY, endX, endY, map, mapWidth, mapHeight, entitiesWithProximityPenalty) {
            const queue = [{ x: startX, y: startY, path: [], cost: 0 }];
            const visitedCosts = new Map();
            visitedCosts.set(`${startX},${startY}`, 0);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Only cardinal directions for pathfinding

            // Reduced penalties for better movement flow
            const IMMEDIATE_PENALTY = 15; // Reduced from 50 - still avoids enemies but allows movement
            const CLOSE_PENALTY = 8; // Reduced from 20 - moderate penalty for 2 tiles away
            const NEAR_PENALTY = 3; // Reduced from 8 - light penalty for 3 tiles away

            while (queue.length > 0) {
                queue.sort((a, b) => a.cost - b.cost);
                const { x, y, path, cost } = queue.shift();

                if (cost > visitedCosts.get(`${x},${y}`)) {
                    continue;
                }

                if (x === endX && y === endY) {
                    return path.concat({ x, y });
                }

                for (const [dx, dy] of directions) { // Iterate over cardinal directions for movement
                    const newX = x + dx;
                    const newY = y + dy;

                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS)) {

                        let stepCost = 1;

                        // Check multiple distance rings for threats
                        for (const entity of entitiesWithProximityPenalty) {
                            const distance = Math.abs(newX - entity.x) + Math.abs(newY - entity.y); // Manhattan distance
                            if (distance === 1) {
                                stepCost += IMMEDIATE_PENALTY; // Adjacent to enemy
                            } else if (distance === 2) {
                                stepCost += CLOSE_PENALTY; // 2 tiles from enemy
                            } else if (distance === 3) {
                                stepCost += NEAR_PENALTY; // 3 tiles from enemy
                            }
                        }

                        const newCost = cost + stepCost;

                        if (!visitedCosts.has(`${newX},${newY}`) || newCost < visitedCosts.get(`${newX},${newY}`)) {
                            visitedCosts.set(`${newX},${newY}`, newCost);
                            queue.push({ x: newX, y: newY, path: path.concat({ x, y }), cost: newCost });
                        }
                    }
                }
            }
            return null;
        }

        /**
         * Finds a random floor tile for the player's starting position, prioritizing the top-left corner.
         */
        function findPlayerStartInCorner() {
            const playerPos = findEmptyFloorTile([]);
            if (playerPos) {
                player.x = playerPos.x;
                player.y = playerPos.y; // Corrected: assign to player.y
            } else {
                console.error("Failed to find a valid player start position. Forcing placement.");
                player.x = 1;
                player.y = 1;
                if (gameMap[1] && gameMap[1][1] === TILE_WALL) {
                    gameMap[1][1] = TILE_FLOOR; // This is the key part
                }
            }
        }

        /**
         * Checks if all floor tiles are reachable from a starting position, treating stairs as passable
         * @param {number} startX - Starting X coordinate
         * @param {number} startY - Starting Y coordinate
         * @param {Array<Array<number>>} map - The game map
         * @returns {boolean} True if all floor tiles are reachable
         */
        function checkConnectivity(startX, startY, map) {
            const visited = new Set();
            const queue = [{ x: startX, y: startY }];
            visited.add(`${startX},${startY}`);
            
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            let reachableFloorTiles = 0;
            let totalFloorTiles = 0;
            
            // Optimized floor tile counting with early exit potential
            const floorTilePositions = [];
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (map[y][x] === TILE_FLOOR || map[y][x] === TILE_STAIRS) {
                        totalFloorTiles++;
                        floorTilePositions.push({ x, y });
                    }
                }
            }
            
            // Quick exit for small maps
            if (totalFloorTiles <= 1) {
                return true;
            }
            
            // BFS to find all reachable tiles with optimizations
            while (queue.length > 0) {
                const { x, y } = queue.shift();
                
                if (map[y][x] === TILE_FLOOR || map[y][x] === TILE_STAIRS) {
                    reachableFloorTiles++;
                    // Early exit if we've reached all floor tiles
                    if (reachableFloorTiles === totalFloorTiles) {
                        return true;
                    }
                }
                
                // Optimized direction checking
                for (let i = 0; i < 4; i++) {
                    const dx = directions[i][0];
                    const dy = directions[i][1];
                    const newX = x + dx;
                    const newY = y + dy;
                    const posKey = `${newX},${newY}`;
                    
                    if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS) &&
                        !visited.has(posKey)) {
                        
                        visited.add(posKey);
                        queue.push({ x: newX, y: newY });
                    }
                }
            }
            
            return reachableFloorTiles === totalFloorTiles;
        }

        /**
         * Finds a random floor tile in the bottom-right corner for the staircase, prioritizing open areas.
         */
        function placeStairsOppositeCorner() {
            let found = false;
            let attempts = 0;
            const MAX_PLACEMENT_ATTEMPTS = 1000;
            const MIN_OPEN_NEIGHBORS_FOR_STAIRS = 2; // Minimum number of adjacent floor tiles for stairs

            const searchStartX = Math.floor(dynamicMapWidth * 3 / 4);
            const searchStartY = Math.floor(dynamicMapHeight * 3 / 4);

            let validStairsCandidates = [];
            const cardinalDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            // First, try to find candidates with enough open neighbors that don't break connectivity
            for (let y = searchStartY; y < dynamicMapHeight; y++) {
                for (let x = searchStartX; x < dynamicMapWidth; x++) {
                    if (y >= 0 && y < dynamicMapHeight && x >= 0 && x < dynamicMapWidth &&
                        gameMap[y][x] === TILE_FLOOR && (x !== player.x || y !== player.y)) {

                        let openNeighbors = 0;
                        for (const [dx, dy] of cardinalDirections) {
                            const checkX = x + dx;
                            const checkY = y + dy;
                            if (checkX >= 0 && checkX < dynamicMapWidth && checkY >= 0 && checkY < dynamicMapHeight &&
                                gameMap[checkY][checkX] === TILE_FLOOR) {
                                openNeighbors++;
                            }
                        }

                        if (openNeighbors >= MIN_OPEN_NEIGHBORS_FOR_STAIRS) {
                            // Test placing stairs here and check if connectivity is maintained
                            const originalTile = gameMap[y][x];
                            gameMap[y][x] = TILE_STAIRS;
                            
                            if (checkConnectivity(player.x, player.y, gameMap)) {
                                validStairsCandidates.push({ x, y, openNeighbors });
                            }
                            
                            // Restore original tile
                            gameMap[y][x] = originalTile;
                        }
                    }
                }
            }

            // Sort candidates by openNeighbors in descending order
            validStairsCandidates.sort((a, b) => b.openNeighbors - a.openNeighbors);

            if (validStairsCandidates.length > 0) {
                // Pick a random one from the top few, or just the very best one
                const bestCandidatesSlice = validStairsCandidates.slice(0, Math.min(5, validStairsCandidates.length));
                const chosen = bestCandidatesSlice[getRandomInt(0, bestCandidatesSlice.length - 1)];
                stairs.x = chosen.x;
                stairs.y = chosen.y;
                gameMap[stairs.y][stairs.x] = TILE_STAIRS;
                found = true;
            }

            // Fallback if no suitable candidates found with open neighbors - check connectivity for any valid position
            if (!found) {
                attempts = 0;
                while (!found && attempts < MAX_PLACEMENT_ATTEMPTS) {
                    const randX = searchStartX + Math.floor(Math.random() * (dynamicMapWidth - searchStartX));
                    const randY = searchStartY + Math.floor(Math.random() * (dynamicMapHeight - searchStartY));

                    if (randY >= 0 && randY < dynamicMapHeight && randX >= 0 && randX < dynamicMapWidth &&
                        gameMap[randY][randX] === TILE_FLOOR && (randX !== player.x || randY !== player.y)) {
                        
                        // Test connectivity before placing stairs
                        const originalTile = gameMap[randY][randX];
                        gameMap[randY][randX] = TILE_STAIRS;
                        
                        if (checkConnectivity(player.x, player.y, gameMap)) {
                            stairs.x = randX;
                            stairs.y = randY;
                            found = true;
                        } else {
                            // Restore original tile if connectivity fails
                            gameMap[randY][randX] = originalTile;
                        }
                    }
                    attempts++;
                }
            }

            // Final fallback if still not found (should be rare with MAX_PLACEMENT_ATTEMPTS)
            if (!found) {
                attempts = 0;
                while (!found && attempts < MAX_PLACEMENT_ATTEMPTS) {
                    const randX = Math.floor(Math.random() * dynamicMapWidth);
                    const randY = Math.floor(Math.random() * dynamicMapHeight);
                    if (gameMap[randY][randX] === TILE_FLOOR && (randX !== player.x || randY !== player.y)) {
                        
                        // Test connectivity before placing stairs
                        const originalTile = gameMap[randY][randX];
                        gameMap[randY][randX] = TILE_STAIRS;
                        
                        if (checkConnectivity(player.x, player.y, gameMap)) {
                            stairs.x = randX;
                            stairs.y = randY;
                            found = true;
                        } else {
                            // Restore original tile if connectivity fails
                            gameMap[randY][randX] = originalTile;
                        }
                    }
                    attempts++;
                }
            }

            if (!found) {
                console.error("Failed to find a valid stairs position after many attempts. Forcing placement.");
                stairs.x = dynamicMapWidth - 2;
                stairs.y = dynamicMapHeight - 2;
                if (gameMap[dynamicMapHeight - 2] && gameMap[dynamicMapHeight - 2][dynamicMapWidth - 2] === TILE_WALL) {
                    gameMap[dynamicMapHeight - 2][dynamicMapWidth - 2] = TILE_FLOOR;
                }
                gameMap[stairs.y][stairs.x] = TILE_STAIRS;
            }
        }

        /**
         * Spawns enemies on the map, distributing total health points equal to the current level.
         * @param {number} levelHealthBonus - Additional health points for enemies based on player's health.
         * @param {number} playerAverageFlow - The player's average flow so far in the run.
         */
        function spawnEnemies(levelHealthBonus = 0, playerAverageFlow = 0) {
            enemies = [];
            const totalHealthForLevel = currentLevel + levelHealthBonus;

            let actualNumEnemies;
            if (currentLevel === 1) {
                actualNumEnemies = 1; // For level 1, always spawn exactly one enemy
            } else {
                const maxPossibleEnemies = Math.max(1, Math.min(totalHealthForLevel, 7));
                actualNumEnemies = getRandomInt(1, maxPossibleEnemies);
            }

            // Removed: Reintroduced minimum enemies based on level number divided by two
            // actualNumEnemies = Math.max(Math.floor(currentLevel / 2), actualNumEnemies);


            let remainingHealthToDistribute = totalHealthForLevel;

            for (let i = 0; i < actualNumEnemies; i++) {
                const excludeList = [player, stairs, ...enemies]; // Ensure stairs is in the exclude list for spawning
                const enemyPos = findEmptyFloorTile(excludeList);

                if (enemyPos) {
                    let role;
                    const roleRoll = Math.random();
                    if (roleRoll < 0.4) {
                        role = 'hunter';
                    } else if (roleRoll < 0.7) {
                        role = 'guard';
                    } else {
                        role = 'tracker';
                    }

                    // Temporary health for initial flow calculation (will be updated after distribution)
                    const tempEnemyHealth = 1;

                    // Calculate initial enemy flow based on player's average flow and inverse health bias
                    let initialEnemyFlowForThisEnemy = 0;
                    if (playerAverageFlow > 0) {
                        const healthNormalized = tempEnemyHealth / ENEMY_VISUAL_HEALTH_THRESHOLD;
                        // Bias the random factor: lower healthNormalized (lower health) means randomFactor biases towards 0
                        // Higher healthNormalized (higher health) means randomFactor biases towards 1
                        let effectiveRandomFactor = Math.random() * healthNormalized;
                        initialEnemyFlowForThisEnemy = playerAverageFlow * effectiveRandomFactor;
                    }

                    const baseStepsForFlow = 5; // Use a base number of steps to avoid very high flow from 1 damage / 1 step
                    const initialEnemyDamageDealt = initialEnemyFlowForThisEnemy * baseStepsForFlow;
                    const initialEnemyStepsTaken = initialEnemyFlowForThisEnemy > 0 ? baseStepsForFlow : 0;

                    enemies.push({
                        x: enemyPos.x, y: enemyPos.y, role: role, health: tempEnemyHealth,
                        name: generateAgentName(), // Add generated name
                        thrustAnimActive: false, thrustAnimStartTime: 0, thrustAnimDuration: 150,
                        thrustAnimDirectionX: 0, thrustAnimDirectionY: 0, thrustAnimMagnitude: 0,
                        totalDamageDealtByThisEnemy: initialEnemyDamageDealt,
                        stepsTakenByThisEnemy: initialEnemyStepsTaken,
                        flowLevel: initialEnemyFlowForThisEnemy,
                        initialHealth: tempEnemyHealth,
                        totalDamageTakenByThisEnemy: 0
                    });
                    remainingHealthToDistribute--;
                } else {
                    console.warn(`Could not place enemy ${i + 1}. Skipping this enemy.`);
                }
            }

            // Distribute remaining health points among spawned enemies
            while (remainingHealthToDistribute > 0 && enemies.length > 0) {
                const randomIndex = getRandomInt(0, enemies.length - 1);
                enemies[randomIndex].health = enemies[randomIndex].health + 1; // Explicit assignment
                // Update initialHealth here as well, because we're still in the "initialization" phase for this enemy
                enemies[randomIndex].initialHealth = enemies[randomIndex].health;
                remainingHealthToDistribute--;
            }

            // After health distribution, re-calculate flow based on final enemy health
            enemies.forEach(enemy => {
                let finalEnemyFlowForThisEnemy = 0;
                if (playerAverageFlow > 0) {
                    const healthNormalized = enemy.health / ENEMY_VISUAL_HEALTH_THRESHOLD;
                    // Bias the random factor: lower healthNormalized (lower health) means randomFactor biases towards 0
                    // Higher healthNormalized (higher health) means randomFactor biases towards 1
                    let effectiveRandomFactor = Math.random() * healthNormalized;
                    finalEnemyFlowForThisEnemy = playerAverageFlow * effectiveRandomFactor;
                }
                const baseStepsForFlow = 5;
                enemy.totalDamageDealtByThisEnemy = finalEnemyFlowForThisEnemy * baseStepsForFlow;
                enemy.stepsTakenByThisEnemy = finalEnemyFlowForThisEnemy > 0 ? baseStepsForFlow : 0;
                enemy.flowLevel = finalEnemyFlowForThisEnemy; // Update flowLevel with final calculated value
            });


            // Fallback to ensure at least one enemy if somehow none were placed and totalHealthForLevel > 0
            if (totalHealthForLevel > 0 && enemies.length === 0) {
                const enemyPos = findEmptyFloorTile([player, stairs]); // Ensure stairs is excluded even in fallback
                if (enemyPos) {
                    const baseStepsForFlow = 5;
                    const initialEnemyDamageDealt = playerAverageFlow * baseStepsForFlow; // Use player flow as fallback
                    const initialEnemyStepsTaken = playerAverageFlow > 0 ? baseStepsForFlow : 0;
                    enemies.push({
                        x: enemyPos.x, y: enemyPos.y, role: 'hunter', health: totalHealthForLevel,
                        thrustAnimActive: false, thrustAnimStartTime: 0, thrustAnimDirectionX: 0, thrustAnimDirectionY: 0, thrustAnimMagnitude: 0,
                        totalDamageDealtByThisEnemy: initialEnemyDamageDealt, stepsTakenByThisEnemy: initialEnemyStepsTaken,
                        flowLevel: playerAverageFlow, // Fallback flow level
                        initialHealth: totalHealthForLevel, // Fallback initial health
                        totalDamageTakenByThisEnemy: 0 // Initialize for new enemy flow logic
                    });
                } else {
                    console.error("Critical: Could not place any enemies even for fallback!");
                }
            }
        }

        /**
         * Spawns scattered health pickups on the map.
         */
        function spawnPickups() {
            // Filter out previous level's static pickups, keep only enemy drops (if any are left uncollected)
            staticDamageNumbers = staticDamageNumbers.filter(item => item.isEnemyDrop);

            let pointsToDistribute = currentLevel;
            let numPickupsToSpawn = 0;

            if (currentLevel === 1) {
                numPickupsToSpawn = 1; // For level 1, always spawn exactly one pickup
            } else {
                // For other levels, distribute points among multiple pickups as before
                // This logic can be refined if you want a specific number of pickups per level
                // For now, it will try to create pickups with values up to currentLevel,
                // resulting in a variable number of pickups.
                numPickupsToSpawn = currentLevel; // A rough estimate, actual number depends on random values
            }

            for (let i = 0; i < numPickupsToSpawn && pointsToDistribute > 0; i++) {
                const excludeList = [player, stairs, ...enemies, ...staticDamageNumbers.map(s => ({x: s.x, y: s.y}))];
                const pickupPos = findEmptyFloorTile(excludeList);

                if (pickupPos) {
                    let pickupValue;
                    if (currentLevel === 1) {
                        pickupValue = pointsToDistribute; // For level 1, the single pickup gets all points
                    } else {
                        // Determine the maximum value for the current pickup.
                        // It should be at least 1, not more than the remaining points.
                        const maxPickupValue = pointsToDistribute;
                        pickupValue = getRandomInt(1, maxPickupValue);
                    }
                    
                    staticDamageNumbers.push({
                        x: pickupPos.x,
                        y: pickupPos.y,
                        parts: [{ content: { type: 'number', value: pickupValue }, offsetX: 0, offsetY: 0 }],
                        isEnemyDrop: false // Mark as a static pickup
                    });
                    pointsToDistribute = pointsToDistribute - pickupValue; // Explicit assignment
                } else {
                    console.warn(`Could not place a pickup with ${pointsToDistribute} points. Remaining: ${pointsToDistribute}.`);
                    break; // Stop if no more spots can be found
                }
            }
        }

        /**
         * Draws an off-screen indicator for an entity.
         * @param {object} entity - The entity ({x, y}) to draw an indicator for.
         * @param {string} color - The color of the indicator.
         * @param {number} offsetX - The camera's X offset.
         * @param {number} offsetY - The camera's Y offset.
         * @param {number} opacity - The opacity of the indicator.
         */
        function drawOffScreenIndicator(entity, color, offsetX, offsetY, opacity) {
            const minIndicatorSize = dynamicTileSize * 0.3;
            const maxIndicatorSize = dynamicTileSize;

            const entityPixelX = entity.x * dynamicTileSize + offsetX;
            const entityPixelY = entity.y * dynamicTileSize + offsetY;

            const distFromLeft = Math.max(0, -entityPixelX);
            const distFromRight = Math.max(0, entityPixelX + gameCanvas.width - gameCanvas.width); // Use gameCanvas.width
            const distFromTop = Math.max(0, -entityPixelY);
            const distFromBottom = Math.max(0, entityPixelY + gameCanvas.height - gameCanvas.height); // Use gameCanvas.height

            const distanceOffScreen = Math.max(distFromLeft, distFromRight, distFromTop, distFromBottom);

            const maxScalingDistance = Math.max(gameCanvas.width, gameCanvas.height) / 3; // Use gameCanvas.width/height

            const normalizedDistance = Math.min(distanceOffScreen / maxScalingDistance, 1);

            const currentIndicatorSize = maxIndicatorSize - (normalizedDistance * (maxScalingDistance - minIndicatorSize));

            let indicatorX, indicatorY;

            if (entityPixelX < 0) {
                indicatorX = 0;
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width) { // Use gameCanvas.width
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
            } else {
                indicatorX = entityPixelX + (dynamicTileSize / 2) - (currentIndicatorSize / 2);
            }

            if (entityPixelY < 0) {
                indicatorY = 0;
            } else if (entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else {
                indicatorY = entityPixelY + (dynamicTileSize / 2) - (currentIndicatorSize / 2);
            }

            if (entityPixelX < 0 && entityPixelY < 0) {
                indicatorX = 0;
                indicatorY = 0;
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width && entityPixelY < 0) { // Use gameCanvas.width
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
                indicatorY = 0;
            } else if (entityPixelX < 0 && entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorX = 0;
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width && entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.width/height
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else if (entityPixelX < 0 || entityPixelX + dynamicTileSize > gameCanvas.width) { // Use gameCanvas.width
                indicatorY = Math.max(0, Math.min(gameCanvas.height - currentIndicatorSize, indicatorY)); // Use gameCanvas.height
            } else if (entityPixelY < 0 || entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorX = Math.max(0, Math.min(gameCanvas.width - currentIndicatorSize, indicatorX)); // Use gameCanvas.width
            }

            ctx.save();
            ctx.globalAlpha = opacity; // Apply opacity to the indicator
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(indicatorX), Math.floor(indicatorY), Math.floor(currentIndicatorSize), Math.floor(currentIndicatorSize));
            ctx.restore();
        }

        // Add a roundRect method to CanvasRenderingContext2D for drawing rounded rectangles
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
            if (width < 2 * radius) radius = width / 2;
            if (height < 2 * radius) radius = height / 2;
            this.beginPath();
            this.moveTo(x + radius, y);
            this.arcTo(x + width, y, x + width, y + height, radius);
            this.arcTo(x + width, y + height, x, y + height, radius);
            this.arcTo(x, y + height, x, y, radius);
            this.arcTo(x, y, x + width, y, radius);
            this.closePath();
            return this;
        };

        /**
         * Draws the game map, stairs, player, and enemies on the canvas with a camera effect.
         */
        function drawGame() {
            try {
                // Early validation
                if (!ctx || !gameCanvas) {
                    console.error('Canvas or context not initialized');
                    return;
                }

                // Clear the canvas with a black background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

                // Validate critical game state
                if (!gameMap || !gameMap.length || !gameMap[0] || !gameMap[0].length) {
                    console.error("Game map is invalid or empty");
                    return;
                }

                // Validate player object exists
                if (!player) {
                    console.error("Player object not initialized");
                    return;
                }

                // Validate player position before drawing
                if (isNaN(player.x) || isNaN(player.y) || player.x === null || player.y === null) {
                    console.error("Player position is invalid. Stopping drawGame.");
                    return;
                }

                // Validate currentLevel is defined
                if (typeof currentLevel === 'undefined' || currentLevel === null) {
                    console.error("currentLevel is not defined");
                    return;
                }

                const now = performance.now();

                let currentRenderTileSize;
                let currentRenderOffsetX;
                let currentRenderOffsetY;

                // Calculate the target dynamicTileSize for the current level based on current canvas dimensions
                const targetDynamicTileSizeForLevel = (() => {
                    const initialMaxTileSize = Math.floor(Math.min(gameCanvas.width / MAX_VISIBLE_TILES_LEVEL1, gameCanvas.height / MAX_VISIBLE_TILES_LEVEL1));
                    const finalMinTileSize = Math.floor(Math.min(gameCanvas.width / MIN_VISIBLE_TILES_MAX_LEVEL, gameCanvas.height / MIN_VISIBLE_TILES_MAX_LEVEL));
                    let calculated = initialMaxTileSize - ((Math.min(currentLevel, ZOOM_LEVELS_EFFECTIVE) - 1) * (initialMaxTileSize - finalMinTileSize) / (ZOOM_LEVELS_EFFECTIVE - 1));
                    return Math.max(finalMinTileSize, Math.floor(calculated));
                })();


                if (deathAnimationActive) {
                    const elapsed = now - deathAnimationStartTime;
                    const zoomProgress = Math.min(1, elapsed / DEATH_ZOOM_DURATION);

                    // For death zoom, we zoom *into* the current dynamicTileSize
                    currentRenderTileSize = Math.floor(targetDynamicTileSizeForLevel + (targetDynamicTileSizeForLevel * DEATH_ZOOM_TARGET_TILE_SCALE - targetDynamicTileSizeForLevel) * zoomProgress);

                    // Clamp currentRenderTileSize to prevent it from getting too large or small
                    currentRenderTileSize = Math.max(1, currentRenderTileSize); // Ensure it's at least 1 pixel

                    const targetPlayerCenterScreenX = gameCanvas.width / 2; // Use dynamic canvas width
                    const targetPlayerCenterScreenY = gameCanvas.height / 2; // Use dynamic canvas height

                    currentRenderOffsetX = Math.floor(targetPlayerCenterScreenX - (player.x * currentRenderTileSize + currentRenderTileSize / 2));
                    currentRenderOffsetY = Math.floor(targetPlayerCenterScreenY - (player.y * currentRenderTileSize + currentRenderTileSize / 2));

                    // Remove camera clamping to allow viewing beyond map boundaries during death animation
                    // const totalMapPixelWidthZoomed = dynamicMapWidth * currentRenderTileSize;
                    // const totalMapPixelHeightZoomed = dynamicMapHeight * currentRenderTileSize;
                    // currentRenderOffsetX = Math.max(gameCanvas.width - totalMapPixelWidthZoomed, Math.min(0, currentRenderOffsetX));
                    // currentRenderOffsetY = Math.max(gameCanvas.height - totalMapPixelHeightZoomed, Math.min(0, currentRenderOffsetY));

                } else if (gameStartZoomActive) {
                    const elapsed = now - gameStartZoomStartTime;
                    // Make zoom faster and smooth, slowing at the end (ease-out cubic)
                    const rawProgress = Math.min(1, elapsed / (GAME_START_ZOOM_OUT_DURATION * 0.6)); // 40% faster overall
                    // Ease-out cubic: f(t) = 1 - (1 - t)^3
                    const zoomProgress = 1 - Math.pow(1 - Math.min(rawProgress, 1), 3);

                    // Interpolate currentRenderTileSize from the initial zoomed-in size (dynamicTileSize)
                    // to the target normal level size (targetDynamicTileSizeForLevel)
                    currentRenderTileSize = Math.floor(dynamicTileSize - ((dynamicTileSize - targetDynamicTileSizeForLevel) * zoomProgress));

                    // Clamp currentRenderTileSize to prevent it from getting too large or small
                    currentRenderTileSize = Math.max(1, currentRenderTileSize); // Ensure it's at least 1 pixel

                    // Update offsets based on the current animated tile size
                    currentRenderOffsetX = Math.floor((gameCanvas.width / 2 - currentRenderTileSize / 2) - (player.x * currentRenderTileSize));
                    currentRenderOffsetY = Math.floor((gameCanvas.height / 2 - currentRenderTileSize / 2) - (player.y * currentRenderTileSize));

                    if (zoomProgress >= 1) {
                        gameStartZoomActive = false;
                        // Once zoom-out is complete, ensure dynamicTileSize is set to its final, level-appropriate value
                        dynamicTileSize = targetDynamicTileSizeForLevel;
                    }
                } else {
                    // Default case: no specific zoom animation active
                    currentRenderTileSize = Math.floor(dynamicTileSize); // Use the base dynamicTileSize
                    currentRenderOffsetX = Math.floor((gameCanvas.width / 2 - dynamicTileSize / 2) - (player.x * dynamicTileSize));
                    currentRenderOffsetY = Math.floor((gameCanvas.height / 2 - dynamicTileSize / 2) - (player.y * dynamicTileSize));
                }

                // Ensure all drawing dimensions are integers to prevent sub-pixel rendering artifacts
                currentRenderTileSize = Math.floor(currentRenderTileSize);
                currentRenderOffsetX = Math.floor(currentRenderOffsetX);
                currentRenderOffsetY = Math.floor(currentRenderOffsetY);

                const totalMapPixelWidth = dynamicMapWidth * currentRenderTileSize;
                const totalMapPixelHeight = dynamicMapHeight * currentRenderTileSize;

                // Remove camera clamping to allow viewing beyond map boundaries (void space)
                // currentRenderOffsetX = Math.max(gameCanvas.width - totalMapPixelWidth, Math.min(0, currentRenderOffsetX));
                // currentRenderOffsetY = Math.max(gameCanvas.height - totalMapPixelHeight, Math.min(0, currentRenderOffsetY));

                // Calculate the range of tiles to draw to fill the entire screen
                const startTileX = Math.floor(-currentRenderOffsetX / currentRenderTileSize) - 1;
                const endTileX = Math.ceil((gameCanvas.width - currentRenderOffsetX) / currentRenderTileSize) + 1;
                const startTileY = Math.floor(-currentRenderOffsetY / currentRenderTileSize) - 1;
                const endTileY = Math.ceil((gameCanvas.height - currentRenderOffsetY) / currentRenderTileSize) + 1;

                for (let y = startTileY; y < endTileY; y++) {
                    for (let x = startTileX; x < endTileX; x++) {
                        const tileDrawX = Math.floor(x * currentRenderTileSize + currentRenderOffsetX);
                        const tileDrawY = Math.floor(y * currentRenderTileSize + currentRenderOffsetY);
                        const tileSize = Math.floor(currentRenderTileSize);

                        // Check if this tile is within the actual map bounds
                        if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                            const tileType = gameMap[y][x];
                            switch (tileType) {
                                case TILE_WALL:
                                    ctx.fillStyle = COLOR_WALL;
                                    ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                    break;
                                case TILE_FLOOR:
                                    ctx.fillStyle = COLOR_FLOOR;
                                    ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                    break;
                                case TILE_STAIRS:
                                    // Stairs color is now dynamic based on level
                                    const stairsHealthRatio = currentLevel / ZOOM_LEVELS_EFFECTIVE; // Use currentLevel for stairs "health"
                                    const currentStairsColor = getHealthColor(FIXED_COLOR_STAIRS, currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold
                                    ctx.fillStyle = currentStairsColor;
                                    ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                    break;
                            }
                        }
                        // Outside map bounds = void space (already black from canvas clear)
                    }
                }



                const stairsCanvasX = stairs.x * currentRenderTileSize + currentRenderOffsetX;
                const stairsCanvasY = stairs.y * currentRenderTileSize + currentRenderOffsetY;
                const areStairsOnScreen = stairsCanvasX >= -currentRenderTileSize && stairsCanvasX < gameCanvas.width &&
                                           stairsCanvasY >= -currentRenderTileSize && stairsCanvasY < gameCanvas.height;

                // Calculate opacity and font weight for stairs based on currentLevel
                const stairsOpacity = getOpacity(currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold
                const stairsFontWeight = getFontWeight(currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold
                const currentStairsColor = getHealthColor(FIXED_COLOR_STAIRS, currentLevel, ZOOM_LEVELS_EFFECTIVE); // Use dynamic color for stairs

                if (areStairsOnScreen) {
                    ctx.save();
                    ctx.globalAlpha = stairsOpacity; // Apply opacity to stairs
                    ctx.fillStyle = currentStairsColor; // Use dynamic color
                    ctx.fillRect(Math.floor(stairsCanvasX), Math.floor(stairsCanvasY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                    ctx.restore();

                    // Draw the next level number on the stairs
                    ctx.save();
                    ctx.globalAlpha = stairsOpacity; // Apply opacity to stairs number
                    ctx.fillStyle = '#FFFFFF'; // White color for the level number
                    ctx.font = `${stairsFontWeight} ${Math.floor(currentRenderTileSize * 0.6)}px VT323`; // Apply font weight
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(currentLevel + 1, Math.floor(stairsCanvasX + currentRenderTileSize / 2), Math.floor(stairsCanvasY + currentRenderTileSize / 2));
                    ctx.restore();
                } else {
                    drawOffScreenIndicator(stairs, currentStairsColor, currentRenderOffsetX, currentRenderOffsetY, stairsOpacity); // Indicator also uses dynamic color and opacity
                }

                enemies.forEach(enemy => {
                    const enemyCanvasX = enemy.x * currentRenderTileSize + currentRenderOffsetX;
                    const enemyCanvasY = enemy.y * currentRenderTileSize + currentRenderOffsetY;

                    const isEnemyOnScreen = enemyCanvasX >= -currentRenderTileSize && enemyCanvasX < gameCanvas.width &&
                                            enemyCanvasY >= -currentRenderTileSize && enemyCanvasY < gameCanvas.height;

                    let currentEnemyThrustOffsetX = 0;
                    let currentEnemyThrustOffsetY = 0;
                    let enemyHealthOpacity = 1;

                    if (enemy.thrustAnimActive) {
                        const elapsed = (now - enemy.thrustAnimStartTime) * timeScale; // Apply timeScale
                        if (elapsed < enemy.thrustAnimDuration) {
                            const progress = elapsed / enemy.thrustAnimDuration;
                            const thrustFactor = Math.sin(progress * Math.PI); // Smooth forward and back
                            const displacementMagnitude = currentRenderTileSize * 0.4 * enemy.thrustAnimMagnitude; // Max thrust is 40% of tile size, scaled by damage
                            currentEnemyThrustOffsetX = enemy.thrustAnimDirectionX * thrustFactor * displacementMagnitude;
                            currentEnemyThrustOffsetY = enemy.thrustAnimDirectionY * thrustFactor * displacementMagnitude;
                            enemyHealthOpacity = 1 - (progress * 0.5); // Fade out slightly
                        } else {
                            enemy.thrustAnimActive = false; // Animation finished
                        }
                    }

                    // Calculate health ratio for enemy color and font
                    let currentEnemyColor = getHealthColor(FIXED_COLOR_ENEMY, enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Base color based on health

                    // Calculate enemy flow for blinking effect
                    // MODIFIED: Enemy flow now uses flowLevel if no damage taken, otherwise damage taken flow.
                    const enemyVisualFlow = enemy.totalDamageTakenByThisEnemy > 0
                        ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1) // Ensure no division by zero
                        : enemy.flowLevel; // Use initial flowLevel if no damage taken yet

                    const enemyFlowIntensity = Math.min(1, enemyVisualFlow); // Cap intensity at 1 flow

                    let enemyFlowScale = 1;
                    if (enemyFlowIntensity > 0) {
                        // Invert flow intensity for blink speed: higher flow -> smaller blink speed (faster)
                        const minBlinkSpeed = 50; // Fastest blink speed (for flowIntensity = 1)
                        const maxBlinkSpeed = 200; // Slowest blink speed (for flowIntensity = 0, effectively)
                        const currentBlinkSpeed = maxBlinkSpeed - (maxBlinkSpeed - minBlinkSpeed) * enemyFlowIntensity;
                        const blinkFactor = (Math.sin(now / currentBlinkSpeed) + 1) / 2; // Smooth pulse from 0 to 1

                        // Convert currentEnemyColor to HSL to modulate it for blinking
                        let [h_e, s_e, l_e] = hexToHsl(currentEnemyColor);

                        // Apply saturation boost based on blinkFactor and flowIntensity
                        const maxSaturationBoost_e = 50; // Increased for more obvious effect, same as player
                        s_e = s_e + (blinkFactor * enemyFlowIntensity * maxSaturationBoost_e);
                        s_e = Math.min(100, s_e); // Clamp saturation

                        // Apply a subtle lightness pulse, making it slightly brighter at the peak of the blink
                        const maxLightnessPulse_e = 20; // Increased for more obvious effect, same as player
                        l_e = l_e + (blinkFactor * enemyFlowIntensity * maxLightnessPulse_e);
                        l_e = Math.min(100, l_e); // Clamp lightness

                        currentEnemyColor = hslToHex(h_e, s_e, l_e);

                        enemyFlowScale = 1 + (enemyFlowIntensity * 0.1 * blinkFactor); // Apply size pulse based on flow
                    }


                    const enemyFontWeight = getFontWeight(enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Pass current health and threshold
                    const enemyOpacity = getOpacity(enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Get opacity based on health

                    if (isEnemyOnScreen) {
                        // Draw enemy square
                        ctx.save();
                        ctx.globalAlpha = enemyOpacity;
                        ctx.fillStyle = currentEnemyColor;
                        ctx.fillRect(Math.floor(enemyCanvasX), Math.floor(enemyCanvasY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                        ctx.restore();

                        // Draw enemy health number
                        ctx.save();
                        ctx.globalAlpha = enemyHealthOpacity;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = `${enemyFontWeight} ${Math.floor(currentRenderTileSize * 0.5 * enemyFlowScale)}px VT323`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(enemy.health, Math.floor(enemyCanvasX + currentRenderTileSize / 2 + currentEnemyThrustOffsetX), Math.floor(enemyCanvasY + currentRenderTileSize / 2 + currentEnemyThrustOffsetY));
                        ctx.restore();

                        // Draw enemy name in a crisp font at the bottom of the square
                        ctx.save();
                        ctx.globalAlpha = 1;  // Full opacity for better legibility
                        // Crisp font with slightly reduced weight and smaller size
                        ctx.font = `${Math.max(8, Math.floor(currentRenderTileSize * 0.2))}px 'VT323'`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';  // Align to bottom of the square
                        // Draw black outline first for better contrast
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(enemy.name, 
                            Math.floor(enemyCanvasX + currentRenderTileSize / 2),
                            Math.floor(enemyCanvasY + currentRenderTileSize));
                        // Then draw white text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(enemy.name, 
                            Math.floor(enemyCanvasX + currentRenderTileSize / 2),
                            Math.floor(enemyCanvasY + currentRenderTileSize));
                        ctx.restore();
                    } else {
                        drawOffScreenIndicator(enemy, currentEnemyColor, currentRenderOffsetX, currentRenderOffsetY, enemyOpacity); // Indicator also uses dynamic color and opacity
                    }
                });

                let currentHealthTextScale = 1;
                const healthAnimDuration = 200;
                if (player.healthAnimStartTime > 0 && (now - player.healthAnimStartTime) * timeScale < healthAnimDuration) { // Apply timeScale
                    const progress = ((now - player.healthAnimStartTime) * timeScale) / healthAnimDuration;
                    if (progress < 0.5) {
                        currentHealthTextScale = 1 + (0.5 * progress * 2);
                    } else {
                        currentHealthTextScale = 1.5 - (0.5 * (progress - 0.5) * 2);
                    }
                } else {
                    player.healthAnimStartTime = 0;
                }

                let currentPlayerThrustOffsetX = 0;
                let currentPlayerThrustOffsetY = 0;
                let playerHealthOpacity = 1;

                if (player.thrustAnimActive) {
                    const elapsed = (now - player.thrustAnimStartTime) * timeScale; // Apply timeScale
                    if (elapsed < player.thrustAnimDuration) {
                        const progress = elapsed / player.thrustAnimDuration;
                        const thrustFactor = Math.sin(progress * Math.PI); // Smooth forward and back
                        const displacementMagnitude = currentRenderTileSize * 0.4 * player.thrustAnimMagnitude; // Max thrust is 40% of tile size, scaled by damage
                        currentPlayerThrustOffsetX = player.thrustAnimDirectionX * thrustFactor * displacementMagnitude;
                        currentPlayerThrustOffsetY = player.thrustAnimDirectionY * thrustFactor * displacementMagnitude;
                        playerHealthOpacity = 1 - (progress * 0.5); // Fade out slightly
                    } else {
                        player.thrustAnimActive = false; // Animation finished
                    }
                }

                // Calculate health ratio for player color and font
                let currentPlayerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Base color based on health

                // Calculate player flow for blinking effect
                playerFlow = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0; // Assign to the global playerFlow
                const flowIntensity = Math.min(1, playerFlow); // Cap intensity at 1 flow

                let playerFlowScale = 1; // Initialize playerFlowScale
                if (flowIntensity > 0) {
                    // Invert flow intensity for blink speed: higher flow -> smaller blink speed (faster)
                    const minBlinkSpeed = 50; // Fastest blink speed (for flowIntensity = 1)
                    const maxBlinkSpeed = 200; // Slowest blink speed (for flowIntensity = 0, effectively)
                    const currentBlinkSpeed = maxBlinkSpeed - (maxBlinkSpeed - minBlinkSpeed) * flowIntensity;
                    const blinkFactor = (Math.sin(now / currentBlinkSpeed) + 1) / 2; // Smooth pulse from 0 to 1

                    // Convert currentPlayerColor to HSL to modulate it for blinking
                    let [h, s, l] = hexToHsl(currentPlayerColor);

                    // Apply saturation boost based on blinkFactor and flowIntensity
                    const maxSaturationBoost = 50; // Increased for more obvious effect
                    s = s + (blinkFactor * flowIntensity * maxSaturationBoost);
                    s = Math.min(100, s); // Clamp saturation

                    // Apply a subtle lightness pulse, making it slightly brighter at the peak of the blink
                    const maxLightnessPulse = 20; // Increased for more obvious effect
                    l = l + (blinkFactor * flowIntensity * maxLightnessPulse);
                    l = Math.min(100, l); // Clamp lightness

                    currentPlayerColor = hslToHex(h, s, l);

                    playerFlowScale = 1 + (flowIntensity * 0.1 * blinkFactor); // Apply size pulse based on flow
                }

                const playerFontWeight = getFontWeight(player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Pass current health and threshold
                const playerOpacity = getOpacity(player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Get opacity based on health

                // Only draw player if not game over (player explodes and is no longer drawn as a solid block)
                    if (!gameOver) {
                        // Draw player square
                        ctx.save();
                        ctx.globalAlpha = playerOpacity;
                        ctx.fillStyle = currentPlayerColor;
                        ctx.fillRect(Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX), Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                        
                        // Draw player name in a crisp font at the bottom of the square
                        ctx.save();
                        ctx.globalAlpha = 1;  // Full opacity for better legibility
                        // Crisp font with slightly reduced weight and smaller size
                        ctx.font = `${Math.max(8, Math.floor(currentRenderTileSize * 0.2))}px 'VT323'`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';  // Align to bottom of the square
                        // Draw black outline first for better contrast
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(player.name, 
                            Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2), 
                            Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize));
                        // Then draw white text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(player.name, 
                            Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2), 
                            Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize));
                        ctx.restore();
                        ctx.restore();
                    ctx.save(); // Save context again for text opacity
                    ctx.globalAlpha = playerHealthOpacity; // Apply thrust animation opacity
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${playerFontWeight} ${Math.floor(currentRenderTileSize * 0.5 * currentHealthTextScale * playerFlowScale)}px VT323`; // Use dynamic font weight and flow scale
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(player.health, Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + currentPlayerThrustOffsetX), Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + currentPlayerThrustOffsetY));
                    ctx.restore(); // Restore context
                }


                for (let i = activeExplosions.length - 1; i >= 0; i--) {
                    const explosion = activeExplosions[i];
                    const elapsed = (now - explosion.startTime) * timeScale; // Apply timeScale
                    const progress = elapsed / explosion.duration;

                    if (progress >= 1) {
                        activeExplosions.splice(i, 1);
                        continue;
                    }

                    for (let j = explosion.particles.length - 1; j >= 0; j--) {
                        const particle = explosion.particles[j];
                        const particleProgress = ((now - particle.startTime) * timeScale) / particle.duration; // Apply timeScale

                        if (particleProgress >= 1) {
                            continue;
                        }

                        // Calculate current size of the particle (shrinks over time)
                        const initialParticleSize = currentRenderTileSize * 0.2; // Starting size for fragments
                        const currentParticleSize = initialParticleSize * (1 - particleProgress * 0.7); // Shrink more significantly

                        const currentX = particle.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + particle.initialVelocityX * elapsed;
                        const currentY = particle.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + particle.initialVelocityY * elapsed;

                        ctx.save();
                        ctx.globalAlpha = (1 - particleProgress) * particle.fadeFactor; // Apply random fade factor
                        ctx.fillStyle = particle.color;
                        ctx.fillRect(Math.floor(currentX - currentParticleSize / 2), Math.floor(currentY - currentParticleSize / 2), Math.floor(currentParticleSize), Math.floor(currentParticleSize));
                        ctx.restore();
                    }
                }

                // Draw static pickups (including player remains)
                // Note: Text alignment is now set individually for each pickup to position them at corners
                staticDamageNumbers.forEach(staticNum => {
                    if (staticNum.parts && staticNum.parts.length > 0) {
                        staticNum.parts.forEach(part => {
                            let writhingXOffset = 0;
                            let writhingYOffset = 0;
                            if (staticNum.isPlayerRemains) {
                                writhingXOffset = Math.cos(staticNum.writhingOffsetAngle + now * staticNum.writhingSpeed) * staticNum.writhingOffsetRadius;
                                writhingYOffset = Math.sin(staticNum.writhingOffsetAngle + now * staticNum.writhingSpeed) * staticNum.writhingOffsetRadius;
                            }

                            // Position pickup numbers around the edges of the tile to avoid center overlap with agent health
                            // Use a hash of the pickup position to deterministically place it in a corner
                            // Player remains stay centered for visibility
                            let cornerOffsetX, cornerOffsetY, textAlign, textBaseline;
                            
                            if (staticNum.isPlayerRemains) {
                                // Keep player remains centered and visible
                                cornerOffsetX = currentRenderTileSize / 2;
                                cornerOffsetY = currentRenderTileSize / 2;
                                textAlign = 'center';
                                textBaseline = 'middle';
                            } else {
                                // Position regular pickups in corners based on position hash
                                const positionHash = (staticNum.x * 31 + staticNum.y * 17) % 4; // Generate 0-3 for four corners
                                const edgeMargin = Math.max(4, Math.floor(currentRenderTileSize * 0.1)); // Small margin from tile edge
                                
                                switch (positionHash) {
                                    case 0: // Top-left
                                        cornerOffsetX = edgeMargin;
                                        cornerOffsetY = edgeMargin;
                                        textAlign = 'left';
                                        textBaseline = 'top';
                                        break;
                                    case 1: // Top-right
                                        cornerOffsetX = currentRenderTileSize - edgeMargin;
                                        cornerOffsetY = edgeMargin;
                                        textAlign = 'right';
                                        textBaseline = 'top';
                                        break;
                                    case 2: // Bottom-left
                                        cornerOffsetX = edgeMargin;
                                        cornerOffsetY = currentRenderTileSize - edgeMargin;
                                        textAlign = 'left';
                                        textBaseline = 'bottom';
                                        break;
                                    case 3: // Bottom-right
                                        cornerOffsetX = currentRenderTileSize - edgeMargin;
                                        cornerOffsetY = currentRenderTileSize - edgeMargin;
                                        textAlign = 'right';
                                        textBaseline = 'bottom';
                                        break;
                                }
                            }
                            
                            const drawX = staticNum.x * currentRenderTileSize + currentRenderOffsetX + cornerOffsetX + part.offsetX + writhingXOffset;
                            const drawY = staticNum.y * currentRenderTileSize + currentRenderOffsetY + cornerOffsetY + part.offsetY + writhingYOffset;
                            
                            // Determine color based on type of pickup
                            ctx.fillStyle = staticNum.isPlayerRemains ? staticNum.playerDeathColor : '#CCCC00'; // Use playerDeathColor if it's player remains

                            // Apply font weight based on pickup value - make pickups smaller and less bold
                            const pickupFontWeight = staticNum.isPlayerRemains ? 600 : Math.max(400, getFontWeight(part.content.value, Math.max(2, currentLevel)) - 200);
                            
                            // Make pickup font size much smaller to avoid overlaps
                            const baseFontSize = Math.floor(currentRenderTileSize * 0.3); // Reduced from 0.6 to 0.3
                            const minFontSize = Math.max(10, Math.floor(currentRenderTileSize * 0.25)); // Much smaller minimum
                            const pickupFontSize = Math.max(minFontSize, baseFontSize);
                            
                            ctx.font = `${pickupFontWeight} ${pickupFontSize}px VT323`;

                            // IMPORTANT: Remove yellow background squares
                            // Clear any canvas effects that might create backgrounds
                            ctx.save(); // Save current state
                            ctx.shadowBlur = 0;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;
                            ctx.shadowColor = 'transparent';
                            ctx.globalAlpha = 1; // Ensure no alpha blending issues
                            ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
                            
                            // Set text alignment based on corner position
                            ctx.textAlign = textAlign;
                            ctx.textBaseline = textBaseline;
                            
                            // Draw either number or symbol
                            if (part.content.type === 'number') {
                                ctx.fillText(part.content.value, Math.floor(drawX), Math.floor(drawY));
                            } else if (part.content.type === 'symbol') {
                                ctx.fillText(part.content.value, Math.floor(drawX), Math.floor(drawY));
                            }
                            
                            ctx.restore(); // Restore previous state
                        });
                    }
                });

                // Drawing activeDamageTextAnimations
                for (let i = activeDamageTextAnimations.length - 1; i >= 0; i--) {
                    const anim = activeDamageTextAnimations[i];
                    const elapsed = (now - anim.startTime) * timeScale; // Apply timeScale

                    if (elapsed < anim.delay) {
                        continue;
                    }

                    const effectiveElapsed = elapsed - anim.delay;
                    const progress = effectiveElapsed / anim.duration;

                    if (progress >= 1) {
                        activeDamageTextAnimations.splice(i, 1);
                        continue;
                    }

                    const opacity = 1 - progress;
                    const moveDistance = currentRenderTileSize * 1.2 * progress;

                    const drawX = Math.floor(anim.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.dirX * moveDistance);
                    const drawY = Math.floor(anim.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.dirY * moveDistance);

                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = anim.color;
                    const baseFontSize = currentRenderTileSize * 0.6;
                    const scaledFontSize = baseFontSize + (anim.amount * (currentRenderTileSize * 0.05));
                    ctx.font = `${Math.floor(scaledFontSize * (1 - progress * 0.5))}px VT323`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(anim.amount, drawX, drawY); // Draw the damage amount
                    ctx.restore();
                }

                // Drawing activePickupAnimations
                for (let i = activePickupAnimations.length - 1; i >= 0; i--) {
                    const anim = activePickupAnimations[i];
                    const elapsed = (now - anim.startTime) * timeScale; // Apply timeScale
                    const progress = elapsed / anim.duration;

                    if (progress >= 1) {
                        activePickupAnimations.splice(i, 1);
                        continue;
                    }

                    const opacity = 1 - progress;

                    const currentX = anim.startX * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.initialOffsetX + (player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 - (anim.startX * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.initialOffsetX)) * progress;
                    const currentY = anim.startY * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.initialOffsetY + (player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 - (anim.startY * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.initialOffsetY)) * progress;


                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = VINTAGE_GREEN; // Green color for health pickups
                    ctx.font = `${Math.floor(currentRenderTileSize * 0.6 * (1 - progress * 0.5))}px VT323`; // Shrink slightly
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(anim.amount, Math.floor(currentX), Math.floor(currentY));
                    ctx.restore();
                }

                // Calculate and draw the score at the top left
                let score = 0;
                if (stepsTaken > 0) {
                    const averageDamagePerTurn = totalDamageDealt / stepsTaken;
                    score = Math.floor(totalDamageDealt * averageDamagePerTurn);
                }

                // Draw a single black bar across the full width of the screen at the top
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, gameCanvas.width, SCORE_BOX_HEIGHT);

                // Calculate text positions for full-width layout
                const scoreFlowFontSize = Math.floor(SCORE_BOX_HEIGHT - (2 * SCORE_BOX_PADDING));
                ctx.font = `${scoreFlowFontSize}px VT323`;
                ctx.textBaseline = 'middle';
                const textY = SCORE_BOX_HEIGHT / 2;

                // Draw SCORE on the left
                ctx.fillStyle = '#e2e8f0';
                ctx.textAlign = 'left';
                ctx.fillText(`SCORE: ${score}`, 10, textY);

                // Calculate and draw the FLOW on the right
                const displayFlow = playerFlow.toFixed(2);
                ctx.textAlign = 'right';
                ctx.fillText(`FLOW: ${displayFlow}`, gameCanvas.width - 10, textY);

                // Draw the current world info in the center
                const world = getCurrentWorld();
                ctx.fillStyle = world.colors.stairs; // Use world's theme color
                ctx.textAlign = 'center';
                ctx.fillText(`WORLD ${currentWorld}: ${world.name.toUpperCase()}`, gameCanvas.width / 2, textY);

                // Draw the "HARD DIVISION" overlay if active
                if (gameStartedOverlayActive) {
                    const elapsed = now - gameStartedOverlayStartTime;
                    let opacity = 1;
                    let currentTitleFontSize;

                    // Phase 1: Zoom In
                    if (elapsed < OVERLAY_ZOOM_DURATION) {
                        const zoomProgress = elapsed / OVERLAY_ZOOM_DURATION;
                        const initialSize = Math.floor(gameCanvas.height * INITIAL_OVERLAY_FONT_FACTOR); // Use gameCanvas.height
                        const targetSize = Math.floor(gameCanvas.height * MAX_OVERLAY_FONT_FACTOR); // Use gameCanvas.height
                        currentTitleFontSize = initialSize + (targetSize - initialSize) * zoomProgress;
                        opacity = 1; // Full opacity during zoom
                    }
                    // Phase 2: Fade Out (starts after zoom)
                    else {
                        const fadeElapsed = elapsed - OVERLAY_ZOOM_DURATION;
                        const fadeProgress = Math.min(1, fadeElapsed / OVERLAY_FADE_DURATION);
                        opacity = 1 - fadeProgress;
                        currentTitleFontSize = Math.floor(gameCanvas.height * MAX_OVERLAY_FONT_FACTOR); // Hold max size during fade // Use gameCanvas.height
                    }

                    if (opacity <= 0) {
                        gameStartedOverlayActive = false; // Deactivate once fully faded
                    } else {
                        ctx.save();
                        ctx.globalAlpha = opacity;
                        ctx.fillStyle = '#FFD700'; // Gold color for the title
                        ctx.font = `${currentTitleFontSize}px VT323`; // Use dynamic font size
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Add shadow
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; // Black shadow, slightly transparent
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 5;
                        ctx.shadowOffsetY = 5;

                        ctx.fillText("HARD DIVISION", gameCanvas.width / 2, gameCanvas.height / 2 - gameCanvas.height * 0.05); // Use gameCanvas.width/height
                        ctx.restore();
                    }
                }

                // Removed the word bubble drawing logic from here as per user request.
                // Event messages will now only appear in the dialogue area on the left.

                // Draw the "PRESS R TO RESTART" message or its particles if game is over
                // This block now draws if gameOver OR if the restart animation is active
                if (gameOver || restartTextAnimationActive) {
                    if (restartTextAnimationActive) {
                        const elapsed = now - restartTextAnimationStartTime;
                        const progress = elapsed / RESTART_TEXT_EXPLOSION_DURATION;

                        if (progress >= 1) {
                            restartTextAnimationActive = false;
                            restartTextParticles = []; // Clear particles once animation is done
                        } else {
                            for (let i = restartTextParticles.length - 1; i >= 0; i--) {
                                const particle = restartTextParticles[i];
                                const particleProgress = (now - particle.startTime) / RESTART_TEXT_EXPLOSION_DURATION;

                                if (particleProgress >= 1) {
                                    continue;
                                }

                                const opacity = 1 - particleProgress;
                                const moveDistance = particle.initialSpeed * elapsed; // Use elapsed for continuous movement

                                const currentX = particle.startX + particle.dirX * moveDistance;
                                const currentY = particle.startY + particle.dirY * moveDistance;

                                ctx.save();
                                ctx.globalAlpha = opacity;
                                ctx.fillStyle = particle.color;
                                // Ensure font size consistency
                                ctx.font = `${Math.floor(dynamicTileSize * 0.8 * (1 - particleProgress * 0.5))}px VT323`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(particle.char, currentX, currentY);
                                ctx.restore();
                            }
                        }
                    } else if (gameOver) { // Only draw static text if game is over AND no animation is active
                        ctx.fillStyle = '#FFD700'; // Gold color for restart message
                        ctx.font = `${Math.floor(currentRenderTileSize * 0.8)}px VT323`; // Use currentRenderTileSize for scaling
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText("PRESS R TO RESTART", gameCanvas.width / 2, gameCanvas.height / 2 + currentRenderTileSize * 1.5); // Use gameCanvas.width/height
                    }
                }

            } catch (error) {
                console.error("Error in animation loop:", error);
                stopAnimationLoop(); // Stop the loop to prevent further errors
                handleGameOver(); // Attempt to gracefully end the game
            }
        }

        /**
         * Moves an entity (player or enemy) towards a target, considering obstacles.
         * @param {object} entity - The entity to move ({x, y}).
         * @param {number} targetX - The target X coordinate.
         * @param {number} targetY - The target Y coordinate.
         * @param {Array<object>} obstacles - An array of other entities (excluding the moving entity) to avoid.
         * @param {object|null} forbiddenTarget - An optional tile that the entity explicitly cannot move onto.
         * @returns {boolean} True if the entity moved, false otherwise.
         */
        function moveEntityTowardsTarget(entity, targetX, targetY, obstacles, forbiddenTarget = null) {
            // Validate entity position before attempting to move
            if (isNaN(entity.x) || isNaN(entity.y) || entity.x === null || entity.y === null) {
                console.error("Entity position is invalid. Cannot move.");
                return false;
            }

            const dxToTarget = targetX - entity.x;
            const dyToTarget = targetY - entity.y;

            let moveX = 0;
            let moveY = 0;

            // Prioritize movement along the axis with the greater distance
            if (Math.abs(dxToTarget) > Math.abs(dyToTarget)) {
                moveX = Math.sign(dxToTarget);
            } else {
                moveY = Math.sign(dyToTarget);
            }

            let newX = entity.x + moveX;
            let newY = entity.y + moveY;

            // Check if the primary move is valid
            if (newX < 0 || newX >= dynamicMapWidth || newY < 0 || newY >= dynamicMapHeight ||
                gameMap[newY][newX] === TILE_WALL ||
                obstacles.some(o => o.x === newX && o.y === newY) ||
                (forbiddenTarget && newX === forbiddenTarget.x && newY === forbiddenTarget.y)) {
                // If the primary move is blocked, try the other axis
                moveX = 0;
                moveY = 0;
                if (Math.abs(dxToTarget) > Math.abs(dyToTarget)) { // If X was primary, try Y
                    moveY = Math.sign(dyToTarget);
                } else { // If Y was primary, try X
                    moveX = Math.sign(dxToTarget);
                }
                newX = entity.x + moveX;
                newY = entity.y + moveY;
            }

            // Final check for the chosen move (either primary or secondary)
            if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                (gameMap[newY][newX] === TILE_FLOOR || gameMap[newY][newX] === TILE_STAIRS) &&
                !obstacles.some(o => o.x === newX && o.y === newY) &&
                !(forbiddenTarget && newX === forbiddenTarget.x && newY === forbiddenTarget.y)) {
                entity.x = newX;
                entity.y = newY;
                
                // Invalidate caches when entities move
                cacheValidationFrame++;
                invalidateSpatialIndex();
                
                // Increment steps taken for enemies if they are moving
                if (entity.totalDamageDealtByThisEnemy !== undefined && entity.stepsTakenByThisEnemy !== undefined) { // Check if it's an enemy
                    entity.stepsTakenByThisEnemy = entity.stepsTakenByThisEnemy + 1; // Explicit assignment
                }
                return true; // Movement successful
            }

            return false; // Movement failed
        }

        /**
         * Adds a damage text animation to the queue.
         * @param {number} x - X coordinate of the hit entity.
         * @param {number} y - Y coordinate of the hit entity.
         * @param {number} amount - Damage amount.
         * @param {string} color - Color of the damage text.
         * @param {number} dirX - X component of the direction vector for animation.
         * @param {number} dirY - Y component of the direction vector for animation.
         * @param {number} duration - Duration of the animation in milliseconds.
         * @param {number} delay - Delay before animation starts in milliseconds.
         */
        function addDamageAnimation(x, y, amount, color, dirX, dirY, duration = 1000, delay = 0) {
            activeDamageTextAnimations.push({
                x: x,
                y: y,
                amount: amount,
                color: VINTAGE_GREEN,
                dirX: dirX,
                dirY: dirY,
                startTime: performance.now(),
                duration: duration,
                delay: delay
            });
        }

        /**
         * Creates a single particle for an explosion animation.
         * @param {number} x - X coordinate of the particle's origin.
         * @param {number} y - Y coordinate of the particle's origin.
         * @param {string} color - Color of the particle.
         * @param {number} initialVelocityX - Initial horizontal velocity.
         * @param {number} initialVelocityY - Initial vertical velocity.
         * @param {number} duration - Duration of the particle's animation.
         * @param {number} fadeFactor - A factor to control how quickly the particle fades.
         * @returns {object} Particle object.
         */
        function createParticle(x, y, color, initialVelocityX, initialVelocityY, duration, fadeFactor) {
            return {
                x: x,
                y: y,
                color: color,
                initialVelocityX: initialVelocityX,
                initialVelocityY: initialVelocityY,
                startTime: performance.now(),
                duration: duration,
                fadeFactor: fadeFactor
            };
        }

        /**
         * Adds an explosion animation at a given tile.
         * @param {number} tileX - X coordinate of the tile.
         * @param {number} tileY - Y coordinate of the tile.
         * @param {string} color - Color of the particles.
         * @param {number} damageAmount - The damage that caused the explosion (for scaling).
         * @param {number} numParticles - Number of particles in the explosion.
         * @param {number} duration - Duration of the explosion animation in milliseconds.
         * @param {number} [spreadFactor=1] - Multiplier for particle spread.
         */
        function addExplosionAnimation(tileX, tileY, color, damageAmount, numParticles = 15, duration = 1500, spreadFactor = 1) {
            const scaledNumParticles = Math.max(5, Math.min(numParticles + (damageAmount * 1), 50)); // Cap at 50 for performance

            const explosion = {
                particles: [],
                startTime: performance.now(),
                duration: duration,
                damageAmount: damageAmount
            };

            for (let i = 0; i < scaledNumParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                // Scale speed by the provided spreadFactor
                const speed = (Math.random() * 1.0 + 0.1) * (dynamicTileSize / 150) * spreadFactor;
                const initialVelocityX = Math.cos(angle) * speed;
                const initialVelocityY = Math.sin(angle) * speed;
                const randomFadeFactor = Math.random() * 0.7 + 0.3;
                explosion.particles.push(createParticle(tileX, tileY, color, initialVelocityX, initialVelocityY, duration, randomFadeFactor));
            }
            activeExplosions.push(explosion);
        }

        /**
         * Handles game over state.
         */
        function handleGameOver() {
            console.log("Game Over triggered.");
            gameOver = true;
            stopAutomatedMovement();
            // Do not stop animation loop here, enemies need to move and explosion needs to play
            window.removeEventListener('keydown', handleKeyDown); // Temporarily remove player movement listener

            // Activate death animation effects
            deathAnimationActive = true;
            deathAnimationStartTime = performance.now();
            timeScale = DEATH_SLOW_MOTION_FACTOR; // Activate slow motion

            // Capture player's final color
            const playerHealthRatio = player.health / PLAYER_VISUAL_HEALTH_THRESHOLD;
            const finalPlayerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD);

            // Player death animation: Explode and scatter numbers/symbols
            addExplosionAnimation(player.x, player.y, finalPlayerColor, player.health, PLAYER_DEATH_PARTICLE_COUNT, PLAYER_DEATH_EXPLOSION_DURATION, PLAYER_DEATH_PARTICLE_SPREAD_FACTOR);

            // Scatter player's "numbers" (health/damage dealt) and symbols as pickups
            let remainingValueToScatter = player.health;
            const scatterCount = Math.min(player.health + MATH_SYMBOLS.length, 50); // More particles for drama
            for (let i = 0; i < scatterCount; i++) {
                const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR; // Wider spread
                const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;

                let partContent;
                if (remainingValueToScatter > 0 && Math.random() < 0.7) { // Bias towards numbers initially
                    const value = Math.min(PLAYER_DEATH_PICKUP_VALUE_PER_CHUNK, remainingValueToScatter);
                    partContent = { type: 'number', value: value };
                    remainingValueToScatter = remainingValueToScatter - value; // Explicit assignment
                } else {
                    const symbol = MATH_SYMBOLS[getRandomInt(0, MATH_SYMBOLS.length - 1)];
                    partContent = { type: 'symbol', value: symbol };
                }

                staticDamageNumbers.push({
                    x: player.x,
                    y: player.y,
                    parts: [{ content: partContent, offsetX: randomOffsetX, offsetY: randomOffsetY }], // Changed 'amount' to 'content'
                    isEnemyDrop: false,
                    isPlayerRemains: true,
                    playerDeathColor: finalPlayerColor, // Store the player's death color with the remains
                    writhingOffsetAngle: Math.random() * Math.PI * 2, // Initial angle for writhing
                    writhingOffsetRadius: (Math.random() * 0.5 + 0.5) * dynamicTileSize * 0.1, // Small radius, slightly varied
                    writhingSpeed: (Math.random() * 0.0005 + 0.0002) // Very slow speed for subtle writhing
                });
            }
            // Ensure any remaining value is scattered as a final number if any
            if (remainingValueToScatter > 0) {
                const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;
                const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;
                staticDamageNumbers.push({
                    x: player.x,
                    y: player.y,
                    parts: [{ content: { type: 'number', value: remainingValueToScatter }, offsetX: randomOffsetX, offsetY: randomOffsetY }],
                    isEnemyDrop: false,
                    isPlayerRemains: true,
                    playerDeathColor: finalPlayerColor,
                    writhingOffsetAngle: Math.random() * Math.PI * 2,
                    writhingOffsetRadius: (Math.random() * 0.5 + 0.5) * dynamicTileSize * 0.1,
                    writhingSpeed: (Math.random() * 0.0005 + 0.0002)
                });
            }

            // Calculate final score and add to leaderboard
            let finalScore = 0;
            if (stepsTaken > 0) {
                const scoreMultiplier = Math.max(1, currentLevel * 0.5);
                const flowBonus = Math.floor((totalDamageDealt / stepsTaken) * 100);
                const healthBonus = Math.floor(player.health * 5);
                const levelBonus = Math.floor((currentLevel - 1) * 200);
                finalScore = Math.floor((totalDamageDealt + flowBonus + healthBonus + levelBonus) * scoreMultiplier);
            }
            
            // Update total player score for world progression
            totalPlayerScore = Math.max(totalPlayerScore, finalScore);
            localStorage.setItem('hardDivisionTotalScore', totalPlayerScore.toString());
            checkAndUnlockWorlds();
            
            // Add score to leaderboard if it's high enough
            if (finalScore > 0 && (leaderboard.length < 10 || finalScore > leaderboard[leaderboard.length - 1].score)) {
                addToLeaderboard(finalScore);
            }

            // Start enemy swarm behavior (animation loop is already running)
            startEnemySwarm();

            // Re-add event listener for restart only
            window.addEventListener('keydown', handleRestartKeyDown);
        }

        /**
         * Handles the 'R' key press for restarting the game.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleRestartKeyDown(event) {
            if (gameOver && (event.key === 'r' || event.key === 'R')) {
                event.preventDefault();

                // Get the position and size of the "PRESS R TO RESTART" text
                const restartText = "PRESS R TO RESTART";
                // Use dynamicTileSize for font sizing to match the game's current scale
                const baseFontSize = Math.floor(dynamicTileSize * 0.8);
                ctx.font = `${baseFontSize}px VT323`;
                const textMetrics = ctx.measureText(restartText);
                const textWidth = textMetrics.width;
                const textHeight = baseFontSize; // Approximate height based on font size

                const textX = gameCanvas.width / 2;
                const textY = gameCanvas.height / 2 + dynamicTileSize * 1.5;

                // Generate particles for each character
                restartTextParticles = [];
                let currentTextX = textX - textWidth / 2; // Start X for the first character
                const charSpacing = textWidth / restartText.length; // Simple even spacing

                for (let i = 0; i < restartText.length; i++) {
                    const char = restartText[i];
                    const charX = currentTextX + charSpacing * i + charSpacing / 2; // Center of the character
                    const charY = textY;

                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 0.5 + 0.2) * (dynamicTileSize / 20); // Slower, more controlled spread
                    const dirX = Math.cos(angle);
                    const dirY = Math.sin(angle);
                    const fadeFactor = Math.random() * 0.7 + 0.3;

                    restartTextParticles.push({
                        char: char,
                        startX: charX,
                        startY: charY,
                        dirX: dirX,
                        dirY: dirY,
                        initialSpeed: speed,
                        fontSize: baseFontSize, // Use the calculated baseFontSize for consistency
                        color: '#FFD700', // Gold color for the text particles
                        startTime: performance.now(),
                        duration: RESTART_TEXT_EXPLOSION_DURATION,
                        fadeFactor: fadeFactor
                    });
                }

                restartTextAnimationActive = true;
                restartTextAnimationStartTime = performance.now();

                // Immediately start the game restart (which includes the zoom-out)
                restartGame();
            }
        }

        /**
         * Restarts the game.
         */
        function restartGame() {
            window.removeEventListener('keydown', handleRestartKeyDown); // Remove restart listener
            initGame(true, false); // Start a brand new game, no overlay on restart
            // The animation loop is already running, no need to restart it here.
        }

        /**
         * Initiates enemy swarm behavior after player death.
         */
        function startEnemySwarm() {
            // This function ensures enemies continuously move towards player remains.
            // The actual movement logic is within enemyTurn().
            console.log("Enemies starting swarm behavior.");
        }

        /**
         * Checks the player's current tile for any static health pickups and collects them.
         */
        function checkAndCollectPickups() {
            for (let i = staticDamageNumbers.length - 1; i >= 0; i--) {
                const staticNum = staticDamageNumbers[i];
                // Only collect non-player-remains pickups
                if (!staticNum.isPlayerRemains && getDistance(player, staticNum) <= DIRECT_PICKUP_RADIUS) {
                    let healthGained = 0;
                    staticNum.parts.forEach(part => {
                        healthGained = healthGained + part.content.value; // Explicit assignment
                        activePickupAnimations.push({
                            startX: staticNum.x,
                            startY: staticNum.y,
                            initialOffsetX: part.offsetX || 0,
                            initialOffsetY: part.offsetY || 0,
                            amount: part.content.value, // Pass value from content
                            color: VINTAGE_GREEN,
                            startTime: performance.now(),
                            duration: 300
                        });
                    });
                    player.health = player.health + healthGained; // Explicit assignment
                    totalPickupValueCollectedThisTurn = totalPickupValueCollectedThisTurn + healthGained; // Explicit assignment
                    player.healthAnimScale = 1.5;
                    player.healthAnimStartTime = performance.now();
                    
                    // Add pickup message
                    if (healthGained >= 10) {
                        addPickupMessage(`${player.name} collected major health pickup (+${healthGained})`, 'high');
                    } else if (healthGained >= 5) {
                        addPickupMessage(`${player.name} collected health (+${healthGained})`, 'medium');
                    } else {
                        addPickupMessage(`${player.name} collected health (+${healthGained})`, 'low');
                    }
                    
                    staticDamageNumbers.splice(i, 1);
                }
            }
        }

        /**
         * Applies health loss to the player based on steps taken.
         * Interval and damage are both inversely proportional to current health.
         */
        function applyStepBasedHealthLoss() {
            // Calculate dynamic interval based on health
            const MIN_INTERVAL = 10;  // Minimum steps between health loss (when health is high)
            const MAX_INTERVAL = 37;  // Maximum steps between health loss (when health is low)
            
            let dynamicInterval;
            if (player.health <= 1) {
                dynamicInterval = MAX_INTERVAL; // Lowest health = longest interval
            } else {
                // Use inverse proportion: interval = MAX_INTERVAL / (health)
                // Clamp to minimum interval to prevent too-frequent health loss at high health
                dynamicInterval = Math.max(MIN_INTERVAL, Math.floor(MAX_INTERVAL / player.health));
            }

            if (stepsTaken > 0 && stepsTaken % dynamicInterval === 0) {
                // Always lose 10% of current health (rounded)
                let damage = Math.round(player.health * 0.1);
                if (damage < 1 && player.health > 0) {
                    damage = 1;
                } else if (player.health === 0) {
                    damage = 0;
                }

                if (damage > 0) {
                    player.health = player.health - damage;
                    hitsTaken = hitsTaken + 1;
                    hitsTakenThisTurn = hitsTakenThisTurn + 1;
                    playerTookDamageInCombatThisTurn = true;
                    const animDuration = Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damage - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE));
                    addDamageAnimation(player.x, player.y, damage, VINTAGE_GREEN, 0, -1, animDuration, 0);
                }

                // Sanity check for player health after health loss
                if (isNaN(player.health)) {
                    console.error("Player health became NaN after step-based health loss! Forcing game over.");
                    player.health = 0;
                }

                if (player.health <= 0) {
                    player.health = 0; // Ensure health doesn't go negative for display
                    handleGameOver();
                }
            }
        }

        /**
         * Moves the player if the target tile is a floor or stairs.
         * Handles combat if the target tile is occupied by an enemy.
         * @param {number} dx - Change in X coordinate.
         * @param {number} dy - Change in Y coordinate.
         * @returns {boolean} True if combat occurred, false otherwise.
         */
        function movePlayer(dx, dy) {
            if (gameOver) return false;

            // Validate player position before attempting to move
            if (isNaN(player.x) || isNaN(player.y) || player.x === null || player.y === null) {
                console.error("Player position is invalid. Cannot move.");
                return false;
            }

            const newX = player.x + dx;
            const newY = player.y + dy;

            if (newX < 0 || newX >= dynamicMapWidth || newY < 0 || newY >= dynamicMapHeight) {
                return false;
            }

            const collidedEnemyIndex = enemies.findIndex(e => e.x === newX && e.y === newY);

            if (collidedEnemyIndex !== -1) {
                const attackedEnemy = enemies[collidedEnemyIndex];
                const enemyHealthBeforeHit = attackedEnemy.health; // Store health before hit
                const enemyInitialHealth = attackedEnemy.initialHealth; // Store initial health of this enemy

                let playerAttacksFirst = Math.random() < 0.5;
                combatOccurredThisTurn = true; // Mark that combat occurred this turn

                // Track damage for activity log
                let totalDamageDealtToEnemy = 0;
                let totalDamageDealtToPlayer = 0;
                let damageDealtToEnemy = 0; // Initialize to prevent undefined errors

                if (playerAttacksFirst) {
                    // Player wins initiative and attacks
                    player.thrustAnimActive = true;
                    player.thrustAnimStartTime = performance.now();
                    player.thrustAnimDirectionX = dx;
                    player.thrustAnimDirectionY = dy;
                    const playerCurrentFlow = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0;
                    
                    // New hybrid damage system: base damage from level + small health bonus
                    const levelDamage = Math.max(1, Math.floor(currentLevel / 3)) + 1; // 2-4 at level 1, 4-6 at level 9
                    const healthBonus = Math.floor(player.health / 20); // +1 damage per 20 health
                    const minDamage = levelDamage;
                    const maxDamage = levelDamage + 2 + healthBonus;
                    
                    damageDealtToEnemy = getWeightedRandomInt(minDamage, maxDamage, player.health, attackedEnemy.health, playerCurrentFlow);
                    console.log('Combat: Player attacks enemy -', 'Player health:', player.health, 'Enemy health:', attackedEnemy.health, 'Damage dealt:', damageDealtToEnemy);
                    
                    // Critical Strike chance (10% chance)
                    if (Math.random() < 0.1) {
                        damageDealtToEnemy = Math.floor(damageDealtToEnemy * CRITICAL_STRIKE_DAMAGE_MULTIPLIER);
                        const isMajor = damageDealtToEnemy >= CRITICAL_STRIKE_MAJOR_DAMAGE;
                        const logMessage = `${player.name} dealt ${damageDealtToEnemy} critical damage to ${attackedEnemy.name}`;
                        
                        addEventMessage("Critical Strike!", isMajor, logMessage);
                        eventFlags.criticalStrike = true;
                    } else {
                        eventFlags.criticalStrike = false;
                    }

                    damageDealtToEnemy = Math.min(damageDealtToEnemy, attackedEnemy.health);
                    totalDamageDealtToEnemy = damageDealtToEnemy; // Track for activity log
                    player.thrustAnimMagnitude = Math.min(1, damageDealtToEnemy / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);

                    attackedEnemy.health = attackedEnemy.health - damageDealtToEnemy;
                    attackedEnemy.totalDamageTakenByThisEnemy = (attackedEnemy.totalDamageTakenByThisEnemy || 0) + damageDealtToEnemy;
                    
                    hitsDealt = hitsDealt + 1;
                    totalDamageDealt = totalDamageDealt + damageDealtToEnemy;
                    damageDealtThisTurn = damageDealtThisTurn + damageDealtToEnemy;
                    addDamageAnimation(attackedEnemy.x, attackedEnemy.y, damageDealtToEnemy, VINTAGE_GREEN, dx, dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToEnemy - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));
                } else {
                    // Enemy wins initiative and attacks
                    attackedEnemy.thrustAnimActive = true;
                    attackedEnemy.thrustAnimStartTime = performance.now();
                    attackedEnemy.thrustAnimDirectionX = -dx;
                    attackedEnemy.thrustAnimDirectionY = -dy;
                    
                    const enemyCurrentFlow = attackedEnemy.totalDamageTakenByThisEnemy > 0
                        ? attackedEnemy.totalDamageTakenByThisEnemy / (attackedEnemy.stepsTakenByThisEnemy || 1)
                        : attackedEnemy.flowLevel;
                    
                    // Enemy damage uses similar system but based on enemy health
                    const enemyLevelDamage = Math.max(1, Math.floor(currentLevel / 3)) + 1;
                    const enemyHealthBonus = Math.floor(attackedEnemy.health / 20);
                    const enemyMinDamage = enemyLevelDamage;
                    const enemyMaxDamage = enemyLevelDamage + 2 + enemyHealthBonus;
                    
                    let damageDealtToPlayer = getWeightedRandomInt(enemyMinDamage, enemyMaxDamage, attackedEnemy.health, player.health, enemyCurrentFlow);
                    damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                    totalDamageDealtToPlayer = damageDealtToPlayer; // Track for activity log
                    attackedEnemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                    attackedEnemy.totalDamageDealtByThisEnemy = attackedEnemy.totalDamageDealtByThisEnemy + damageDealtToPlayer;

                    player.health = player.health - damageDealtToPlayer;
                    hitsTaken = hitsTaken + 1;
                    hitsTakenThisTurn = hitsTakenThisTurn + 1;
                    if (damageDealtToPlayer > 0) {
                        playerTookDamageInCombatThisTurn = true;
                    }
                    addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, -dx, -dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));
                }

                if (attackedEnemy.health <= 0) {
                    console.log('Enemy died:', attackedEnemy.name, 'Health:', attackedEnemy.health, 'Damage dealt:', damageDealtToEnemy);
                    // Calculate spread factor for explosion based on damage dealt
                    const explosionSpread = ENEMY_DEATH_EXPLOSION_BASE_SPREAD + (damageDealtToEnemy * ENEMY_DEATH_EXPLOSION_DAMAGE_SPREAD_MULTIPLIER);
                    addExplosionAnimation(attackedEnemy.x, attackedEnemy.y, FIXED_COLOR_ENEMY, enemyHealthBeforeHit, undefined, undefined, explosionSpread); // Pass explosionSpread

                    // MODIFIED: "One-Shot Kill" detection - only if enemy went from initial health to 0
                    if (attackedEnemy.initialHealth === enemyHealthBeforeHit && attackedEnemy.health <= 0) {
                        const isMajor = enemyHealthBeforeHit >= ONE_SHOT_MAJOR_HEALTH;
                        const logMessage = `${player.name} eliminated ${attackedEnemy.name} (HP: ${enemyHealthBeforeHit}) in a single devastating strike`;
                        
                        addEventMessage("One-Shot Kill!", isMajor, logMessage);
                        eventFlags.oneShotKill = true;
                    } else {
                        eventFlags.oneShotKill = false;
                    }

                    // Calculate pickup scatter magnitude based on damage dealt
                    const pickupScatterMagnitude = PICKUP_SCATTER_BASE_SPREAD + (damageDealtToEnemy * PICKUP_SCATTER_DAMAGE_MULTIPLIER);

                    // Enemy drops exactly the amount of health it had before the final hit
                    let remainingDroppedHealth = enemyHealthBeforeHit;

                    // Denominations for splitting
                    const denominations = [10, 5, 1]; // Prioritize larger denominations

                    while (remainingDroppedHealth > 0) {
                        const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * pickupScatterMagnitude;
                        const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * pickupScatterMagnitude;

                        let valueToDrop = 0;
                        for (const denom of denominations) {
                            if (remainingDroppedHealth >= denom) {
                                valueToDrop = denom;
                                break;
                            }
                        }
                        if (valueToDrop === 0 && remainingDroppedHealth > 0) {
                            valueToDrop = remainingDroppedHealth; // Drop remaining as a 1 if it's less than smallest denom
                        }

                        if (valueToDrop > 0) {
                            staticDamageNumbers.push({
                                x: attackedEnemy.x,
                                y: attackedEnemy.y,
                                parts: [{ content: { type: 'number', value: valueToDrop }, offsetX: randomOffsetX, offsetY: randomOffsetY }],
                                isEnemyDrop: true
                            });
                            remainingDroppedHealth -= valueToDrop;
                        } else {
                            break; // Should not happen if remainingDroppedHealth > 0
                        }
                    }

                    // Add activity log entry for the kill
                    addActivityLogEntry(player, attackedEnemy, totalDamageDealtToEnemy, totalDamageDealtToPlayer);
                    
                    // Track killed enemy for events
                    killedEnemiesThisTurn.push(attackedEnemy.name);
                    
                    enemies.splice(collidedEnemyIndex, 1);
                    enemiesKilledThisTurn = enemiesKilledThisTurn + 1; // Explicit assignment
                }

                // Sanity check for player health after combat
                if (isNaN(player.health)) {
                    console.error("Player health became NaN during combat! Forcing game over.");
                    player.health = 0; // Set to 0 to trigger game over
                }

                if (player.health <= 0) {
                    player.health = 0; // Ensure health doesn't go negative for display
                    handleGameOver();
                }
                // Always return true if combat occurred, regardless of outcome
                return true;
            }

            const obstaclesForPlayer = enemies;
            const playerMoved = moveEntityTowardsTarget(player, newX, newY, obstaclesForPlayer);

            if (playerMoved) {
                stepsTaken = stepsTaken + 1; // Explicit assignment
                // Mark current tile as visited for "Map Explorer"
                if (visitedTiles[player.y] && visitedTiles[player.y][player.x] !== undefined) {
                    visitedTiles[player.y][player.x] = true;
                }
                applyStepBasedHealthLoss();
                checkAndCollectPickups(); // Check for and collect pickups after moving

                if (player.x === stairs.x && player.y === stairs.y) {
                    nextLevel();
                }
                // Enemy turn is now called after player moves, regardless of combat
                enemyTurn();
                return false;
            }
            return false;
        }

        /**
         * Handles enemy turns. Each enemy moves based on its assigned role.
         */
        function enemyTurn() {
            // If game is over, enemies only swarm player remains
            if (gameOver) {
                enemies.forEach(enemy => {
                    const obstaclesForThisEnemy = enemies.filter(e => e !== enemy); // Enemies don't block each other if player is dead

                    // Find the closest player remains pickup
                    const closestPlayerRemains = getClosestEntity(staticDamageNumbers.filter(s => s.isPlayerRemains), enemy);

                    if (closestPlayerRemains) {
                        // Move towards the closest player remains
                        const moved = moveEntityTowardsTarget(enemy, closestPlayerRemains.x, closestPlayerRemains.y, obstaclesForThisEnemy, null);

                        // If enemy reached the remains, "eat" them
                        if (moved && enemy.x === closestPlayerRemains.x && enemy.y === closestPlayerRemains.y) {
                            const index = staticDamageNumbers.indexOf(closestPlayerRemains);
                            if (index > -1) {
                                staticDamageNumbers.splice(index, 1);
                                console.log(`Enemy ate player remains at (${closestPlayerRemains.x}, ${closestPlayerRemains.y})`);
                                // Increase enemy health by the amount of the eaten remains, only if it's a number
                                if (closestPlayerRemains.parts[0].content.type === 'number') {
                                    enemy.health = enemy.health + closestPlayerRemains.parts[0].content.value; // Explicit assignment
                                }
                            }
                        }
                    } else {
                        // If no more player remains, enemies can just wander or stay put
                        // For now, they'll just stand still if no remains are left.
                        // Could implement a random wander here if desired.
                    }
                });
                checkNotableEvents(); // Check events even if game over, for enemy swarm behavior
                // Reset per-turn stats after checkNotableEvents
                enemiesKilledThisTurn = 0;
                killedEnemiesThisTurn = []; // Reset killed enemies tracking
                damageDealtThisTurn = 0;
                hitsTakenThisTurn = 0;
                totalPickupValueCollectedThisTurn = 0;
                combatOccurredThisTurn = false; // Reset for next turn
                playerTookDamageInCombatThisTurn = false; // Reset for next turn
                return; // Skip normal enemy turn logic if game over
            }

            const HUNTER_MOVE_CHANCE = 0.8;
            const GUARD_PATROL_RADIUS = 5;
            const GUARD_MOVE_CHANCE = 0.5;
            const TRACKER_AGGRO_RADIUS = 8;
            const GLOBAL_STOP_CHANCE = 0.2; // 20% chance for any enemy to stop

            enemies.forEach(enemy => {
                // Apply global random stop chance before any movement logic
                if (Math.random() < GLOBAL_STOP_CHANCE) {
                    // Enemy decided to stop this turn
                    return;
                }

                let enemyAttackedThisTurn = false; // Flag for this enemy's turn

                // Check for unprovoked attack if player is adjacent
                const isPlayerAdjacent = getDistance(enemy, player) <= 1.5; // Manhattan distance of 1 or diagonal
                if (isPlayerAdjacent) {
                    // Use enemy.totalDamageTakenByThisEnemy for enemy flow.
                    // If no damage taken yet, use enemy.flowLevel for initial flow.
                    const enemyCurrentFlow = enemy.totalDamageTakenByThisEnemy > 0
                        ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1)
                        : enemy.flowLevel;
                    const attackChance = Math.min(1.0, Math.max(0.0, enemyCurrentFlow)); // Clamp flow to 0-1 for probability

                    if (Math.random() < attackChance) {
                        // Enemy attacks unprovoked
                        enemy.thrustAnimActive = true;
                        enemy.thrustAnimStartTime = performance.now();
                        let dx = player.x - enemy.x; // Change to let
                        let dy = player.y - enemy.y; // Change to let
                        // Ensure attacks are cardinal only
                        if (Math.abs(dx) > 0 && Math.abs(dy) > 0) { // If diagonal, pick one axis
                            if (Math.random() < 0.5) dy = 0;
                            else dx = 0;
                        }

                        enemy.thrustAnimDirectionX = dx;
                        enemy.thrustAnimDirectionY = dy;

                        let damageDealtToPlayer = getWeightedRandomInt(1, enemy.health, enemy.health, player.health, enemyCurrentFlow);
                        damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                        enemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                        enemy.totalDamageDealtByThisEnemy = enemy.totalDamageDealtByThisEnemy + damageDealtToPlayer; // Explicit assignment

                        player.health = player.health - damageDealtToPlayer; // Explicit assignment
                        hitsTaken = hitsTaken + 1; // Explicit assignment
                        hitsTakenThisTurn = hitsTakenThisTurn + 1; // Explicit assignment
                        if (damageDealtToPlayer > 0) {
                            playerTookDamageInCombatThisTurn = true; // Player took damage in combat
                        }
                        addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, dx, dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));

                        // Sanity check for player health after combat
                        if (isNaN(player.health)) {
                            console.error("Player health became NaN during enemy unprovoked attack! Forcing game over.");
                            player.health = 0;
                        }
                        if (player.health <= 0) {
                            player.health = 0;
                            handleGameOver();
                            return; // Stop further enemy turns if game over
                        }
                        enemyAttackedThisTurn = true;
                    }
                }

                if (!enemyAttackedThisTurn) { // Only move if no unprovoked attack occurred
                    const obstaclesForThisEnemy = enemies.filter(e => e !== enemy).concat(player);
                    let moved = false; // Flag to track if enemy successfully moved

                    // New: Check enemy's flowLevel for following chance
                    // MODIFIED: Enemy flow is now based on totalDamageTakenByThisEnemy
                    if (Math.random() < (enemy.totalDamageTakenByThisEnemy > 0 ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1) : 0)) { // If random number is less than flowLevel, enemy follows
                        moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                    } else { // Otherwise, enemy performs its role-based movement
                        if (enemy.role === 'hunter') {
                            // Hunters always try to move towards the player if not following by flow
                            moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                        } else if (enemy.role === 'guard') {
                            if (stairs && stairs.x !== undefined && stairs.y !== undefined) {
                                const distToStairs = getDistance(enemy, stairs);

                                if (distToStairs > GUARD_PATROL_RADIUS) {
                                    moved = moveEntityTowardsTarget(enemy, stairs.x, stairs.y, obstaclesForThisEnemy, stairs);
                                } else {
                                    if (Math.random() < GUARD_MOVE_CHANCE) { // Guard-specific stop chance
                                        // Only cardinal directions for guard's random movement
                                        const cardinalDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                                        let bestMove = null;
                                        let minCombinedDistance = Infinity;

                                        for (const [dx, dy] of cardinalDirections) { // Iterate over cardinal directions
                                            const newX = enemy.x + dx;
                                            const newY = enemy.y + dy;

                                            if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                                                gameMap[newY][newX] === TILE_FLOOR && // Only move onto floor tiles
                                                !(newX === player.x && newY === player.y) &&
                                                !obstaclesForThisEnemy.some(o => o.x === newX && o.y === newY) &&
                                                (stairs && stairs.x !== undefined && stairs.y !== undefined && (newX !== stairs.x || newY !== stairs.y)) && // Explicitly avoid stairs
                                                (stairs && stairs.x !== undefined && stairs.y !== undefined && getDistance({x: newX, y: newY}, stairs) <= GUARD_PATROL_RADIUS + 1)) {

                                                const distToPlayer = getDistance({x: newX, y: newY}, player);
                                                const distToStairsFromNewPos = getDistance({x: newX, y: newY}, stairs);

                                                const combinedDistance = distToPlayer + distToStairsFromNewPos;

                                                if (combinedDistance < minCombinedDistance) {
                                                    minCombinedDistance = combinedDistance;
                                                    bestMove = {x: newX, y: newY};
                                                }
                                            }
                                        }

                                        if (bestMove) {
                                            enemy.x = bestMove.x;
                                            enemy.y = bestMove.y;
                                            moved = true; // Mark as moved
                                        }
                                    }
                                }
                            } else {
                                moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                            }
                        } else if (enemy.role === 'tracker') {
                            const distToPlayer = getDistance(enemy, player);
                            if (distToPlayer <= TRACKER_AGGRO_RADIUS) {
                                moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                            } else {
                                if (stairs && stairs.x !== undefined && stairs.y !== undefined) {
                                    moved = moveEntityTowardsTarget(enemy, stairs.x, stairs.y, obstaclesForThisEnemy, stairs);
                                } else {
                                    moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                                }
                            }
                        }
                    }
                }
            });

            checkNotableEvents(); // Check events after all entities have moved
            // Reset per-turn stats
            enemiesKilledThisTurn = 0;
            killedEnemiesThisTurn = []; // Reset killed enemies tracking
            damageDealtThisTurn = 0;
            hitsTakenThisTurn = 0;
            combatOccurredThisTurn = false; // Reset for next turn
            playerTookDamageInCombatThisTurn = false; // Reset for next turn
            totalPickupValueCollectedThisTurn = 0;
        }

        /**
         * Adds an event message to be displayed on screen.
         * @param {string} text - The text of the event message.
         * @param {boolean} isMajor - Whether this is a major event that should be logged.
         * @param {string} logMessage - Detailed message for the activity log (if major).
         */
        function addEventMessage(text, isMajor = false, logMessage = null) {
            // Only add if not already active or recently shown (simple check for now)
            // Could add more sophisticated cooldowns per event type if needed
            if (!activeEventMessages.some(msg => msg.text === text)) {
                activeEventMessages.push({
                    text: text,
                    startTime: performance.now(),
                    duration: EVENT_TEXT_DURATION
                });
                
                // Add major events to the message area like kill messages
                if (isMajor && logMessage) {
                    addMajorEventMessage(logMessage);
                } else {
                    // Regular events still appear briefly as event titles
                    addPlayerDialogue(text);
                }
            }
        }

        /**
         * Adds a major event message to the message area with warning styling.
         * @param {string} message - The detailed message to display.
         */
        function addMajorEventMessage(message) {
            addCategorizedMessage(message, 'EVENT', 'critical');
        }

        /**
         * Updates the opacity of all messages to create a gradient effect.
         * Newer messages (at the top) are more opaque, older ones fade out.
         */
        function updateMessageOpacity() {
            const messages = Array.from(messageArea.children).filter(child => 
                child.classList.contains('kill-message')
            );
            
            for (let i = 0; i < messages.length; i++) {
                const opacity = Math.max(0.1, 1 - (i * 0.15)); // Each message is 15% more transparent
                messages[i].style.opacity = opacity;
            }
        }

        /**
         * Toggles a message filter and updates the UI
         * @param {string} type - The message type to toggle
         */
        function toggleMessageFilter(type) {
            MESSAGE_TYPES[type].enabled = !MESSAGE_TYPES[type].enabled;
            saveMessagePreferences();
            updateFilterUI();
            filterMessages();
        }

        /**
         * Updates the filter button UI to reflect current state
         */
        function updateFilterUI() {
            Object.keys(MESSAGE_TYPES).forEach(type => {
                const btn = document.getElementById(`filter${type.charAt(0) + type.slice(1).toLowerCase()}`);
                if (btn) {
                    if (MESSAGE_TYPES[type].enabled) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });
        }

        /**
         * Filters visible messages based on current filter settings
         */
        function filterMessages() {
            const messages = Array.from(messageArea.children).filter(child => 
                child.classList.contains('kill-message')
            );
            
            messages.forEach(message => {
                const messageType = message.dataset.messageType;
                if (messageType && MESSAGE_TYPES[messageType]) {
                    message.style.display = MESSAGE_TYPES[messageType].enabled ? 'flex' : 'none';
                }
            });
            
            updateMessageOpacity(); // Recalculate opacity after filtering
        }

        /**
         * Initializes the message filter system
         */
        function initializeMessageFilters() {
            loadMessagePreferences();
            
            // Set up filter button event listeners
            Object.keys(MESSAGE_TYPES).forEach(type => {
                const btnId = `filter${type.charAt(0) + type.slice(1).toLowerCase()}`;
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.addEventListener('click', () => toggleMessageFilter(type));
                }
            });
            
            updateFilterUI();
        }

        /**
         * Helper functions for specific message types
         */
        function addCombatMessage(message, priority = 'normal') {
            addCategorizedMessage(message, 'COMBAT', priority);
        }

        function addEventMessage(message, priority = 'high') {
            addCategorizedMessage(message, 'EVENT', priority);
        }

        function addPickupMessage(message, priority = 'normal') {
            addCategorizedMessage(message, 'PICKUP', priority);
        }

        function addProgressMessage(message, priority = 'high') {
            addCategorizedMessage(message, 'PROGRESS', priority);
        }

        /**
         * Adds a new line of player dialogue to the dialogue area.
         * Function removed temporarily
         */
        function addPlayerDialogue(statusText) {
            // Dialogue system temporarily removed
            return;
        }

        /**
         * Counts the number of visited tiles in the `visitedTiles` grid.
         * @returns {number} The count of visited tiles.
         */
        function countVisitedTiles() {
            let count = 0;
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (visitedTiles[y] && visitedTiles[y][x]) {
                        count++;
                    }
                }
            }
            return count;
        }

        /**
         * Checks for notable game events based on current state and history.
         */
        function checkNotableEvents() {
            // 1. Store current state in history
            gameHistory.push({
                stepsTaken: stepsTaken,
                playerHealth: player.health,
                enemiesCount: enemies.length,
                hitsTaken: hitsTaken,
                totalDamageDealt: totalDamageDealt,
                playerX: player.x,
                playerY: player.y,
                enemiesPositions: enemies.map(e => ({ x: e.x, y: e.y, health: e.health, name: e.name })),
                pickupsOnMap: staticDamageNumbers.filter(s => !s.isPlayerRemains).map(p => ({ x: p.x, y: p.y, value: p.parts[0].content.value })),
                enemiesKilledThisTurn: enemiesKilledThisTurn,
                killedEnemyNames: [...killedEnemiesThisTurn],
                damageDealtThisTurn: damageDealtThisTurn,
                hitsTakenThisTurn: hitsTakenThisTurn,
                totalPickupValueCollectedThisTurn: totalPickupValueCollectedThisTurn,
                visitedTilesCount: countVisitedTiles(),
                combatOccurredThisTurn: combatOccurredThisTurn,
                playerTookDamageInCombatThisTurn: playerTookDamageInCombatThisTurn,
                currentLevel: currentLevel,
                playerFlow: stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0
            });

            if (gameHistory.length > HISTORY_LENGTH) {
                gameHistory.shift();
            }

            const currentTurn = gameHistory[gameHistory.length - 1];
            const previousTurn = gameHistory.length > 1 ? gameHistory[gameHistory.length - 2] : null;

            // === COMBAT EVENTS - OFFENSIVE ===
            
            // Massacre Event
            let enemiesKilledRecently = 0;
            for (let i = Math.max(0, gameHistory.length - 5); i < gameHistory.length; i++) {
                enemiesKilledRecently += gameHistory[i].enemiesKilledThisTurn || 0;
            }
            if (enemiesKilledRecently >= MASSACRE_COUNT && !eventFlags.massacre) {
                const isMajor = true;
                const logMessage = `${player.name} has achieved a MASSACRE, eliminating ${enemiesKilledRecently} enemies in rapid succession!`;
                addEventMessage("Massacre", isMajor, logMessage);
                eventFlags.massacre = true;
            } else if (enemiesKilledRecently < MASSACRE_COUNT) {
                eventFlags.massacre = false;
            }

            // Berserker Mode
            let recentDamage = 0;
            for (let i = Math.max(0, gameHistory.length - BERSERKER_TURNS); i < gameHistory.length; i++) {
                recentDamage += gameHistory[i].damageDealtThisTurn || 0;
            }
            if (recentDamage >= BERSERKER_DAMAGE_THRESHOLD && !eventFlags.berserkerMode) {
                const isMajor = recentDamage >= BERSERKER_DAMAGE_THRESHOLD * 1.5;
                const logMessage = `${player.name} enters BERSERKER MODE, dealing ${recentDamage} damage in ${BERSERKER_TURNS} turns!`;
                addEventMessage("Berserker Mode", isMajor, logMessage);
                eventFlags.berserkerMode = true;
            } else if (recentDamage < BERSERKER_DAMAGE_THRESHOLD) {
                eventFlags.berserkerMode = false;
            }

            // Glass Cannon
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.3 && 
                damageDealtThisTurn >= player.health * GLASS_CANNON_DAMAGE_RATIO && 
                !eventFlags.glassCannon) {
                const isMajor = damageDealtThisTurn >= player.health * GLASS_CANNON_DAMAGE_RATIO * 1.5;
                const logMessage = `${player.name} demonstrates GLASS CANNON tactics, dealing ${damageDealtThisTurn} damage while having only ${player.health} health!`;
                addEventMessage("Glass Cannon", isMajor, logMessage);
                eventFlags.glassCannon = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * 0.3 || damageDealtThisTurn < player.health * GLASS_CANNON_DAMAGE_RATIO) {
                eventFlags.glassCannon = false;
            }

            // Headhunter
            const highValueEnemiesKilled = killedEnemiesThisTurn.filter(name => {
                const enemy = gameHistory.length > 1 ? 
                    gameHistory[gameHistory.length - 2].enemiesPositions.find(e => e.name === name) : null;
                return enemy && enemy.health >= HEADHUNTER_HIGH_VALUE_ENEMY;
            });
            if (highValueEnemiesKilled.length > 0 && !eventFlags.headhunter) {
                const isMajor = highValueEnemiesKilled.length > 1;
                const targets = highValueEnemiesKilled.join(', ');
                const logMessage = `${player.name} is a HEADHUNTER, taking down high-value targets: ${targets}`;
                addEventMessage("Headhunter", isMajor, logMessage);
                eventFlags.headhunter = true;
            } else if (highValueEnemiesKilled.length === 0) {
                eventFlags.headhunter = false;
            }

            // === COMBAT EVENTS - DEFENSIVE ===

            // Last Stand
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * LAST_STAND_HEALTH_RATIO && 
                enemies.length >= 2 && damageDealtThisTurn > 0 && !eventFlags.lastStand) {
                const isMajor = enemies.length >= 3;
                const logMessage = `${player.name} makes a LAST STAND with ${player.health} health against ${enemies.length} enemies!`;
                addEventMessage("Last Stand", isMajor, logMessage);
                eventFlags.lastStand = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * LAST_STAND_HEALTH_RATIO) {
                eventFlags.lastStand = false;
            }

            // Narrow Escape
            if (previousTurn && previousTurn.playerHealth <= PLAYER_VISUAL_HEALTH_THRESHOLD * NARROW_ESCAPE_HEALTH_RATIO && 
                player.health > previousTurn.playerHealth && !eventFlags.narrowEscape) {
                const isMajor = previousTurn.playerHealth <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.03;
                const logMessage = `${player.name} had a NARROW ESCAPE, surviving with only ${previousTurn.playerHealth} health!`;
                addEventMessage("Narrow Escape", isMajor, logMessage);
                eventFlags.narrowEscape = true;
            } else if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * NARROW_ESCAPE_HEALTH_RATIO) {
                eventFlags.narrowEscape = false;
            }

            // Damage Sponge
            let recentDamageAbsorbed = 0;
            for (let i = Math.max(0, gameHistory.length - 5); i < gameHistory.length; i++) {
                recentDamageAbsorbed += gameHistory[i].hitsTakenThisTurn || 0;
            }
            if (recentDamageAbsorbed >= DAMAGE_SPONGE_THRESHOLD && player.health > 0 && !eventFlags.damageSponge) {
                const isMajor = recentDamageAbsorbed >= DAMAGE_SPONGE_THRESHOLD * 1.5;
                const logMessage = `${player.name} is a DAMAGE SPONGE, absorbing ${recentDamageAbsorbed} damage while staying alive!`;
                addEventMessage("Damage Sponge", isMajor, logMessage);
                eventFlags.damageSponge = true;
            } else if (recentDamageAbsorbed < DAMAGE_SPONGE_THRESHOLD) {
                eventFlags.damageSponge = false;
            }

            // Iron Will
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * IRON_WILL_LOW_HEALTH_COMBAT && 
                combatOccurredThisTurn && !playerTookDamageInCombatThisTurn && !eventFlags.ironWill) {
                const isMajor = player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.1;
                const logMessage = `${player.name} shows IRON WILL, fighting at ${player.health} health without taking damage!`;
                addEventMessage("Iron Will", isMajor, logMessage);
                eventFlags.ironWill = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * IRON_WILL_LOW_HEALTH_COMBAT || playerTookDamageInCombatThisTurn) {
                eventFlags.ironWill = false;
            }

            // === TACTICAL EVENTS ===

            // Tactical Advance
            if (previousTurn && enemies.length > 0) {
                const closestEnemyBefore = getClosestEntity(previousTurn.enemiesPositions, {x: previousTurn.playerX, y: previousTurn.playerY});
                const closestEnemyNow = getClosestEntity(enemies, player);
                if (closestEnemyBefore && closestEnemyNow) {
                    const distBefore = getDistance({x: previousTurn.playerX, y: previousTurn.playerY}, closestEnemyBefore);
                    const distNow = getDistance(player, closestEnemyNow);
                    if (distBefore - distNow >= TACTICAL_ADVANCE_DISTANCE && damageDealtThisTurn > 0 && !eventFlags.tacticalAdvance) {
                        const isMajor = distBefore - distNow >= TACTICAL_ADVANCE_DISTANCE * 1.5;
                        const logMessage = `${player.name} executes TACTICAL ADVANCE, closing ${distBefore - distNow} tiles and dealing ${damageDealtThisTurn} damage!`;
                        addEventMessage("Tactical Advance", isMajor, logMessage);
                        eventFlags.tacticalAdvance = true;
                    } else if (distBefore - distNow < TACTICAL_ADVANCE_DISTANCE) {
                        eventFlags.tacticalAdvance = false;
                    }
                }
            }

            // Guerrilla Warfare
            let hitAndRunCount = 0;
            for (let i = Math.max(0, gameHistory.length - GUERRILLA_HIT_AND_RUN); i < gameHistory.length; i++) {
                if (gameHistory[i].damageDealtThisTurn > 0 && gameHistory[i].hitsTakenThisTurn === 0) {
                    hitAndRunCount++;
                }
            }
            if (hitAndRunCount >= GUERRILLA_HIT_AND_RUN && !eventFlags.guerrillaWarfare) {
                const isMajor = hitAndRunCount >= GUERRILLA_HIT_AND_RUN + 2;
                const logMessage = `${player.name} employs GUERRILLA WARFARE, ${hitAndRunCount} consecutive hit-and-run attacks!`;
                addEventMessage("Guerrilla Warfare", isMajor, logMessage);
                eventFlags.guerrillaWarfare = true;
            } else if (hitAndRunCount < GUERRILLA_HIT_AND_RUN) {
                eventFlags.guerrillaWarfare = false;
            }

            // === RESOURCE MANAGEMENT ===

            // Greedy Collector
            const totalPickupsAvailable = staticDamageNumbers.filter(s => !s.isPlayerRemains).length;
            const pickupEfficiency = totalPickupsAvailable > 0 ? 
                (totalPickupValueCollectedThisTurn / totalPickupsAvailable) : 0;
            if (pickupEfficiency >= GREEDY_COLLECTOR_RATIO && totalPickupValueCollectedThisTurn > 0 && !eventFlags.greedyCollector) {
                const isMajor = pickupEfficiency >= 1.0;
                const logMessage = `${player.name} is a GREEDY COLLECTOR, gathering ${totalPickupValueCollectedThisTurn} resources with ${Math.round(pickupEfficiency * 100)}% efficiency!`;
                addEventMessage("Greedy Collector", isMajor, logMessage);
                eventFlags.greedyCollector = true;
            } else if (pickupEfficiency < GREEDY_COLLECTOR_RATIO) {
                eventFlags.greedyCollector = false;
            }

            // Resource Hoarder
            let totalResourcesHoarded = 0;
            for (let i = Math.max(0, gameHistory.length - 10); i < gameHistory.length; i++) {
                totalResourcesHoarded += gameHistory[i].totalPickupValueCollectedThisTurn || 0;
            }
            if (totalResourcesHoarded >= RESOURCE_HOARDER_COUNT && !eventFlags.resourceHoarder) {
                const isMajor = totalResourcesHoarded >= RESOURCE_HOARDER_COUNT * 2;
                const logMessage = `${player.name} is a RESOURCE HOARDER, collecting ${totalResourcesHoarded} total resources recently!`;
                addEventMessage("Resource Hoarder", isMajor, logMessage);
                eventFlags.resourceHoarder = true;
            } else if (totalResourcesHoarded < RESOURCE_HOARDER_COUNT) {
                eventFlags.resourceHoarder = false;
            }

            // === EXPLORATION EVENTS ===

            // Speed Runner
            const levelCompletionRatio = enemies.length === 0 ? 1.0 : (currentTurn.enemiesCount === 0 ? 1.0 : 0);
            if (levelCompletionRatio >= SPEED_RUNNER_PERCENTAGE && stepsTaken <= SPEEDSTER_TURN_LIMIT && !eventFlags.speedRunner) {
                const isMajor = stepsTaken <= SPEEDSTER_TURN_LIMIT * 0.7;
                const logMessage = `${player.name} is a SPEED RUNNER, completing level in ${stepsTaken} turns!`;
                addEventMessage("Speed Runner", isMajor, logMessage);
                eventFlags.speedRunner = true;
            }

            // Cartographer
            const mapCoverage = countVisitedTiles() / (dynamicMapWidth * dynamicMapHeight);
            if (mapCoverage >= CARTOGRAPHER_MAP_COVERAGE && !eventFlags.cartographer) {
                const isMajor = mapCoverage >= 0.98;
                const logMessage = `${player.name} is a CARTOGRAPHER, mapping ${Math.round(mapCoverage * 100)}% of the area!`;
                addEventMessage("Cartographer", isMajor, logMessage);
                eventFlags.cartographer = true;
            } else if (mapCoverage < CARTOGRAPHER_MAP_COVERAGE) {
                eventFlags.cartographer = false;
            }

            // === HEALTH & RECOVERY ===

            // Regeneration
            if (previousTurn && player.health - previousTurn.playerHealth >= REGENERATION_HEALTH_GAIN && !eventFlags.regeneration) {
                const isMajor = player.health - previousTurn.playerHealth >= REGENERATION_HEALTH_GAIN * 1.5;
                const healthGained = player.health - previousTurn.playerHealth;
                const logMessage = `${player.name} shows REGENERATION, gaining ${healthGained} health in one turn!`;
                addEventMessage("Regeneration", isMajor, logMessage);
                eventFlags.regeneration = true;
            } else if (!previousTurn || player.health - previousTurn.playerHealth < REGENERATION_HEALTH_GAIN) {
                eventFlags.regeneration = false;
            }

            // Vitality
            if (player.health >= PLAYER_VISUAL_HEALTH_THRESHOLD * VITALITY_HIGH_HEALTH_COMBAT && 
                combatOccurredThisTurn && damageDealtThisTurn > 0 && !eventFlags.vitality) {
                const isMajor = player.health >= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.9;
                const logMessage = `${player.name} demonstrates VITALITY, fighting at ${player.health} health and dealing ${damageDealtThisTurn} damage!`;
                addEventMessage("Vitality", isMajor, logMessage);
                eventFlags.vitality = true;
            } else if (player.health < PLAYER_VISUAL_HEALTH_THRESHOLD * VITALITY_HIGH_HEALTH_COMBAT || !combatOccurredThisTurn) {
                eventFlags.vitality = false;
            }

            // === PSYCHOLOGICAL EVENTS ===

            // Confidence
            const currentFlow = currentTurn.playerFlow;
            if (currentFlow >= CONFIDENCE_HIGH_FLOW && player.health >= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.6 && !eventFlags.confidence) {
                const isMajor = currentFlow >= CONFIDENCE_HIGH_FLOW * 1.5;
                const logMessage = `${player.name} radiates CONFIDENCE with ${currentFlow.toFixed(2)} flow and ${player.health} health!`;
                addEventMessage("Confidence", isMajor, logMessage);
                eventFlags.confidence = true;
            } else if (currentFlow < CONFIDENCE_HIGH_FLOW || player.health < PLAYER_VISUAL_HEALTH_THRESHOLD * 0.6) {
                eventFlags.confidence = false;
            }

            // Desperation
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * DESPERATION_LOW_HEALTH && 
                enemies.length >= 2 && !eventFlags.desperation) {
                const isMajor = player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.05;
                const logMessage = `${player.name} fights with DESPERATION, ${player.health} health against ${enemies.length} enemies!`;
                addEventMessage("Desperation", isMajor, logMessage);
                eventFlags.desperation = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * DESPERATION_LOW_HEALTH || enemies.length < 2) {
                eventFlags.desperation = false;
            }

            // === ACHIEVEMENT EVENTS ===

            // First Blood (only triggers on level 1)
            if (currentLevel === FIRST_BLOOD_LEVEL && enemiesKilledThisTurn > 0 && !eventFlags.firstBlood) {
                const isMajor = false;
                const logMessage = `${player.name} draws FIRST BLOOD in the division!`;
                addEventMessage("First Blood", isMajor, logMessage);
                eventFlags.firstBlood = true;
            }

            // Perfectionist
            if (enemies.length === 0 && hitsTaken === 0 && stepsTaken > 5 && !eventFlags.perfectionist) {
                const isMajor = true;
                const logMessage = `${player.name} achieves PERFECTIONIST status, completing level without taking damage!`;
                addEventMessage("Perfectionist", isMajor, logMessage);
                eventFlags.perfectionist = true;
            }

            // === LEGACY EVENTS (Updated) ===
            
            // Player Surrounded
            let adjacentEnemiesCount = 0;
            let adjacentEnemies = [];
            const eightDirections = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dx, dy] of eightDirections) {
                const checkX = player.x + dx;
                const checkY = player.y + dy;
                const adjacentEnemy = enemies.find(e => e.x === checkX && e.y === checkY);
                if (adjacentEnemy) {
                    adjacentEnemiesCount++;
                    adjacentEnemies.push(adjacentEnemy);
                }
            }
            if (adjacentEnemiesCount >= SURROUNDED_THRESHOLD && !eventFlags.playerSurrounded) {
                const isMajor = adjacentEnemiesCount >= SURROUNDED_MAJOR_THRESHOLD;
                const enemyNames = adjacentEnemies.map(e => e.name).join(', ');
                const logMessage = `${player.name} is SURROUNDED by ${enemyNames} (${adjacentEnemiesCount} enemies)`;
                addEventMessage("Player Surrounded", isMajor, logMessage);
                eventFlags.playerSurrounded = true;
            } else if (adjacentEnemiesCount < SURROUNDED_THRESHOLD) {
                eventFlags.playerSurrounded = false;
            }

            // Near-Death Recovery
            const wasLowHealthThreshold = PLAYER_VISUAL_HEALTH_THRESHOLD * NEAR_DEATH_HEALTH_RATIO;
            const recoveryThreshold = PLAYER_VISUAL_HEALTH_THRESHOLD * RECOVERY_HEALTH_GAIN_RATIO;

            if (player.health <= wasLowHealthThreshold && !player.wasLowHealth) {
                player.wasLowHealth = true;
                player.lowestHealthReached = player.health;
            } else if (player.wasLowHealth && player.health >= player.lowestHealthReached + recoveryThreshold) {
                if (!eventFlags.nearDeathRecovery) {
                    const isMajor = player.lowestHealthReached <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.1;
                    const logMessage = `${player.name} makes NEAR-DEATH RECOVERY from ${player.lowestHealthReached} to ${player.health} health!`;
                    addEventMessage("Near-Death Recovery", isMajor, logMessage);
                    eventFlags.nearDeathRecovery = true;
                }
                player.wasLowHealth = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
            } else if (player.health > wasLowHealthThreshold && player.wasLowHealth && player.health < player.lowestHealthReached + recoveryThreshold) {
                player.wasLowHealth = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
                eventFlags.nearDeathRecovery = false;
            } else if (player.health > wasLowHealthThreshold && !player.wasLowHealth) {
                eventFlags.nearDeathRecovery = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
            }

            // Killing Spree (Updated)
            if (enemiesKilledRecently >= KILLING_SPREE_COUNT && !eventFlags.killingSpree) {
                const isMajor = enemiesKilledRecently >= KILLING_SPREE_MAJOR_COUNT;
                let recentKilledEnemies = [];
                for (let i = Math.max(0, gameHistory.length - KILLING_SPREE_COUNT); i < gameHistory.length; i++) {
                    if (gameHistory[i].killedEnemyNames) {
                        recentKilledEnemies = recentKilledEnemies.concat(gameHistory[i].killedEnemyNames);
                    }
                }
                const killedNames = recentKilledEnemies.length > 0 ? recentKilledEnemies.join(', ') : 'multiple enemies';
                const logMessage = `${player.name} goes on KILLING SPREE, eliminating ${enemiesKilledRecently} enemies: ${killedNames}`;
                addEventMessage("Killing Spree", isMajor, logMessage);
                eventFlags.killingSpree = true;
            } else if (enemiesKilledRecently < KILLING_SPREE_COUNT) {
                eventFlags.killingSpree = false;
            }

            // Other legacy events with similar updates...
            // (Continuing with existing logic but enhanced logging)

            // NEW: 13. "Perfect Dodge"
            // Only check if combat occurred this turn and player took no damage from combat
            if (currentTurn.combatOccurredThisTurn && !currentTurn.playerTookDamageInCombatThisTurn && !eventFlags.perfectDodge) {
                addEventMessage("Perfect Dodge!");
                eventFlags.perfectDodge = true;
            } else if (!currentTurn.combatOccurredThisTurn || currentTurn.playerTookDamageInCombatThisTurn) {
                eventFlags.perfectDodge = false;
            }

            // NEW: 14. "Critical Strike!" - This is handled directly in movePlayer.

            // NEW: 15. "Flawless Victory" (for a level)
            // This needs to be checked when advancing to the next level, not every turn.
            // We'll add a check in `nextLevel()` or `initGame()` when `resetGameStats` is false.
        }

        /**
         * Advances the player to the next level.
         */
        function nextLevel() {
            // Check for "Flawless Victory" before resetting stats for the new level
            const previousLevelState = gameHistory.find(state => state.currentLevel === currentLevel); // Find state from the start of this level
            let totalDamageTakenThisLevel = 0;
            if (previousLevelState) {
                totalDamageTakenThisLevel = hitsTaken - previousLevelState.hitsTaken;
            }
            if (totalDamageTakenThisLevel === 0 && !eventFlags.flawlessVictory) {
                addProgressMessage("üèÖ Flawless Victory! üèÖ", 'high');
                eventFlags.flawlessVictory = true;
            } else {
                eventFlags.flawlessVictory = false;
            }

            // Preserve auto mode across level transitions
            const previousAutoMode = autoMode;

            // Check for world progression (need points = level * 10)
            const currentScore = stepsTaken > 0 ? Math.floor(totalDamageDealt * (totalDamageDealt / stepsTaken)) : 0;
            const pointsNeededForNextWorld = (currentLevel + 1) * 10;
            
            // Check if we should advance to next world
            if (currentScore >= pointsNeededForNextWorld && WORLDS[currentWorld + 1] && !unlockedWorlds.includes(currentWorld + 1)) {
                currentWorld = currentWorld + 1;
                unlockedWorlds.push(currentWorld);
                console.log(`Advanced to World ${currentWorld}: ${getCurrentWorld().name}!`);
                addProgressMessage(`üåç ENTERED ${getCurrentWorld().name.toUpperCase()}! üåç`, 'high');
            }

            currentLevel = currentLevel + 1; // Explicit assignment
            
            // Add level progression message
            addProgressMessage(`üèÜ LEVEL ${currentLevel} REACHED! üèÜ`, 'high');
            
            initGame(false); // No overlay when progressing levels

            // Restart auto mode if it was active
            if (previousAutoMode) {
                autoMode = previousAutoMode;
                startAutomatedMovement();
            }
        }

        /**
         * Stops all automated movement (A mode).
         */
        function stopAutomatedMovement() {
            if (autoMoveTimeoutId) {
                clearTimeout(autoMoveTimeoutId);
                autoMoveTimeoutId = null;
            }
            autoMode = null;
            autoMovePath = [];
            currentPathIndex = 0;
        }

        /**
         * Finds the closest entity from a list to the player, optionally within a radius.
         * @param {object[]} entities - The list of entities ({x, y}).
         * @param {object} playerPos - The player's current position {x, y}.
         * @param {number} radius - Optional maximum distance to consider. Defaults to Infinity.
         * @returns {object|null} The closest entity, or null if none found within radius.
         */
        function getClosestEntity(entities, playerPos, radius = Infinity) {
            let closest = null;
            let minDist = Infinity;
            entities.forEach(entity => {
                if (entity && typeof entity.x === 'number' && typeof entity.y === 'number') {
                    const dist = getDistance(playerPos, entity);
                    if (dist <= radius && dist < minDist) {
                        minDist = dist;
                        closest = entity;
                    }
                }
            });
            return closest;
        }

        /**
         * Starts the appropriate automated movement mode (P or E).
         * This function determines the target based on the active autoMode and initiates the pathfinding.
         */
        function startAutomatedMovement() {
            console.log('startAutomatedMovement called, autoMode:', autoMode);
            if (gameOver) {
                console.log('Game over, stopping auto movement');
                stopAutomatedMovement();
                return;
            }
            if (autoMode === null) {
                console.log('autoMode is null, returning');
                return;
            }

            // Set standard speed for auto mode
            AUTO_MOVE_SPEED = DEFAULT_AUTO_MOVE_SPEED;

            if (autoMoveTimeoutId) {
                clearTimeout(autoMoveTimeoutId);
                autoMoveTimeoutId = null;
            }

            autoMovePath = [];
            currentPathIndex = 0;

            let targetDestination = null;
            let pathFunction = findPathBasic;
            let pathPenaltyEntities = [];

            const allEnemies = enemies;
            const allPickups = staticDamageNumbers.filter(s => !s.isPlayerRemains);

            if (autoMode === 'auto') {
                console.log('Auto mode logic - Player health:', player.health, 'Enemies:', allEnemies.length, 'Pickups:', allPickups.length);
                // Simple auto mode strategy:
                // 1. If player health is low, prioritize nearby pickups
                // 2. If there are weak enemies (health <= player health), target them
                // 3. If there are pickups nearby, collect them
                // 4. Otherwise go to stairs
                
                const isPlayerLowHealth = player.health <= 10;
                const weakEnemies = allEnemies.filter(e => e.health <= player.health);
                const nearbyPickups = allPickups.filter(p => getDistance(player, p) <= 5);
                
                const closestWeakEnemy = getClosestEntity(weakEnemies, player);
                const closestNearbyPickup = getClosestEntity(nearbyPickups, player);
                const closestPickup = getClosestEntity(allPickups, player);

                console.log('Target analysis - Low health:', isPlayerLowHealth, 'Weak enemies:', weakEnemies.length, 'Nearby pickups:', nearbyPickups.length);

                if (isPlayerLowHealth && closestPickup) {
                    // Low health - prioritize any pickup
                    targetDestination = closestPickup;
                    pathPenaltyEntities = allEnemies; // Avoid all enemies when low health
                    console.log('Targeting pickup for low health at:', targetDestination.x, targetDestination.y);
                } else if (closestWeakEnemy) {
                    // Fight weak enemies for easy wins
                    targetDestination = closestWeakEnemy;
                    pathPenaltyEntities = allEnemies.filter(e => e.health > player.health); // Avoid strong enemies
                    console.log('Targeting weak enemy at:', targetDestination.x, targetDestination.y);
                } else if (closestNearbyPickup) {
                    // Collect nearby pickups when no weak enemies
                    targetDestination = closestNearbyPickup;
                    pathPenaltyEntities = allEnemies; // Avoid all enemies when collecting
                    console.log('Targeting nearby pickup at:', targetDestination.x, targetDestination.y);
                } else {
                    // Default: go to stairs
                    targetDestination = stairs;
                    pathPenaltyEntities = allEnemies; // Avoid enemies when heading to exit
                    console.log('Targeting stairs at:', targetDestination.x, targetDestination.y);
                }
                
                pathFunction = findPathWithProximityPenalty;
            }

            if (targetDestination) {
                console.log('Finding path to target:', targetDestination.x, targetDestination.y);
                // For auto-movement, entities should avoid certain obstacles.
                // If the target is stairs, stairs should NOT be an obstacle.
                const entitiesToAvoidForAutoMove = [...pathPenaltyEntities];
                if (targetDestination !== stairs && stairs) {
                    entitiesToAvoidForAutoMove.push(stairs);
                }
                const path = pathFunction(player.x, player.y, targetDestination.x, targetDestination.y, gameMap, dynamicMapWidth, dynamicMapHeight, entitiesToAvoidForAutoMove);
                console.log('Path found:', path ? `${path.length} steps` : 'null');
                if (path && path.length > 1) {
                    autoMovePath = path;
                    console.log('Executing first auto move step');
                    executeAutoMoveStep();
                } else {
                    // Fallback: try basic pathfinding to stairs
                    console.log("Auto mode: Primary pathfinding failed, trying basic pathfinding to stairs...");
                    let fallbackPath = findPathBasic(player.x, player.y, stairs.x, stairs.y, gameMap, dynamicMapWidth, dynamicMapHeight, []);
                    
                    if (fallbackPath && fallbackPath.length > 1) {
                        autoMovePath = fallbackPath;
                        executeAutoMoveStep();
                    } else {
                        console.warn("Auto mode: Even basic pathfinding failed, stopping auto-movement");
                        stopAutomatedMovement();
                    }
                }
            } else {
                console.warn("Auto mode: No target destination found, stopping auto-movement");
                stopAutomatedMovement();
            }
        }

        /**
         * Executes one step of the automated movement path for auto mode.
         * This function is called recursively by setTimeout.
         */
        function executeAutoMoveStep() {
            if (gameOver || autoMode === null) {
                stopAutomatedMovement();
                return;
            }

            if (!autoMovePath || autoMovePath.length === 0 || currentPathIndex >= autoMovePath.length) {
                // If path is exhausted or invalid, try to find a new path
                autoMoveTimeoutId = setTimeout(startAutomatedMovement, AUTO_MOVE_SPEED);
                return;
            }

            const nextPos = autoMovePath[currentPathIndex];
            const dx = nextPos.x - player.x;
            const dy = nextPos.y - player.y;

            const combatOccurred = movePlayer(dx, dy);

            if (gameOver) {
                stopAutomatedMovement();
                return;
            }

            const delay = combatOccurred ? COMBAT_MOVE_DELAY : AUTO_MOVE_SPEED;

            // Check if we need to recalculate the path
            let shouldRecalculate = false;
            
            // If the player didn't move to the expected position or combat occurred, recalculate
            if (player.x !== nextPos.x || player.y !== nextPos.y || combatOccurred) {
                shouldRecalculate = true;
            }

            if (shouldRecalculate) {
                autoMoveTimeoutId = setTimeout(startAutomatedMovement, delay);
                return;
            }

            currentPathIndex = currentPathIndex + 1; // Explicit assignment
            autoMoveTimeoutId = setTimeout(executeAutoMoveStep, delay);
        }

        /**
         * Handles keyboard input for player movement.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDown(event) {
            console.log('Key pressed:', event.key); // Debug: log every key press
            
            // If the game start overlay is active, any key press will dismiss it
            if (gameStartedOverlayActive) {
                gameStartedOverlayActive = false;
                event.preventDefault(); // Prevent default action for the key press
                return;
            }

            // Only process game input if the game is running (which it always is now after initial load)
            if (!isGameRunning) {
                return;
            }

            // Stop auto mode on any key press except A
            if (autoMode !== null && 
                event.key !== 'a' && event.key !== 'A') {
                stopAutomatedMovement();
                // Continue processing the key press for manual control
            }

            if (event.key === 'a' || event.key === 'A') {
                console.log('=== A KEY DETECTED ===');
                event.preventDefault();
                console.log('A key pressed. Current autoMode:', autoMode);
                if (autoMode === 'auto') {
                    console.log('Stopping auto mode');
                    stopAutomatedMovement();
                } else {
                    console.log('Starting auto mode');
                    stopAutomatedMovement();
                    autoMode = 'auto';
                    startAutomatedMovement();
                }
                return;
            }

            // World switching controls (1-9 keys)
            if (['1','2','3','4','5','6','7','8','9'].includes(event.key)) {
                event.preventDefault();
                const worldNumber = parseInt(event.key);
                
                // Check if world exists and is unlocked (temporarily unlock all for testing)
                if (WORLDS[worldNumber] && worldNumber !== currentWorld) {
                    currentWorld = worldNumber;
                    // Temporarily unlock all worlds for testing
                    unlockedWorlds = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                    setupWorldColors();
                    initGame(true, false); // Restart game in new world
                    console.log(`Switched to world ${worldNumber}: ${WORLDS[worldNumber].name}`);
                }
                return;
            }

            if (gameOver) {
                event.preventDefault();
                return;
            }

            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                    // Removed 'a' and 'A' from left movement since A is now auto mode
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    movePlayer(1, 0);
                    break;
            }
        }

        // Controller/Gamepad Support Variables
        let gamepadIndex = -1;
        let lastGamepadState = {
            buttons: [],
            axes: []
        };
        const GAMEPAD_DEADZONE = 0.3;
        const GAMEPAD_POLL_INTERVAL = 16; // ~60fps polling

        /**
         * Detects connected gamepads and sets up gamepad support
         */
        function detectGamepad() {
            const gamepads = navigator.getGamepads();
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i]) {
                    gamepadIndex = i;
                    console.log(`Gamepad connected: ${gamepads[i].id}`);
                    break;
                }
            }
        }

        /**
         * Handles gamepad input polling
         */
        function handleGamepadInput() {
            if (gamepadIndex === -1) return;

            const gamepad = navigator.getGamepads()[gamepadIndex];
            if (!gamepad) {
                gamepadIndex = -1;
                return;
            }

            // Handle D-pad and analog stick movement
            let dx = 0;
            let dy = 0;

            // D-pad (buttons 12, 13, 14, 15 are standard D-pad)
            if (gamepad.buttons[12] && gamepad.buttons[12].pressed) dy = -1; // Up
            if (gamepad.buttons[13] && gamepad.buttons[13].pressed) dy = 1;  // Down
            if (gamepad.buttons[14] && gamepad.buttons[14].pressed) dx = -1; // Left
            if (gamepad.buttons[15] && gamepad.buttons[15].pressed) dx = 1;  // Right

            // Left analog stick (axes 0 and 1)
            if (Math.abs(gamepad.axes[0]) > GAMEPAD_DEADZONE) {
                if (gamepad.axes[0] > GAMEPAD_DEADZONE) dx = 1;
                else if (gamepad.axes[0] < -GAMEPAD_DEADZONE) dx = -1;
            }
            if (Math.abs(gamepad.axes[1]) > GAMEPAD_DEADZONE) {
                if (gamepad.axes[1] > GAMEPAD_DEADZONE) dy = 1;
                else if (gamepad.axes[1] < -GAMEPAD_DEADZONE) dy = -1;
            }

            // Only move if there's input and it's different from last frame
            if ((dx !== 0 || dy !== 0) && !gameOver) {
                const currentInput = `${dx},${dy}`;
                const lastInput = `${lastGamepadState.dx || 0},${lastGamepadState.dy || 0}`;
                
                // Only process movement if it's a new input or enough time has passed
                if (currentInput !== lastInput || !lastGamepadState.lastMoveTime || 
                    performance.now() - lastGamepadState.lastMoveTime > 150) {
                    movePlayer(dx, dy);
                    lastGamepadState.lastMoveTime = performance.now();
                }
                lastGamepadState.dx = dx;
                lastGamepadState.dy = dy;
            } else {
                lastGamepadState.dx = 0;
                lastGamepadState.dy = 0;
            }

            // Handle automation mode buttons
            // X button (button 2) - Toggle stairs mode
            if (gamepad.buttons[2] && gamepad.buttons[2].pressed && !lastGamepadState.buttons[2]) {
                if (autoMode === 'stairs') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'stairs';
                    startAutomatedMovement();
                }
            }

            // Y button (button 3) - Toggle enemies mode
            if (gamepad.buttons[3] && gamepad.buttons[3].pressed && !lastGamepadState.buttons[3]) {
                if (autoMode === 'enemies') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'enemies';
                    startAutomatedMovement();
                }
            }

            // A button (button 0) - Toggle high score mode
            if (gamepad.buttons[0] && gamepad.buttons[0].pressed && !lastGamepadState.buttons[0]) {
                if (autoMode === 'highScore') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'highScore';
                    startAutomatedMovement();
                }
            }

            // B button (button 1) - Toggle survival mode
            if (gamepad.buttons[1] && gamepad.buttons[1].pressed && !lastGamepadState.buttons[1]) {
                if (autoMode === 'survival') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'survival';
                    startAutomatedMovement();
                }
            }

            // Start button (button 9) - Restart game when game over
            if (gameOver && gamepad.buttons[9] && gamepad.buttons[9].pressed && !lastGamepadState.buttons[9]) {
                // Trigger restart animation and game restart
                const restartText = "PRESS R TO RESTART";
                const baseFontSize = Math.floor(dynamicTileSize * 0.8);
                ctx.font = `${baseFontSize}px VT323`;
                const textMetrics = ctx.measureText(restartText);
                const textWidth = textMetrics.width;

                const textX = gameCanvas.width / 2;
                const textY = gameCanvas.height / 2 + dynamicTileSize * 1.5;

                // Generate particles for each character
                restartTextParticles = [];
                let currentTextX = textX - textWidth / 2;
                const charSpacing = textWidth / restartText.length;

                for (let i = 0; i < restartText.length; i++) {
                    const char = restartText[i];
                    const charX = currentTextX + charSpacing * i + charSpacing / 2;
                    const charY = textY;

                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 0.5 + 0.2) * (dynamicTileSize / 20);
                    const dirX = Math.cos(angle);
                    const dirY = Math.sin(angle);
                    const fadeFactor = Math.random() * 0.7 + 0.3;

                    restartTextParticles.push({
                        char: char,
                        startX: charX,
                        startY: charY,
                        dirX: dirX,
                        dirY: dirY,
                        initialSpeed: speed,
                        fontSize: baseFontSize,
                        color: '#FFD700',
                        startTime: performance.now(),
                        duration: RESTART_TEXT_EXPLOSION_DURATION,
                        fadeFactor: fadeFactor
                    });
                }

                restartTextAnimationActive = true;
                restartTextAnimationStartTime = performance.now();
                restartGame();
            }

            // Any face button - Dismiss game start overlay
            if (gameStartedOverlayActive && 
                ((gamepad.buttons[0] && gamepad.buttons[0].pressed) ||
                 (gamepad.buttons[1] && gamepad.buttons[1].pressed) ||
                 (gamepad.buttons[2] && gamepad.buttons[2].pressed) ||
                 (gamepad.buttons[3] && gamepad.buttons[3].pressed))) {
                gameStartedOverlayActive = false;
            }

            // Store button states for next frame
            lastGamepadState.buttons = gamepad.buttons.map(button => button.pressed);
        }

        /**
         * Starts gamepad polling
         */
        function startGamepadPolling() {
            setInterval(() => {
                if (gamepadIndex === -1) {
                    detectGamepad();
                } else {
                    handleGamepadInput();
                }
            }, GAMEPAD_POLL_INTERVAL);
        }

        // Gamepad connection event listeners
        window.addEventListener('gamepadconnected', (e) => {
            console.log(`Gamepad connected: ${e.gamepad.id}`);
            gamepadIndex = e.gamepad.index;
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log(`Gamepad disconnected: ${e.gamepad.id}`);
            if (e.gamepad.index === gamepadIndex) {
                gamepadIndex = -1;
            }
        });

        /**
         * The main animation loop.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function animate(currentTime) {
            try {
                animationFrameId = requestAnimationFrame(animate);
                drawGame();
            }
            catch (error) {
                console.error("Error in animation loop:", error);
                stopAnimationLoop(); // Stop the loop to prevent further errors
                handleGameOver(); // Attempt to gracefully end the game
            }
        }

        /**
         * Starts the animation loop.
         */
        function startAnimationLoop() {
            console.log('Starting animation loop...');
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(animate);
            console.log('Animation loop started with ID:', animationFrameId);
        }

        /**
         * Stops the animation loop.
         */
        function stopAnimationLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        /**
         * Calculates the current score.
         */
        function calculateScore() {
            let score = 0;
            if (stepsTaken > 0) {
                const averageDamagePerTurn = totalDamageDealt / stepsTaken;
                score = Math.floor(totalDamageDealt * averageDamagePerTurn);
            }
            return score;
        }

        /**
         * Loads high scores from local storage. (Function kept for potential future use, not currently displayed)
         */
        function loadHighScores() {
            const storedScores = localStorage.getItem(HIGH_SCORES_STORAGE_KEY);
            if (storedScores) {
                highScores = JSON.parse(storedScores);
            } else {
                highScores = [];
            }
        }

        /**
         * Saves high scores to local storage. (Function kept for potential future use, not currently displayed)
         */
        function saveHighScores() {
            localStorage.setItem(HIGH_SCORES_STORAGE_KEY, JSON.stringify(highScores));
        }

        /**
         * Adds a new score to the high scores list. (Function kept for potential future use, not currently displayed)
         * @param {string} name - Player's name.
         * @param {number} score - Player's score.
         */
        function addHighScore(name, score) {
            highScores.push({ name: name, score: score });
            highScores.sort((a, b) => b.score - a.score); // Sort descending
            highScores = highScores.slice(0, MAX_HIGH_SCORES); // Keep only top N
            saveHighScores();
        }

        /**
         * Calculates the target dynamicTileSize for a given level based on current canvas dimensions.
         * @param {number} level - The level for which to calculate the target tile size.
         * @returns {number} The calculated target tile size.
         */
        function calculateTargetTileSize(level) {
            const initialMaxTileSize = Math.floor(Math.min(gameCanvas.width / MAX_VISIBLE_TILES_LEVEL1, gameCanvas.height / MAX_VISIBLE_TILES_LEVEL1));
            const finalMinTileSize = Math.floor(Math.min(gameCanvas.width / MIN_VISIBLE_TILES_MAX_LEVEL, gameCanvas.height / MIN_VISIBLE_TILES_MAX_LEVEL));
            let calculated = initialMaxTileSize - ((Math.min(level, ZOOM_LEVELS_EFFECTIVE) - 1) * (initialMaxTileSize - finalMinTileSize) / (ZOOM_LEVELS_EFFECTIVE - 1));
            return Math.max(finalMinTileSize, Math.floor(calculated));
        }

        /**
         * Gets the player's location using geolocation and IP-based lookup
         */
        async function getPlayerLocation() {
            try {
                // Try IP-based location first (more reliable and no API key needed)
                await getLocationByIP();
                updateLeaderboard();
            } catch (error) {
                console.log('All location detection methods failed:', error);
                playerLocation = { city: 'Unknown', country: 'Unknown' };
                updateLeaderboard();
            }
        }

        /**
         * Gets player location based on IP address using multiple fallback services
         */
        async function getLocationByIP() {
            const services = [
                // Try ipapi.co first
                async () => {
                    const response = await fetch('https://ipapi.co/json/');
                    const data = await response.json();
                    return {
                        city: data.city || 'Unknown',
                        country: data.country_name || 'Unknown'
                    };
                },
                // Fallback to ip-api.com
                async () => {
                    const response = await fetch('http://ip-api.com/json/');
                    const data = await response.json();
                    return {
                        city: data.city || 'Unknown',
                        country: data.country || 'Unknown'
                    };
                },
                // Fallback to ipinfo.io
                async () => {
                    const response = await fetch('https://ipinfo.io/json');
                    const data = await response.json();
                    return {
                        city: data.city || 'Unknown',
                        country: data.country || 'Unknown'
                    };
                }
            ];

            for (let i = 0; i < services.length; i++) {
                try {
                    console.log(`Trying location service ${i + 1}...`);
                    const result = await services[i]();
                    if (result.city !== 'Unknown' || result.country !== 'Unknown') {
                        playerLocation.city = result.city;
                        playerLocation.country = result.country;
                        console.log(`Location found: ${result.city}, ${result.country}`);
                        return;
                    }
                } catch (error) {
                    console.log(`Location service ${i + 1} failed:`, error);
                    continue;
                }
            }
            
            // If all services fail
            throw new Error('All location services failed');
        }

        /**
         * Loads the leaderboard from localStorage
         */
        function loadLeaderboard() {
            const saved = localStorage.getItem('hardDivisionLeaderboard');
            if (saved) {
                leaderboard = JSON.parse(saved);
            } else {
                // Initialize with some sample scores
                leaderboard = [
                    { name: 'Anonymous', city: 'New York', country: 'USA', score: 1500 },
                    { name: 'Anonymous', city: 'London', country: 'UK', score: 1350 },
                    { name: 'Anonymous', city: 'Tokyo', country: 'Japan', score: 1200 },
                    { name: 'Anonymous', city: 'Berlin', country: 'Germany', score: 1100 },
                    { name: 'Anonymous', city: 'Sydney', country: 'Australia', score: 1000 },
                    { name: 'Anonymous', city: 'Toronto', country: 'Canada', score: 950 },
                    { name: 'Anonymous', city: 'Paris', country: 'France', score: 900 },
                    { name: 'Anonymous', city: 'Seoul', country: 'South Korea', score: 850 },
                    { name: 'Anonymous', city: 'Mumbai', country: 'India', score: 800 },
                    { name: 'Anonymous', city: 'S√£o Paulo', country: 'Brazil', score: 750 }
                ];
            }
        }

        /**
         * Saves the leaderboard to localStorage
         */
        function saveLeaderboard() {
            localStorage.setItem('hardDivisionLeaderboard', JSON.stringify(leaderboard));
        }

        /**
         * Updates the leaderboard display
         */
        function updateLeaderboard() {
            const content = document.getElementById('leaderboard-content');
            if (!content) return;

            let html = '';
            leaderboard.forEach((entry, index) => {
                // Truncate city name if too long
                const maxCityLength = 8;
                const truncatedCity = entry.city.length > maxCityLength ? 
                    entry.city.substring(0, maxCityLength - 2) + '..' : 
                    entry.city;
                
                // Create a short country abbreviation for display
                const countryAbbrev = entry.country.length > 8 ? 
                    entry.country.substring(0, 3).toUpperCase() : 
                    entry.country.substring(0, 4).toUpperCase();
                
                // Combine city and country with length limit
                const locationText = `${truncatedCity},${countryAbbrev}`;
                const maxLocationLength = 16;
                const finalLocation = locationText.length > maxLocationLength ?
                    locationText.substring(0, maxLocationLength - 2) + '..' :
                    locationText;
                
                html += `
                    <div class="leaderboard-entry">
                        <span class="leaderboard-rank">${index + 1}.</span>
                        <span class="leaderboard-name">${entry.name}</span>
                        <span class="leaderboard-city">${finalLocation}</span>
                        <span class="leaderboard-score">${entry.score}</span>
                    </div>
                `;
            });
            content.innerHTML = html;
        }

        /**
         * Adds a score to the leaderboard
         */
        function addToLeaderboard(score) {
            // Use the current player's name from their run
            const currentPlayerName = player && player.name ? player.name : 'Anonymous';

            const newEntry = {
                name: currentPlayerName,
                city: playerLocation.city,
                country: playerLocation.country,
                score: score
            };

            leaderboard.push(newEntry);
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 10); // Keep only top 10

            saveLeaderboard();
            updateLeaderboard();
        }

        /**
         * Initializes the game for a new level or a new game.
         * @param {boolean} resetGameStats - Whether to reset all game statistics.
         * @param {boolean} showGameStartOverlay - Whether to show the "HARD DIVISION" overlay.
         */
        function initGame(resetGameStats = true, showGameStartOverlay = false) {
            console.log('=== initGame() called ===', { resetGameStats, showGameStartOverlay });
            const wasGameOver = gameOver; // Capture state before resetting gameOver
            gameOver = false;
            // Remove any existing event listener before adding a new one
            window.removeEventListener('keydown', handleKeyDown);
            window.addEventListener('keydown', handleKeyDown);
            
            console.log('About to check currentLevel and reset stats...');
            // Ensure currentLevel has a valid value before using it
            if (resetGameStats || currentLevel === undefined || currentLevel === null) {
                currentLevel = 1; // Initialize currentLevel first
                console.log('Set currentLevel to:', currentLevel);
                // Check for world progression on new game
                if (resetGameStats) {
                    checkAndUnlockWorlds();
                }
            }
            
            console.log('About to setup world colors...');
            // Set up world-specific colors and theme
            setupWorldColors();
            
            // Set initial map dimensions based on current level
            const BASE_MAP_DIMENSION = 7;
            dynamicMapWidth = BASE_MAP_DIMENSION + Math.floor((currentLevel - 1) * 0.5);
            dynamicMapHeight = BASE_MAP_DIMENSION + Math.floor((currentLevel - 1) * 0.5);
            
            const MAX_MAP_DIMENSION = 60;
            dynamicMapWidth = Math.min(dynamicMapWidth, MAX_MAP_DIMENSION);
            dynamicMapHeight = Math.min(dynamicMapHeight, MAX_MAP_DIMENSION);

            // Initialize visited tiles grid
            visitedTiles = Array(dynamicMapHeight).fill(null).map(() => Array(dynamicMapWidth).fill(false));
            
            // Initialize core game objects
            if (!player) {
                player = { 
                    x: 0, 
                    y: 0, 
                    health: 1, 
                    name: generateAgentName(), 
                    healthAnimScale: 1, 
                    healthAnimStartTime: 0, 
                    thrustAnimActive: false, 
                    thrustAnimStartTime: 0, 
                    thrustAnimDirectionX: 0, 
                    thrustAnimDirectionY: 0, 
                    thrustAnimMagnitude: 0, 
                    lowestHealthReached: PLAYER_VISUAL_HEALTH_THRESHOLD, 
                    wasLowHealth: false, 
                    thrustAnimDuration: 200 
                };
            }
            
            if (!stairs) {
                stairs = { x: 0, y: 0 };
            }
            
            if (!enemies) {
                enemies = [];
            }
            
            if (resetGameStats) {
                player.x = 0; // Reset player position
                player.y = 0;
                // currentLevel already set above
                player.health = 1; // Set player health to 1 for new game/restart
                hitsDealt = 0;
                hitsTaken = 0;
                stepsTaken = 0;
                totalDamageDealt = 0;
                autoMode = null;
                // Reset death animation states
                deathAnimationActive = false;
                deathAnimationStartTime = 0;
                timeScale = 1;
                gameStartedOverlayActive = showGameStartOverlay; // This controls the fading overlay
                if (showGameStartOverlay) {
                    gameStartedOverlayStartTime = performance.now();
                }

                // IMPORTANT: Do NOT reset restartTextAnimationActive or restartTextParticles here
                // if we are coming from a game over state, as the animation needs to play out.
                // The drawGame loop will clear them once the animation duration is over.
                if (!wasGameOver) { // Only clear if it's a fresh start, not a restart from game over
                    restartTextAnimationActive = false;
                    restartTextParticles = [];
                }

                // Reset event tracking flags and history for a new game
                for (const key in eventFlags) {
                    eventFlags[key] = false;
                }
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
                player.wasLowHealth = false;

                // Reset activity log for new game
                activityLog = [];

            } else {
                // Heal player by current level number when advancing to a new level
                player.health = player.health + currentLevel; // Explicit assignment
                player.healthAnimScale = 1.5; // Trigger health animation
                player.healthAnimStartTime = performance.now();
                gameStartedOverlayActive = false; // Ensure it's off for level progression
            }
            player.healthAnimScale = 1;
            player.healthAnimStartTime = 0;
            activeDamageTextAnimations = [];
            activeExplosions = [];
            activePickupAnimations = []; // Reset pickup animations for new level
            staticDamageNumbers = []; // Clear all static pickups for new level/game
            activeEventMessages = []; // Clear active event messages

            // Reset per-turn stats
            enemiesKilledThisTurn = 0;
            killedEnemiesThisTurn = []; // Reset killed enemies tracking
            damageDealtThisTurn = 0;
            hitsTakenThisTurn = 0;
            totalPickupValueCollectedThisTurn = 0;
            combatOccurredThisTurn = false; // Reset for new level
            playerTookDamageInCombatThisTurn = false; // Reset for new level

            const targetDynamicTileSizeForLevel = calculateTargetTileSize(currentLevel);

            if (resetGameStats) {
                // For a new game/restart, start zoomed in
                // Increase GAME_START_INITIAL_ZOOM_FACTOR for more zoom
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel * GAME_START_INITIAL_ZOOM_FACTOR);
                gameStartZoomActive = true;
                gameStartZoomStartTime = performance.now();
            } else {
                // For level progression, just set to the target size immediately
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel);
                gameStartZoomActive = false; // Ensure it's off for level progression
            }

            // Update map dimensions based on current level (using constants defined earlier)
            dynamicMapWidth = Math.min(
                7 + Math.floor((currentLevel - 1) * 0.5),
                60
            );
            dynamicMapHeight = Math.min(
                7 + Math.floor((currentLevel - 1) * 0.5),
                60
            );

            // Initialize visitedTiles grid
            visitedTiles = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(false));


            console.log(`Initializing Level ${currentLevel}. Map dimensions: ${dynamicMapWidth}x${dynamicMapHeight}`);

            let attempts = 0;
            const MAX_ATTEMPTS = 1000; // Max attempts to generate a connected map
            let mapGeneratedSuccessfully = false;

            // Map generation always happens now, as the game starts directly
            do {
                console.log(`Level ${currentLevel} - World ${currentWorld} (${getCurrentWorld().name}) - Map generation attempt: ${attempts + 1}`);
                initializeMap();
                generateWorldMap();

                // Validate map has floor tiles
                let floorTilesFound = false;
                for (let y = 0; y < dynamicMapHeight; y++) {
                    for (let x = 0; x < dynamicMapWidth; x++) {
                        if (gameMap[y][x] === TILE_FLOOR) {
                            floorTilesFound = true;
                            break;
                        }
                    }
                    if (floorTilesFound) break;
                }
                
                if (!floorTilesFound) {
                    console.error("No floor tiles generated - retrying map generation");
                    continue;
                }

                // Place player
                findPlayerStartInCorner(); // This function now ensures player is on a floor tile
                
                // Validate player position
                if (player.x === undefined || player.y === undefined || 
                    player.x === null || player.y === null ||
                    !gameMap[player.y] || gameMap[player.y][player.x] !== TILE_FLOOR) {
                    console.error("Invalid player placement - retrying map generation");
                    continue;
                }

                // Mark player's starting tile as visited
                if (visitedTiles[player.y] && visitedTiles[player.y][player.x] !== undefined) {
                    visitedTiles[player.y][player.x] = true;
                }
                console.log(`Player placed at (${player.x}, ${player.y})`);

                // Place stairs
                placeStairsOppositeCorner(); // This function now ensures stairs are on a stairs tile
                console.log(`Stairs placed at (${stairs.x}, ${stairs.y})`);

                // Calculate player's average flow for new enemies
                const playerAverageFlowForNewEnemies = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0;

                // Spawn enemies
                // For level 1, pass 0 as levelHealthBonus to ensure enemy starts with 1 health
                // For other levels, pass player.health as before
                spawnEnemies(currentLevel === 1 ? 0 : player.health, playerAverageFlowForNewEnemies);

                // Spawn pickups for the current level
                spawnPickups();

                // Check path from player to stairs
                if (player.x !== undefined && player.y !== undefined && stairs.x !== undefined && stairs.y !== undefined) {
                    mapGeneratedSuccessfully = findPathBasic(player.x, player.y, stairs.x, stairs.y, gameMap, dynamicMapWidth, dynamicMapHeight, enemies) !== null;
                    console.log(`Path from player to stairs exists: ${mapGeneratedSuccessfully}`);
                } else {
                    mapGeneratedSuccessfully = false; // Cannot check path if player/stairs not valid
                    console.warn("Player or stairs not valid, map generation considered unsuccessful.");
                }

                attempts = attempts + 1; // Explicit assignment
                if (!mapGeneratedSuccessfully && attempts >= MAX_ATTEMPTS) {
                    console.warn(`Max map generation attempts (${MAX_ATTEMPTS}) reached for Level ${currentLevel}. Attempting to force a path.`);
                    // Force a path by creating a direct line of floor tiles from player to stairs
                    let currentPathX = player.x;
                    let currentPathY = player.y;
                    let pathSteps = 0;
                    const MAX_PATH_FORCING_STEPS = dynamicMapWidth * dynamicMapHeight * 2; // Safeguard

                    while ((currentPathX !== stairs.x || currentPathY !== stairs.y) && pathSteps < MAX_PATH_FORCING_STEPS) {
                        // Ensure current position is floor
                        if (gameMap[currentPathY] && gameMap[currentPathY][currentPathX] !== undefined) {
                            gameMap[currentPathY][currentPathX] = TILE_FLOOR;
                        }

                        const dx = stairs.x - currentPathX;
                        const dy = stairs.y - currentPathY;

                        if (dx !== 0 && dy !== 0) { // If both X and Y need to change
                            if (Math.abs(dx) > Math.abs(dy)) {
                                currentPathX = currentPathX + Math.sign(dx); // Explicit assignment
                            } else {
                                currentPathY = currentPathY + Math.sign(dy); // Explicit assignment
                            }
                        } else if (dx !== 0) { // Only X needs to change
                            currentPathX = currentPathX + Math.sign(dx); // Explicit assignment
                        } else if (dy !== 0) { // Only Y needs to change
                            currentPathY = currentPathY + Math.sign(dy); // Explicit assignment
                        }

                        // Ensure bounds for forced path
                        currentPathX = Math.max(0, Math.min(dynamicMapWidth - 1, currentPathX));
                        currentPathY = Math.max(0, Math.min(dynamicMapHeight - 1, currentPathY));

                        // Ensure the new step is floor, unless it's the stairs
                        if (currentPathX === stairs.x && currentPathY === stairs.y) {
                             gameMap[currentPathY][currentPathX] = TILE_STAIRS;
                        } else if (gameMap[currentPathY] && gameMap[currentPathY][currentPathX] !== undefined) {
                             gameMap[currentPathY][currentPathX] = TILE_FLOOR;
                        }
                        pathSteps = pathSteps + 1; // Explicit assignment
                    }
                    if (pathSteps >= MAX_PATH_FORCING_STEPS) {
                        console.error("Forced path generation hit max steps, likely stuck in an infinite loop logic. This should not happen with the new logic.");
                        // Fallback: Ensure stairs is at least TILE_STAIRS if loop exited prematurely
                        if (gameMap[stairs.y] && gameMap[stairs.y][stairs.x] !== undefined) {
                            gameMap[stairs.y][stairs.x] = TILE_STAIRS;
                        }
                    } else {
                        gameMap[stairs.y][stairs.x] = TILE_STAIRS; // Ensure stairs are still stairs at the end
                    }
                    mapGeneratedSuccessfully = true; // Path is now guaranteed
                    console.log("Forced a path from player to stairs.");
                }
            } while (!mapGeneratedSuccessfully);

            setupColors();
            // Animation loop is already started, no need to call startAnimationLoop() here.
            // It's continuously drawing the game.

            // If an auto-mode was active before initGame, restart it for the new level
            if (autoMode !== null) {
                startAutomatedMovement();
            }
        }

        // Handle canvas resizing for responsiveness
        function resizeCanvas() {
            // Get container dimensions
            const gameContainer = document.getElementById('gameContainer');
            const canvas = document.getElementById('gameCanvas');
            
            if (!gameContainer || !canvas) {
                console.error('Required elements not found:', { 
                    gameContainer: !!gameContainer, 
                    canvas: !!canvas 
                });
                return;
            }

            // Make canvas truly fullscreen
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            
            // Set the container dimensions to fullscreen
            gameContainer.style.width = `${canvasWidth}px`;
            gameContainer.style.height = `${canvasHeight}px`;
            
            // Set the canvas dimensions to fullscreen
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Calculate new tile size
            const targetDynamicTileSizeForLevel = calculateTargetTileSize(currentLevel);

            // Update the tile size
            if (gameStartZoomActive) {
                // Let the zoom animation handle the tile size
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel * GAME_START_INITIAL_ZOOM_FACTOR);
            } else {
                // Set tile size directly
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel);
            }

            // Force a redraw
            drawGame();
        }

        // Wait for the DOM to be fully loaded before initializing
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded - Initializing game...');
            
            // Get canvas element and context
            gameCanvas = document.getElementById('gameCanvas');
            if (!gameCanvas) {
                console.error('Canvas element not found!');
                return;
            }
            
            ctx = gameCanvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context!');
                return;
            }
            
            console.log('Canvas and context successfully obtained');
            
            // Initialize leaderboard and get player location
            loadLeaderboard();
            
            // Load total player score for world progression
            const savedScore = localStorage.getItem('hardDivisionTotalScore');
            if (savedScore) {
                totalPlayerScore = parseInt(savedScore);
            }
            checkAndUnlockWorlds();
            
            // Set initial background color based on current world
            updateBackgroundColor();
            
            console.log('About to update leaderboard and initialize game...');
            console.log('Canvas element found:', gameCanvas ? 'YES' : 'NO');
            console.log('Context obtained:', ctx ? 'YES' : 'NO');
            
            updateLeaderboard();
            getPlayerLocation(); // This will update the leaderboard once location is found
            
            // Initialize the game
            console.log('Calling initGame...');
            initGame(true, true); // Reset game stats and show overlay
            
            // Set up event listeners (keydown is handled in initGame)
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize message filter system
            initializeMessageFilters();
            
            // Initialize gamepad support
            startGamepadPolling();
            detectGamepad();
            
            // Initial canvas resize
            resizeCanvas();
            
            // Start the animation loop
            startAnimationLoop();
            
            console.log('Game initialization complete');
        });
    </script>
</body>
</html>
