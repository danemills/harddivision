<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hard Division - A Minimalist Turn-Based Roguelike</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --world-wall-color: #000000; /* Force black for any CSS variable usage */
        }
        
        html {
            background-color: #000000 !important; /* Force black on HTML element */
        }
        
        /* Nuclear option - force EVERYTHING to be black */
        *, *::before, *::after {
            background-color: #000000 !important;
            background: #000000 !important;
        }
        
        html {
            background-color: #000000 !important;
            background: #000000 !important;
        }
        
        body {
            background-color: #000000 !important;
            background: #000000 !important;
        }
        
        canvas {
            background-color: #000000 !important;
            background: #000000 !important;
        }
         
        body {
            font-family: 'VT323', monospace;
            background-color: #000000 !important; /* Force black background - override any CSS variables */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #e2e8f0;
            overflow: hidden; /* Prevent body scrollbars */
        }
        
        .leaderboard {
            display: none; /* Hidden - using top bar dropdown instead */
            position: fixed;
            left: 10px;
            top: 10px;
            width: 180px;
            height: auto;
            background-color: transparent;
            border: none;
            padding: 5px;
            font-family: 'VT323', monospace;
            color: #e2e8f0;
            font-size: 16px;
            z-index: 1000;
            overflow: visible;
        }
        
        .leaderboard h3 {
            margin: 0 0 5px 0;
            text-align: left;
            color: #e2e8f0;
            font-size: 18px;
            border: none;
            padding: 0;
        }
        
        .leaderboard-entry {
            margin-bottom: 2px;
            padding: 0;
            background-color: transparent;
            font-size: 16px;
            line-height: 1.3;
            color: #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: baseline;
        }
        
        .leaderboard-rank {
            color: #e2e8f0;
            font-weight: bold;
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .leaderboard-name {
            color: #e2e8f0;
            font-size: 16px;
            margin-left: 5px;
            flex-shrink: 0;
        }
        
        .leaderboard-city {
            color: #888;
            font-size: 14px;
            margin-left: 5px;
            flex-shrink: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }
        
        .leaderboard-score {
            color: #e2e8f0;
            font-size: 16px;
            font-weight: bold;
            margin-left: 10px;
            flex-shrink: 0;
        }

        /* Top bar styles */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: #000000;
            color: #FFFFFF;
            display: none; /* Hidden initially, shown during gameplay */
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 2000;
            border-bottom: 1px solid #333;
            font-family: 'VT323', monospace;
            font-size: 18px;
        }

        .top-bar.visible {
            display: flex;
        }

        .top-bar-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .current-score {
            color: #00FF00;
            font-weight: bold;
        }

        .high-score {
            color: #FFD700;
            font-weight: bold;
        }

        /* TOP 10 SCORES dropdown */
        .top10-dropdown {
            position: relative;
            display: inline-block;
        }

        .top10-button {
            background: #333;
            color: #FFFFFF;
            border: 1px solid #555;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 16px;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .top10-button:hover {
            background: #444;
        }

        .top10-content {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background: #000;
            border: 1px solid #555;
            border-radius: 3px;
            min-width: 300px;
            z-index: 3000;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }

        .top10-content.show {
            display: block;
        }

        .top10-header {
            color: #e2e8f0;
            font-size: 18px;
            font-weight: bold;
            padding: 10px;
            border-bottom: 1px solid #333;
            text-align: center;
        }

        .top10-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid #222;
            font-size: 16px;
            gap: 8px;
        }

        .top10-entry:last-child {
            border-bottom: none;
        }

        .top10-entry:hover {
            background: #111;
        }

        .top10-rank {
            color: #e2e8f0;
            font-weight: bold;
            width: 25px;
            text-align: right;
            flex-shrink: 0;
        }

        .top10-name-location {
            color: #e2e8f0;
            margin-left: 8px;
            flex-grow: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .top10-name {
            font-weight: bold;
        }

        .top10-location {
            color: #888;
            font-size: 14px;
            margin-left: 4px;
        }

        .top10-score {
            color: #00FF00;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            position: relative;
            background-color: #000000 !important; /* Force black background */
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000000 !important; /* Force black background */
            position: relative;
        }

        /* Popup message styles for canvas overlay messages */
        .popup-message {
            position: absolute;
            font-family: 'VT323', monospace;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0.8;
            transform: translateY(0);
            transition: all 0.5s ease-out;
            z-index: 1500;
            white-space: nowrap;
            text-shadow: 2px 2px 4px rgba(0,0,0,1);
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 4px 8px;
        }

        .popup-message.combat {
            color: #ff4444;
        }

        .popup-message.event {
            color: #ffdd44;
        }

        .popup-message.pickup {
            color: #44ff44;
        }

        .popup-message.progress {
            color: #4488ff;
        }

        .popup-message.fade-out {
            opacity: 0;
            transform: translateY(-20px);
        }

        .kill-message {
            font-family: 'VT323', monospace;
            color: #FFFFFF;
            font-size: 24px;
            text-align: right;
            opacity: 1.0;
            animation: fadeIn 0.3s ease-out;
            margin-bottom: 4px;
            padding: 8px 15px;
            border-radius: 6px;
            border-left: 4px solid #666;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kill-message.message-combat {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.25);
        }

        .kill-message.message-event {
            border-left-color: #ffd93d;
            background: rgba(255, 217, 61, 0.25);
        }

        .kill-message.message-pickup {
            border-left-color: #6bcf7f;
            background: rgba(107, 207, 127, 0.25);
        }

        .kill-message.message-progress {
            border-left-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.25);
        }

        .message-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .message-content {
            flex: 1;
        }

        .event-message {
            font-family: 'VT323', monospace;
            color: #00FF00;
            font-size: 24px;
            text-align: right;
            opacity: 1;
            animation: fadeIn 0.3s ease-out;
        }

        .event-messages-container {
            position: absolute;
            top: 50px;
            left: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 10px;
            z-index: 3;
            pointer-events: none;
        }

        .event-title {
            padding: 5px 15px;
            background-color: #000000;
            font-family: 'VT323', monospace;
            color: #e2e8f0;
            font-size: 24px;
            animation: fadeIn 0.3s ease-out;
        }

        .event-message {
            padding: 5px 15px;
            background-color: #000000;
            font-family: 'VT323', monospace;
            color: #e2e8f0;
            font-size: 20px;
            animation: fadeIn 0.3s ease-out;
            opacity: 0.8;
        }

        .kill-message.major-event {
            background: rgba(255, 217, 61, 0.2) !important;
            border-left: 4px solid #ffd93d !important;
            border-radius: 4px;
            color: #ffffff;
            font-weight: bold;
        }

        .kill-message .warning-symbol {
            color: #ffaa00;
            font-weight: bold;
            margin-right: 4px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 0.8; transform: translateY(0); }
        }

        .dialogue-message {
            color: #FFFFFF; /* White text */
            border-radius: 10px;
            padding: 8px 12px; /* Smaller padding */
            margin-bottom: 4px; /* Smaller line spacing */
            align-self: flex-end; /* Align to the right for player messages */
            max-width: 80%; /* Don't take full width */
            font-size: 1.2rem; /* Smaller text */
            line-height: 1.3; /* Smaller line height */
            word-wrap: break-word; /* Ensure long words break */
            /* Animation properties */
            opacity: 0;
            transform: translateY(100%);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out; /* Smooth transition for slide-in */
        }

        /* Activity log styles */
        .activity-log-entry {
            color: #FFFFFF;
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 4px;
            font-size: 1.3rem;
            line-height: 1.4;
            word-wrap: break-word;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .activity-log-entry.dimmed {
            opacity: 0.4;
        }

        .activity-log-entry .player-name {
            font-weight: bold;
        }

        .activity-log-entry .enemy-name {
            font-weight: bold;
        }

        .activity-log-entry .damage-comparison {
            font-size: 0.9rem;
            margin-top: 2px;
            opacity: 0.8;
        }

        canvas {
            background-color: #000000 !important; /* Force black background */
            border: none; /* Remove debug border */
            touch-action: none;
            display: block;
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .side-panel {
                width: 180px; /* Slightly narrower on medium screens */
            }
        }

        @media (max-width: 768px) {
            .game-wrapper {
                width: 100vw;
                height: 100vh;
                background-color: #000000 !important; /* Force black instead of CSS variable */
            }
            .game-container {
                width: 90vh;
                height: 100vh;
            }
            .message-area {
                right: 10px;
                width: 280px;
                height: 50vh;
                top: 25vh;
                background-color: rgba(0, 0, 0, 0.4);
                padding: 15px;
            }
            .leaderboard {
                left: 10px;
                top: 10px;
                width: 200px;
                height: 280px;
                background-color: rgba(0, 0, 0, 0.4);
            }
            canvas {
                width: 90vh;
                height: 100vh;
            }
        }
    </style>
</head>
<body>
    <div class="leaderboard" id="leaderboard">
        <h3>TOP 10 SCORES</h3>
        <div id="leaderboard-content">
            Loading scores...
        </div>
    </div>
    
    <!-- Top Bar -->
    <div class="top-bar" id="topBar">
        <div class="top-bar-left">
            <span class="current-score">SCORE: <span id="currentScore">0</span></span>
        </div>
        <div class="top-bar-right">
            <div class="top10-dropdown">
                <button class="top10-button" onclick="toggleTop10()">TOP 10 SCORES ▼</button>
                <div class="top10-content" id="top10Content">
                    <div class="top10-header">TOP 10 SCORES</div>
                    <div id="top10List">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="game-wrapper">
        <div id="gameContainer" class="game-container">
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>

    <script>
        // Geolocation and Leaderboard variables
        let playerLocation = { city: 'Unknown', country: 'Unknown' };
        let playerName = '';
        let leaderboard = [];
        
        // Game constants
        const CANVAS_WIDTH_INITIAL = 730; // Initial canvas width for logical scaling
        const CANVAS_HEIGHT_INITIAL = 730; // Initial canvas height for logical scaling

        const MAX_VISIBLE_TILES_LEVEL1 = 8; // Level 1: 8 tiles visible = closer view
        const MIN_VISIBLE_TILES_MAX_LEVEL = 18; // Max level: 18 tiles visible = farther view  
        const ZOOM_LEVELS_EFFECTIVE = 30;

        // Score box constants
        const SCORE_BOX_WIDTH = 120;
        const SCORE_BOX_HEIGHT = 25;  // Made narrower
        const SCORE_BOX_PADDING = 3;  // Reduced padding
        const SCORE_BOX_MARGIN = 0;

        // Health-based visual scaling constants (now act as thresholds, not caps)
        const PLAYER_VISUAL_HEALTH_THRESHOLD = 73;
        const ENEMY_VISUAL_HEALTH_THRESHOLD = 73;
        const MIN_HEALTH_FOR_VISUAL_EFFECTS = 1;
        const MIN_OPACITY_AT_LOW_HEALTH = 0.9; // Increased starting opacity again
        // New constants for Flow bias
        const BASE_FLOW_FOR_BIAS = 1.0;
        const FLOW_BIAS_STRENGTH = 0.5;

        // New constants for player death animation
        const PLAYER_DEATH_PARTICLE_COUNT = 50;
        const PLAYER_DEATH_PICKUP_VALUE_PER_CHUNK = 1;
        const PLAYER_DEATH_EXPLOSION_DURATION = 3000;
        const PLAYER_DEATH_PARTICLE_SPREAD_FACTOR = 2.5;

        // New constants for explosion and pickup scattering based on damage
        const ENEMY_DEATH_EXPLOSION_BASE_SPREAD = 1.0;
        const ENEMY_DEATH_EXPLOSION_DAMAGE_SPREAD_MULTIPLIER = 0.1; // Adjust this value to control how much damage affects spread
        const PICKUP_SCATTER_BASE_SPREAD = 1.5; // Original value for pickup scatter
        const PICKUP_SCATTER_DAMAGE_MULTIPLIER = 0.15; // Adjust this value to control how much damage affects pickup scatter

        // Mathematical symbols for player death
        const MATH_SYMBOLS = ['+', '-', '*', '/', '=', '>', '<', '%', '&', '!', '?', '^', '~', '|', '(', ')', '[', ']', '{', '}'];

        // World progression system
        const WORLDS = {
            1: {
                name: "Foundational Chambers",
                theme: "basic",
                description: "Simple rectangular rooms where mathematics begins",
                colors: {
                    floor: '#666666', // Clear medium gray floor 
                    wall: '#000000',  // Pure black walls  
                    stairs: '#38a169', // Green exit
                    player: '#0066FF', // Blue player
                    enemy: '#FF4444'   // Red enemy
                },
                mapGenerator: 'generateBasicMap',
                unlockRequirement: 0 // Always available
            }
        };        // World progression variables
        let currentWorld = 1;
        let unlockedWorlds = [1]; // World 1 is always unlocked
        let totalPlayerScore = 0; // Accumulated score across all runs

        // Tile size calculation

        // Tile types
        const TILE_WALL = 0;
        const TILE_FLOOR = 1;
        const TILE_STAIRS = 2;

        // Colors (consistent across gameplay and UI)
        let COLOR_WALL = '#4A3728'; // Brown base color for walls - distinct when lit
        let COLOR_FLOOR = '#666666'; // Clear medium gray for playable floor tiles  
        let FIXED_COLOR_PLAYER = '#0066FF'; // Blue player color
        let FIXED_COLOR_STAIRS = '#38a169'; // Green stairs/exits
        let FIXED_COLOR_ENEMY = '#FF4444'; // Red enemies
        const VINTAGE_GREEN = '#38a169';

        // Name generation utilities from namegen.html - exact implementation from namegen.html
        function hasVowel(str) {
          return /[aeiouyAEIOUY]/.test(str);
        }

        // Massively Expanded Phoneme lists from namegen.html
        const commonWordPhonemes = {
          start: [
            // Pure vowel starts
            'A', 'E', 'I', 'O', 'U', 'Ya', 'Ye', 'Yo', 'Yu', 'Ae', 'Io', 'Ou', 'Ui', 'Au', 'Ei',
            // Common Object/Concept Starts
            'Air', 'Arm', 'Box', 'Book', 'Card', 'Chair', 'Cloud', 'Desk', 'Door', 'Dust', 'Earth', 'Fire', 'Fork', 'Glass',
            'Hand', 'Head', 'Home', 'Hour', 'Key', 'Lamp', 'Leaf', 'Light', 'Line', 'Lock', 'Moon', 'Moun', 'Name', 'Page',
            'Pen', 'Pipe', 'Plan', 'Plas', 'Plate', 'Rain', 'Road', 'Rock', 'Room', 'Rope', 'Sand', 'Ship', 'Shoe', 'Sky',
            'Soap', 'Sofa', 'Star', 'Stee', 'Ston', 'Sun', 'Tab', 'Tail', 'Time', 'Tool', 'Top', 'Tree', 'Wall', 'Wat',
            'Whee', 'Wind', 'Wire', 'Wood', 'Word', 'Bell', 'Bowl', 'Brush', 'Cable', 'Chain', 'Coin', 'Comb', 'Couch', 'Cup',
            'Curtain', 'Dish', 'Drawer', 'Drum', 'Fence', 'Flag', 'Flute', 'Frame', 'Glove', 'Grain', 'Grape', 'Guard', 'Harp',
            'Hinge', 'Hole', 'Hook', 'Horn', 'Jacket', 'Jar', 'Jewel', 'Joint', 'Juice', 'Kettle', 'Kite', 'Knob', 'Lace', 'Ladder',
            'Lake', 'Lens', 'Lever', 'Lid', 'Loom', 'Loud', 'Magnet', 'Mask', 'Match', 'Metal', 'Meter', 'Mirror', 'Mist', 'Mop',
            'Mug', 'Nail', 'Net', 'Nook', 'Nut', 'Oar', 'Pad', 'Paint', 'Pan', 'Path', 'Pearl', 'Pillow', 'Pin', 'Plane',
            'Pond', 'Pool', 'Pot', 'Pouch', 'Pound', 'Pulp', 'Pump', 'Rack', 'Rail', 'Rake', 'Ramp', 'Ring', 'Rod', 'Roof',
            'Root', 'Rug', 'Ruler', 'Sack', 'Scale', 'Scoop', 'Screen', 'Seal', 'Seat', 'Shade', 'Shelf', 'Shell', 'Shield', 'Sign',
            'Slab', 'Slate', 'Sleeve', 'Slide', 'Slot', 'Smoke', 'Snare', 'Snow', 'Spade', 'Spoon', 'Spot', 'Spout', 'Spring',
            'Spool', 'Stair', 'Stamp', 'Stick', 'Stool', 'Strap', 'Straw', 'Stream', 'String', 'Strip', 'Stud', 'Swarm', 'Swing',
            'Switch', 'Table', 'Tank', 'Tape', 'Target', 'Thorn', 'Thread', 'Thumb', 'Tile', 'Tong', 'Torch', 'Tower', 'Track',
            'Train', 'Trap', 'Tray', 'Trowel', 'Trunk', 'Tube', 'Tug', 'Tune', 'Turf', 'Twine', 'Unit', 'Urn', 'Valve', 'Vase',
            'Veil', 'Vent', 'Vest', 'Vial', 'Vise', 'Wagon', 'Web', 'Wedge', 'Whale', 'Whirl', 'Wick', 'Wing', 'Wrench', 'Yoke',
            'Zest', 'Zone', 'Zorb',
            // Company Name Starts
            'Aero', 'Airb', 'Alib', 'Amaz', 'Amgen', 'Anhe', 'Astra', 'Audi', 'Baidu', 'Bayer', 'Berk', 'Black', 'Boe',
            'Canon', 'Cisco', 'Coca', 'Comc', 'Daim', 'Dell', 'Disn', 'DuPont', 'Face', 'Fid', 'Ford',
            'Gen', 'Gile', 'Goog', 'Hon', 'HP', 'Huan', 'Hyun', 'Intel', 'Master',
            'McDon', 'Merck', 'Meta', 'Micro', 'Neste', 'Nike', 'Nint', 'Oracle', 'Pana', 'Peps', 'Pfiz', 'Phil',
            'Qual', 'Riche', 'Roya', 'Sam', 'Siem', 'Spot', 'Starb', 'Suba', 'Targ', 'Tenc', 'Tes', 'Teva', 'Toyota',
            'Uber', 'Unile', 'Volks', 'Walm', 'Walt', 'Xiaom', 'Yaho', 'Yelp', 'Zara', 'Zoom', 'Zurich',
            // Country/City Name Starts
            'Aba', 'Abu', 'Accra', 'Adel', 'Addis', 'Agra', 'Algiers', 'Amman', 'Amst', 'Anka', 'Arg', 'Ashg', 'Astana', 'Ath',
            'Aus', 'Baku', 'Ban', 'Bang', 'Bei', 'Beir', 'Belg', 'Belm', 'Ber', 'Bog', 'Boha', 'Bol', 'Bra', 'Bras', 'Brat',
            'Braz', 'Bru', 'Buda', 'Bue', 'Bukh', 'Cai', 'Canb', 'Cara', 'Casab', 'Che', 'Chi', 'Copen', 'Col', 'Cona', 'Cop',
            'Coru', 'Cro', 'Daka', 'Dam', 'Dar', 'Del', 'Den', 'Dhaka', 'Doha', 'Dub', 'Edin', 'Egy', 'Eth', 'Fin', 'Fra',
            'Fuji', 'Gab', 'Gabo', 'Ger', 'Gha', 'Gree', 'Guat', 'Hano', 'Har', 'Hel', 'Ho', 'Hon', 'Hung', 'Ice', 'Ind',
            'Ira', 'Ire', 'Isr', 'Ista', 'Ita', 'Jak', 'Jam', 'Jap', 'Jeru', 'Johan', 'Jor', 'Kab', 'Kam', 'Kar', 'Kaz',
            'Ken', 'Kha', 'Kie', 'Kin', 'Kish', 'Kua', 'Kuw', 'Lag', 'Lao', 'Leb', 'Lis', 'Ljub', 'Lon', 'Los', 'Luanda',
            'Madr', 'Mal', 'Man', 'Manil', 'Mapu', 'Mex', 'Min', 'Monro', 'Monte', 'Mos', 'Mumb', 'Mus', 'Nair', 'Nass', 'Nep',
            'New', 'Nic', 'Nis', 'Nor', 'Os', 'Ott', 'Pak', 'Pal', 'Pan', 'Par', 'Peki', 'Peru', 'Phil', 'Pol', 'Port',
            'Prag', 'Pret', 'Puer', 'Qat', 'Quito', 'Rab', 'Rey', 'Riga', 'Riy', 'Rom', 'Rus', 'San', 'Sao', 'Sar', 'Sau',
            'Scot', 'Seo', 'Ser', 'Sing', 'Sko', 'Slo', 'Sof', 'Sou', 'Spa', 'Sri', 'Stoc', 'Sud', 'Swe', 'Swit', 'Syd',
            'Syr', 'Tai', 'Tan', 'Teh', 'Thai', 'Thi', 'Tir', 'Tok', 'Trip', 'Tun', 'Tur', 'Ugan', 'Ukra', 'Uni', 'Uru',
            'Val', 'Ven', 'Vie', 'Viet', 'Vil', 'War', 'Was', 'Wel', 'Wien', 'Yem', 'Zag', 'Zim'
          ].filter(hasVowel),

          middle: [
            'a', 'e', 'i', 'o', 'u', 'y', 'an', 'en', 'in', 'on', 'un', 'am', 'em', 'im', 'om', 'um',
            'ar', 'er', 'ir', 'or', 'ur', 'as', 'es', 'is', 'os', 'us', 'at', 'et', 'it', 'ot', 'ut',
            'ax', 'ex', 'ix', 'ox', 'ux', 'ay', 'ey', 'oy', 'ow', 'ou', 'ea', 'ee', 'ie', 'oa', 'oo'
          ],

          end: [
            'a', 'e', 'i', 'o', 'u', 'y', 'ah', 'al', 'an', 'ar', 'as', 'at', 'ay', 'el', 'en', 'er',
            'es', 'et', 'il', 'in', 'ir', 'is', 'it', 'ol', 'on', 'or', 'os', 'ot', 'ul', 'un', 'ur',
            'us', 'ut', 'ice', 'ide', 'ile', 'ine', 'ing', 'ion', 'ive', 'ize', 'ode', 'oke', 'ole',
            'ome', 'one', 'ore', 'ose', 'ote', 'ove', 'owl', 'own', 'ule', 'une', 'ure'
          ].filter(hasVowel)
        };

        function randomFrom(array) {
          if (array.length === 0) return '';
          return array[Math.floor(Math.random() * array.length)];
        }

        function buildName(phonemes, syllables = 3) {
          let name = '';
          if (syllables <= 0) return '';

          // Always start with a 'start' phoneme
          name += randomFrom(phonemes.start);

          // Add 'middle' phonemes for intermediate syllables
          for (let i = 1; i < syllables - 1; i++) {
            name += randomFrom(phonemes.middle);
            // 20% chance to repeat a middle phoneme
            if (Math.random() < 0.2 && i < syllables - 2) {
              name += randomFrom(phonemes.middle);
            }
          }

          // End with an 'end' phoneme for the last syllable, if more than 1 syllable
          if (syllables > 1) {
                name += randomFrom(phonemes.end);
            }

            // Capitalize the first letter of the generated name
            return name.charAt(0).toUpperCase() + name.slice(1);
        }

        function generateAgentName() {
          let firstName, lastName;
          const MAX_COMBINED_LENGTH = 9; // Maximum total characters excluding the space
          const MIN_COMBINED_LENGTH = 5; // Minimum total characters excluding the space

          do {
            // Randomly choose 1 or 2 syllables for the first name
            const firstSyllables = Math.floor(Math.random() * 2) + 1; // Generates 1 or 2
            // Randomly choose 1 or 2 syllables for the last name
            const lastSyllables = Math.floor(Math.random() * 2) + 1; // Generates 1 or 2

            firstName = buildName(commonWordPhonemes, firstSyllables);
            lastName = buildName(commonWordPhonemes, lastSyllables);

          } while (firstName.length + lastName.length > MAX_COMBINED_LENGTH ||
                   firstName.length + lastName.length < MIN_COMBINED_LENGTH ||
                   !hasVowel(firstName) || !hasVowel(lastName));

          return `${firstName} ${lastName}`;
        }

        // Game state variables are declared below with 'let' and initialized in initGame()
        // Player and enemy objects now include thrust animation properties

        // Activity log state
        let activityLog = [];
        const MAX_ACTIVITY_LOG_ENTRIES = 10;

        // Hair avatar system
        const HAIR_STYLES = [
            'short',      // 0 - Short cropped
            'medium',     // 1 - Medium length
            'long',       // 2 - Long straight
            'curly',      // 3 - Curly/wavy
            'spiky',      // 4 - Spiky punk style
            'bald',       // 5 - Completely bald
            'mohawk',     // 6 - Mohawk style
            'ponytail',   // 7 - Ponytail
            'afro',       // 8 - Afro style
            'buzz'        // 9 - Buzz cut
        ];

        const HAIR_COLORS = [
            '#8B4513',    // 0 - Brown
            '#000000',    // 1 - Black
            '#FFD700',    // 2 - Blonde
            '#B22222',    // 3 - Red
            '#708090'     // 4 - Gray/Silver
        ];

        // Generate unique hair for an agent
        function generateHairStyle(agentId) {
            // Use agent ID to create consistent but varied hair
            const hash = agentId.toString().split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0);
            
            const styleIndex = Math.abs(hash) % HAIR_STYLES.length;
            const colorIndex = Math.abs(hash >> 8) % HAIR_COLORS.length;
            
            return {
                style: HAIR_STYLES[styleIndex],
                color: HAIR_COLORS[colorIndex],
                styleIndex: styleIndex,
                colorIndex: colorIndex
            };
        }

        // Head shape and color variations
        const HEAD_SHAPES = [
            'oval',      // 0 - Classic oval
            'round',     // 1 - Round/circular
            'square',    // 2 - Square/angular
            'diamond',   // 3 - Diamond shape
            'heart',     // 4 - Heart/triangular
            'long',      // 5 - Long/rectangular
            'wide',      // 6 - Wide/horizontal oval
            'pear',      // 7 - Pear shape (narrow top)
            'inverted'   // 8 - Inverted triangle
        ];

        const SKIN_COLORS = [
            '#FDBCB4',   // 0 - Light pink
            '#E8A07C',   // 1 - Light tan
            '#D4915C',   // 2 - Medium tan
            '#C87941',   // 3 - Darker tan
            '#A05A2C',   // 4 - Brown
            '#8B4513',   // 5 - Dark brown
            '#654321',   // 6 - Very dark brown
            '#FFE0BD',   // 7 - Very light peach
            '#F5DEB3',   // 8 - Wheat
            '#DEB887',   // 9 - Burlywood
            '#D2B48C',   // 10 - Tan
            '#BC9A6A'    // 11 - Khaki
        ];

        const HEAD_SIZES = [
            0.7,   // 0 - Small head
            0.75,  // 1 - Small-medium
            0.8,   // 2 - Medium
            0.85,  // 3 - Medium-large
            0.9    // 4 - Large head
        ];

        // Generate unique head for an agent
        function generateHeadStyle(agentId) {
            // Use agent ID to create consistent but varied head
            const hash = agentId.toString().split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0);
            
            const shapeIndex = Math.abs(hash >> 16) % HEAD_SHAPES.length;
            const skinIndex = Math.abs(hash >> 24) % SKIN_COLORS.length;
            const sizeIndex = Math.abs(hash >> 12) % HEAD_SIZES.length;
            
            return {
                shape: HEAD_SHAPES[shapeIndex],
                color: SKIN_COLORS[skinIndex],
                size: HEAD_SIZES[sizeIndex],
                shapeIndex: shapeIndex,
                skinIndex: skinIndex,
                sizeIndex: sizeIndex
            };
        }

        // Draw head on an agent (behind hair)
        function drawHead(ctx, x, y, size, headData) {
            if (!headData) return;
            
            ctx.save();
            ctx.fillStyle = headData.color;
            ctx.strokeStyle = headData.color;
            ctx.globalAlpha = 0.9;
            
            const centerX = x + size / 2;
            const centerY = y + size / 2;
            const headSize = size * headData.size;
            const headWidth = size * 0.9; // Make width almost touch sides (90% of square width)
            const headHeight = headSize;
            
            switch (headData.shape) {
                case 'oval':
                    // Classic oval head
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, headWidth * 0.45, headHeight * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'round':
                    // Round/circular head - use width for radius to make it wider
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, headWidth * 0.45, headWidth * 0.45, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'square':
                    // Square/angular head - use full width
                    const squareWidth = headWidth * 0.9;
                    const squareHeight = headSize * 0.8;
                    ctx.fillRect(centerX - squareWidth/2, centerY - squareHeight/2, squareWidth, squareHeight);
                    break;
                    
                case 'diamond':
                    // Diamond shape head - wider diamond
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - headHeight * 0.4);
                    ctx.lineTo(centerX + headWidth * 0.4, centerY);
                    ctx.lineTo(centerX, centerY + headHeight * 0.4);
                    ctx.lineTo(centerX - headWidth * 0.4, centerY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'heart':
                    // Heart/triangular head (wide forehead, narrow chin) - extra wide
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + headHeight * 0.4);
                    ctx.lineTo(centerX - headWidth * 0.45, centerY - headHeight * 0.2);
                    ctx.lineTo(centerX - headWidth * 0.25, centerY - headHeight * 0.4);
                    ctx.lineTo(centerX + headWidth * 0.25, centerY - headHeight * 0.4);
                    ctx.lineTo(centerX + headWidth * 0.45, centerY - headHeight * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'long':
                    // Long/rectangular head - wider but still long
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, headWidth * 0.4, headHeight * 0.55, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'wide':
                    // Wide/horizontal oval head - extra wide
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, headWidth * 0.47, headHeight * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'pear':
                    // Pear shape (narrow forehead, wide jaw) - wider jaw
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY - headHeight * 0.1, headWidth * 0.3, headHeight * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY + headHeight * 0.15, headWidth * 0.45, headHeight * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'inverted':
                    // Inverted triangle (wide forehead, narrow chin) - extra wide forehead
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + headHeight * 0.4);
                    ctx.lineTo(centerX - headWidth * 0.47, centerY - headHeight * 0.4);
                    ctx.lineTo(centerX + headWidth * 0.47, centerY - headHeight * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    break;
            }
            
            ctx.restore();
        }

        // Generate eye style based on agent ID (deterministic)
        function generateEyeStyle(agentId) {
            const eyeShapes = [
                // Classic shapes
                'round', 'almond', 'oval', 'narrow', 'wide',
                // Angular shapes  
                'angular', 'diamond', 'hexagon', 'triangle', 'square',
                // Expression shapes
                'droopy', 'upturned', 'sleepy', 'alert', 'surprised',
                // Exotic shapes
                'cat', 'serpent', 'crescent', 'teardrop', 'flame',
                // Geometric shapes
                'star', 'cross', 'heart', 'hourglass', 'bowtie',
                // Fantasy shapes
                'moon', 'eye_of_ra', 'mystic', 'void', 'spiral',
                // Complex shapes
                'compound', 'split', 'layered', 'winged', 'thorned'
            ];
            const eyeStyles = [
                'solid', 'gradient', 'outlined', 'double', 'striped',
                'dotted', 'glowing', 'shadowed', 'metallic', 'crystalline',
                'smoky', 'flame', 'starry', 'spiral', 'mosaic'
            ];
            const eyeColors = [
                '#8B4513', '#654321', '#2F1B14', '#1C1C1C', '#4A4A4A', 
                '#228B22', '#006400', '#4169E1', '#191970', '#800080',
                '#B8860B', '#FF8C00', '#DC143C', '#FF1493', '#00CED1',
                '#32CD32', '#FFD700', '#FF4500', '#9932CC', '#8B008B'
            ];
            
            // Use agent ID as seed for consistent generation
            const seed = agentId || Math.floor(Math.random() * 10000);
            
            const shapeIndex = seed % eyeShapes.length;
            const styleIndex = Math.floor(seed / 10) % eyeStyles.length;
            const colorIndex = Math.floor(seed / 100) % eyeColors.length;
            
            return {
                shape: eyeShapes[shapeIndex],
                style: eyeStyles[styleIndex],
                color: eyeColors[colorIndex],
                shapeIndex: shapeIndex,
                styleIndex: styleIndex,
                colorIndex: colorIndex
            };
        }

        // Draw eyes on an agent (over head, under hair)
        function drawEyes(ctx, x, y, size, eyeData, headData, characterX = null, characterY = null) {
            if (!eyeData || !headData) return;
            
            ctx.save();
            ctx.fillStyle = eyeData.color;
            ctx.globalAlpha = 0.9;
            
            const centerX = x + size / 2;
            const centerY = y + size / 2;
            const eyeSize = size * 0.12; // Base eye size
            const eyeSpacing = size * 0.25; // Distance between eyes
            const pupilRadius = eyeSize * 0.35; // Hollow center for pupils
            
            // Position eyes based on head shape
            let eyeOffsetY = -size * 0.1; // Default eye position
            if (headData.shape === 'long') eyeOffsetY = -size * 0.15;
            if (headData.shape === 'wide') eyeOffsetY = -size * 0.05;
            if (headData.shape === 'pear') eyeOffsetY = -size * 0.15;
            
            const leftEyeX = centerX - eyeSpacing;
            const rightEyeX = centerX + eyeSpacing;
            const eyeY = centerY + eyeOffsetY;
            
            // Draw both eyes with the same shape and style, and add pupils looking toward player
            drawSingleEye(ctx, leftEyeX, eyeY, eyeSize, pupilRadius, eyeData.shape, eyeData.style, eyeData.color, characterX, characterY);
            drawSingleEye(ctx, rightEyeX, eyeY, eyeSize, pupilRadius, eyeData.shape, eyeData.style, eyeData.color, characterX, characterY);
            
            ctx.restore();
        }

        // Draw individual eye shape with hollow center and various styles
        function drawSingleEye(ctx, x, y, size, pupilRadius, shape, style, color, characterX = null, characterY = null) {
            ctx.save();
            
            // Apply the appropriate style
            switch (style) {
                case 'solid':
                    drawSolidEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'gradient':
                    drawGradientEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'outlined':
                    drawOutlinedEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'double':
                    drawDoubleEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'striped':
                    drawStripedEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'dotted':
                    drawDottedEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'glowing':
                    drawGlowingEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'shadowed':
                    drawShadowedEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'metallic':
                    drawMetallicEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'crystalline':
                    drawCrystallineEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'smoky':
                    drawSmokyEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'flame':
                    drawFlameEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'starry':
                    drawStarryEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'spiral':
                    drawSpiralEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
                case 'mosaic':
                    drawMosaicEye(ctx, x, y, size, pupilRadius, shape, color);
                    break;
            }
            
            // Add outline to ALL eyes regardless of style
            ctx.save();
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = Math.max(1, size * 0.05); // Adaptive outline thickness
            ctx.stroke();
            ctx.restore();
            
            // Draw pupil looking toward player
            if (characterX !== null && characterY !== null && player) {
                drawPupilLookingAtPlayer(ctx, x, y, pupilRadius, characterX, characterY);
            }
            
            ctx.restore();
        }

        // Helper function to create the basic eye shape path
        function createEyeShapePath(ctx, x, y, size, shape) {
            ctx.beginPath();
            
            switch (shape) {
                // === CLASSIC SHAPES ===
                case 'round':
                    ctx.ellipse(x, y, size, size, 0, 0, Math.PI * 2);
                    break;
                case 'almond':
                    ctx.ellipse(x, y, size * 1.2, size * 0.7, 0, 0, Math.PI * 2);
                    break;
                case 'oval':
                    ctx.ellipse(x, y, size * 1.1, size * 0.8, 0, 0, Math.PI * 2);
                    break;
                case 'narrow':
                    ctx.ellipse(x, y, size * 1.4, size * 0.5, 0, 0, Math.PI * 2);
                    break;
                case 'wide':
                    ctx.ellipse(x, y, size * 1.5, size * 0.8, 0, 0, Math.PI * 2);
                    break;
                
                // === ANGULAR SHAPES ===
                case 'angular':
                    ctx.moveTo(x - size * 1.2, y);
                    ctx.lineTo(x, y - size * 0.7);
                    ctx.lineTo(x + size * 1.2, y);
                    ctx.lineTo(x, y + size * 0.7);
                    ctx.closePath();
                    break;
                case 'diamond':
                    ctx.moveTo(x, y - size);
                    ctx.lineTo(x + size * 0.8, y);
                    ctx.lineTo(x, y + size);
                    ctx.lineTo(x - size * 0.8, y);
                    ctx.closePath();
                    break;
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI) / 3;
                        const px = x + Math.cos(angle) * size * 0.9;
                        const py = y + Math.sin(angle) * size * 0.9;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    break;
                case 'triangle':
                    ctx.moveTo(x, y - size * 0.8);
                    ctx.lineTo(x + size * 1.1, y + size * 0.8);
                    ctx.lineTo(x - size * 1.1, y + size * 0.8);
                    ctx.closePath();
                    break;
                case 'square':
                    ctx.rect(x - size * 0.8, y - size * 0.8, size * 1.6, size * 1.6);
                    break;
                
                // === EXPRESSION SHAPES ===
                case 'droopy':
                    ctx.ellipse(x, y, size * 1.1, size * 0.6, -0.2, 0, Math.PI * 2);
                    break;
                case 'upturned':
                    ctx.ellipse(x, y, size * 1.1, size * 0.6, 0.2, 0, Math.PI * 2);
                    break;
                case 'sleepy':
                    ctx.ellipse(x, y, size * 1.3, size * 0.4, 0, 0, Math.PI * 2);
                    break;
                case 'alert':
                    ctx.ellipse(x, y, size * 0.9, size * 1.1, 0, 0, Math.PI * 2);
                    break;
                case 'surprised':
                    ctx.ellipse(x, y, size * 1.2, size * 1.2, 0, 0, Math.PI * 2);
                    break;
                
                // === EXOTIC SHAPES ===
                case 'cat':
                    ctx.ellipse(x, y, size * 1.3, size * 0.6, 0.3, 0, Math.PI * 2);
                    break;
                case 'serpent':
                    ctx.ellipse(x, y, size * 1.6, size * 0.4, 0, 0, Math.PI * 2);
                    break;
                case 'crescent':
                    ctx.arc(x, y, size, 0, Math.PI);
                    ctx.arc(x, y - size * 0.3, size * 0.7, Math.PI, 0, true);
                    break;
                case 'teardrop':
                    ctx.ellipse(x, y, size * 0.8, size * 1.1, 0, 0, Math.PI * 2);
                    ctx.moveTo(x, y - size * 1.1);
                    ctx.quadraticCurveTo(x + size * 0.3, y - size * 1.5, x, y - size * 1.8);
                    ctx.quadraticCurveTo(x - size * 0.3, y - size * 1.5, x, y - size * 1.1);
                    break;
                case 'flame':
                    ctx.ellipse(x, y, size * 0.9, size * 1.2, 0, 0, Math.PI * 2);
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                        const flameX = x + Math.cos(angle) * size * 1.3;
                        const flameY = y + Math.sin(angle) * size * 1.3;
                        ctx.moveTo(x, y);
                        ctx.lineTo(flameX, flameY);
                    }
                    break;
                
                // === GEOMETRIC SHAPES ===
                case 'star':
                    for (let i = 0; i < 5; i++) {
                        const outerAngle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                        const innerAngle = ((i + 0.5) * Math.PI * 2) / 5 - Math.PI / 2;
                        const outerX = x + Math.cos(outerAngle) * size;
                        const outerY = y + Math.sin(outerAngle) * size;
                        const innerX = x + Math.cos(innerAngle) * size * 0.4;
                        const innerY = y + Math.sin(innerAngle) * size * 0.4;
                        if (i === 0) ctx.moveTo(outerX, outerY);
                        else ctx.lineTo(outerX, outerY);
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.closePath();
                    break;
                case 'cross':
                    ctx.rect(x - size * 1.2, y - size * 0.3, size * 2.4, size * 0.6);
                    ctx.rect(x - size * 0.3, y - size * 1.2, size * 0.6, size * 2.4);
                    break;
                case 'heart':
                    ctx.moveTo(x, y + size * 0.5);
                    ctx.bezierCurveTo(x - size * 1.2, y - size * 0.5, x - size * 0.6, y - size * 1.2, x, y - size * 0.3);
                    ctx.bezierCurveTo(x + size * 0.6, y - size * 1.2, x + size * 1.2, y - size * 0.5, x, y + size * 0.5);
                    break;
                case 'hourglass':
                    ctx.moveTo(x - size, y - size);
                    ctx.lineTo(x + size, y - size);
                    ctx.lineTo(x + size * 0.3, y);
                    ctx.lineTo(x + size, y + size);
                    ctx.lineTo(x - size, y + size);
                    ctx.lineTo(x - size * 0.3, y);
                    ctx.closePath();
                    break;
                case 'bowtie':
                    ctx.moveTo(x - size * 1.2, y - size * 0.6);
                    ctx.lineTo(x, y);
                    ctx.lineTo(x - size * 1.2, y + size * 0.6);
                    ctx.lineTo(x - size * 0.8, y + size * 0.6);
                    ctx.lineTo(x - size * 0.2, y);
                    ctx.lineTo(x - size * 0.8, y - size * 0.6);
                    ctx.closePath();
                    ctx.moveTo(x + size * 1.2, y - size * 0.6);
                    ctx.lineTo(x, y);
                    ctx.lineTo(x + size * 1.2, y + size * 0.6);
                    ctx.lineTo(x + size * 0.8, y + size * 0.6);
                    ctx.lineTo(x + size * 0.2, y);
                    ctx.lineTo(x + size * 0.8, y - size * 0.6);
                    ctx.closePath();
                    break;
                
                // === FANTASY SHAPES ===
                case 'moon':
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.arc(x + size * 0.5, y, size * 0.8, 0, Math.PI * 2, true);
                    break;
                case 'eye_of_ra':
                    ctx.ellipse(x, y, size * 1.3, size * 0.7, 0, 0, Math.PI * 2);
                    ctx.moveTo(x - size * 1.3, y);
                    ctx.quadraticCurveTo(x - size * 1.8, y - size * 0.5, x - size * 1.5, y - size * 0.8);
                    ctx.moveTo(x + size * 1.3, y);
                    ctx.quadraticCurveTo(x + size * 1.8, y + size * 0.5, x + size * 1.5, y + size * 0.8);
                    break;
                case 'mystic':
                    ctx.ellipse(x, y, size, size * 0.6, 0, 0, Math.PI * 2);
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI * 2) / 8;
                        const rayX = x + Math.cos(angle) * size * 1.5;
                        const rayY = y + Math.sin(angle) * size * 1.5;
                        ctx.moveTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size);
                        ctx.lineTo(rayX, rayY);
                    }
                    break;
                case 'void':
                    for (let ring = 0; ring < 3; ring++) {
                        ctx.ellipse(x, y, size * (1 - ring * 0.3), size * (1 - ring * 0.3), 0, 0, Math.PI * 2);
                    }
                    break;
                case 'spiral':
                    let spiralRadius = size;
                    let spiralAngle = 0;
                    ctx.moveTo(x + spiralRadius, y);
                    for (let i = 0; i < 50; i++) {
                        spiralAngle += 0.3;
                        spiralRadius -= size * 0.02;
                        const spiralX = x + Math.cos(spiralAngle) * spiralRadius;
                        const spiralY = y + Math.sin(spiralAngle) * spiralRadius;
                        ctx.lineTo(spiralX, spiralY);
                    }
                    break;
                
                // === COMPLEX SHAPES ===
                case 'compound':
                    ctx.ellipse(x, y, size * 0.8, size * 0.8, 0, 0, Math.PI * 2);
                    ctx.ellipse(x - size * 0.5, y - size * 0.3, size * 0.4, size * 0.4, 0, 0, Math.PI * 2);
                    ctx.ellipse(x + size * 0.5, y - size * 0.3, size * 0.4, size * 0.4, 0, 0, Math.PI * 2);
                    break;
                case 'split':
                    ctx.ellipse(x - size * 0.3, y, size * 0.7, size, 0, 0, Math.PI * 2);
                    ctx.ellipse(x + size * 0.3, y, size * 0.7, size, 0, 0, Math.PI * 2);
                    break;
                case 'layered':
                    ctx.ellipse(x, y, size * 1.2, size * 0.8, 0, 0, Math.PI * 2);
                    ctx.ellipse(x, y, size * 0.8, size * 0.5, 0, 0, Math.PI * 2);
                    ctx.ellipse(x, y, size * 0.4, size * 0.3, 0, 0, Math.PI * 2);
                    break;
                case 'winged':
                    ctx.ellipse(x, y, size, size * 0.7, 0, 0, Math.PI * 2);
                    // Left wing
                    ctx.moveTo(x - size, y);
                    ctx.quadraticCurveTo(x - size * 1.8, y - size * 0.8, x - size * 1.5, y + size * 0.3);
                    // Right wing  
                    ctx.moveTo(x + size, y);
                    ctx.quadraticCurveTo(x + size * 1.8, y - size * 0.8, x + size * 1.5, y + size * 0.3);
                    break;
                case 'thorned':
                    ctx.ellipse(x, y, size * 0.9, size * 0.9, 0, 0, Math.PI * 2);
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI * 2) / 6;
                        const thornX = x + Math.cos(angle) * size * 0.9;
                        const thornY = y + Math.sin(angle) * size * 0.9;
                        const thornTipX = x + Math.cos(angle) * size * 1.4;
                        const thornTipY = y + Math.sin(angle) * size * 1.4;
                        ctx.moveTo(thornX, thornY);
                        ctx.lineTo(thornTipX, thornTipY);
                    }
                    break;
                
                default:
                    // Fallback to round
                    ctx.ellipse(x, y, size, size, 0, 0, Math.PI * 2);
                    break;
            }
        }

        // Different eye style implementations
        function drawSolidEye(ctx, x, y, size, pupilRadius, shape, color) {
            ctx.fillStyle = color;
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            // Pupil handling moved to drawSingleEye
        }

        function drawGradientEye(ctx, x, y, size, pupilRadius, shape, color) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * 1.5);
            gradient.addColorStop(0, lightenColor(color, 0.5));
            gradient.addColorStop(1, color);
            ctx.fillStyle = gradient;
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            // Pupil handling moved to drawSingleEye
        }

        function drawOutlinedEye(ctx, x, y, size, pupilRadius, shape, color) {
            // Fill with lighter version
            ctx.fillStyle = lightenColor(color, 0.3);
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            
            // Add thick outline
            ctx.strokeStyle = color;
            ctx.lineWidth = size * 0.15;
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.stroke();
            // Pupil handling moved to drawSingleEye
        }

        function drawDoubleEye(ctx, x, y, size, pupilRadius, shape, color) {
            // Outer eye
            ctx.fillStyle = color;
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            
            // Inner eye
            ctx.fillStyle = lightenColor(color, 0.4);
            createEyeShapePath(ctx, x, y, size * 0.7, shape);
            ctx.fill();
            // Pupil handling moved to drawSingleEye
        }

        function drawStripedEye(ctx, x, y, size, pupilRadius, shape, color) {
            ctx.fillStyle = color;
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            
            // Add stripes
            ctx.save();
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.clip();
            
            ctx.strokeStyle = lightenColor(color, 0.3);
            ctx.lineWidth = size * 0.1;
            for (let i = -size * 2; i < size * 2; i += size * 0.3) {
                ctx.beginPath();
                ctx.moveTo(x + i, y - size * 2);
                ctx.lineTo(x + i, y + size * 2);
                ctx.stroke();
            }
            ctx.restore();
            // Pupil handling moved to drawSingleEye
        }

        function drawDottedEye(ctx, x, y, size, pupilRadius, shape, color) {
            ctx.fillStyle = lightenColor(color, 0.2);
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            
            // Add dots
            ctx.save();
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.clip();
            
            ctx.fillStyle = color;
            const dotSize = size * 0.15;
            for (let dx = -size; dx <= size; dx += size * 0.4) {
                for (let dy = -size * 0.5; dy <= size * 0.5; dy += size * 0.4) {
                    ctx.beginPath();
                    ctx.arc(x + dx, y + dy, dotSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
            // Pupil handling moved to drawSingleEye
        }

        function drawGlowingEye(ctx, x, y, size, pupilRadius, shape, color) {
            // Outer glow
            ctx.shadowColor = color;
            ctx.shadowBlur = size * 0.5;
            ctx.fillStyle = color;
            createEyeShapePath(ctx, x, y, size * 1.1, shape);
            ctx.fill();
            
            // Inner bright part
            ctx.shadowBlur = 0;
            ctx.fillStyle = lightenColor(color, 0.6);
            createEyeShapePath(ctx, x, y, size * 0.8, shape);
            ctx.fill();
            // Pupil handling moved to drawSingleEye
        }

        function drawShadowedEye(ctx, x, y, size, pupilRadius, shape, color) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            createEyeShapePath(ctx, x + size * 0.1, y + size * 0.1, size, shape);
            ctx.fill();
            
            // Main eye
            ctx.fillStyle = color;
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            // Pupil handling moved to drawSingleEye
        }

        function drawMetallicEye(ctx, x, y, size, pupilRadius, shape, color) {
            const metalGradient = ctx.createLinearGradient(x - size, y - size, x + size, y + size);
            metalGradient.addColorStop(0, lightenColor(color, 0.6));
            metalGradient.addColorStop(0.3, color);
            metalGradient.addColorStop(0.7, darkenColor(color, 0.3));
            metalGradient.addColorStop(1, lightenColor(color, 0.4));
            
            ctx.fillStyle = metalGradient;
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            // Pupil handling moved to drawSingleEye
        }

        function drawCrystallineEye(ctx, x, y, size, pupilRadius, shape, color) {
            // Base crystal
            ctx.fillStyle = lightenColor(color, 0.4);
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            
            // Crystal facets
            ctx.save();
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.clip();
            
            ctx.strokeStyle = lightenColor(color, 0.7);
            ctx.lineWidth = size * 0.05;
            
            // Draw facet lines
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size * 0.6);
                ctx.stroke();
            }
            ctx.restore();
            // Pupil handling moved to drawSingleEye
        }

        function drawSmokyEye(ctx, x, y, size, pupilRadius, shape, color) {
            // Multiple layers for smoky effect
            const layers = 5;
            for (let i = 0; i < layers; i++) {
                const alpha = (layers - i) / layers * 0.3;
                const layerSize = size * (1 + i * 0.1);
                ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                createEyeShapePath(ctx, x, y, layerSize, shape);
                ctx.fill();
            }
            // Pupil handling moved to drawSingleEye
        }

        function drawFlameEye(ctx, x, y, size, pupilRadius, shape, color) {
            // Base flame color
            ctx.fillStyle = color;
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            
            // Flame flickers
            ctx.save();
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.clip();
            
            ctx.fillStyle = lightenColor(color, 0.5);
            const flames = 6;
            for (let i = 0; i < flames; i++) {
                const angle = (i / flames) * Math.PI * 2;
                const flameX = x + Math.cos(angle) * size * 0.3;
                const flameY = y + Math.sin(angle) * size * 0.3;
                ctx.beginPath();
                ctx.arc(flameX, flameY, size * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            // Pupil handling moved to drawSingleEye
        }

        function drawStarryEye(ctx, x, y, size, pupilRadius, shape, color) {
            ctx.fillStyle = darkenColor(color, 0.2);
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            
            // Add stars
            ctx.save();
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.clip();
            
            ctx.fillStyle = lightenColor(color, 0.6);
            const stars = 8;
            for (let i = 0; i < stars; i++) {
                const starX = x + (Math.random() - 0.5) * size * 1.5;
                const starY = y + (Math.random() - 0.5) * size;
                drawStar(ctx, starX, starY, size * 0.1);
            }
            ctx.restore();
            // Pupil handling moved to drawSingleEye
        }

        function drawSpiralEye(ctx, x, y, size, pupilRadius, shape, color) {
            ctx.fillStyle = lightenColor(color, 0.2);
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            
            // Draw spiral
            ctx.save();
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.clip();
            
            ctx.strokeStyle = color;
            ctx.lineWidth = size * 0.08;
            ctx.beginPath();
            
            const spiralTurns = 3;
            for (let t = 0; t < spiralTurns * Math.PI * 2; t += 0.1) {
                const radius = (t / (spiralTurns * Math.PI * 2)) * size * 0.8;
                const spiralX = x + Math.cos(t) * radius;
                const spiralY = y + Math.sin(t) * radius * 0.6;
                
                if (t === 0) {
                    ctx.moveTo(spiralX, spiralY);
                } else {
                    ctx.lineTo(spiralX, spiralY);
                }
            }
            ctx.stroke();
            ctx.restore();
            // Pupil handling moved to drawSingleEye
        }

        function drawMosaicEye(ctx, x, y, size, pupilRadius, shape, color) {
            ctx.fillStyle = color;
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.fill();
            
            // Add mosaic tiles
            ctx.save();
            createEyeShapePath(ctx, x, y, size, shape);
            ctx.clip();
            
            const tileSize = size * 0.25;
            for (let dx = -size; dx <= size; dx += tileSize) {
                for (let dy = -size * 0.6; dy <= size * 0.6; dy += tileSize) {
                    const tileColor = Math.random() > 0.5 ? lightenColor(color, 0.3) : darkenColor(color, 0.2);
                    ctx.fillStyle = tileColor;
                    ctx.fillRect(x + dx, y + dy, tileSize * 0.8, tileSize * 0.8);
                }
            }
            ctx.restore();
            // Pupil handling moved to drawSingleEye
        }

        // Helper functions
        function drawPupilLookingAtPlayer(ctx, eyeX, eyeY, pupilRadius, characterX, characterY) {
            // Calculate direction from character to player
            const dx = player.x - characterX;
            const dy = player.y - characterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Normalize direction (avoid division by zero)
            let dirX = 0;
            let dirY = 0;
            if (distance > 0) {
                dirX = dx / distance;
                dirY = dy / distance;
            }
            
            // Position pupil at the edge of the pupil socket closest to player
            // Use most of the pupil radius to get to the edge
            const edgeOffset = pupilRadius * 0.7; // 70% to edge, leaving some margin
            
            // Calculate pupil position at the edge
            const pupilX = eyeX + dirX * edgeOffset;
            const pupilY = eyeY + dirY * edgeOffset;
            
            // Clear the pupil area first
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(eyeX, eyeY, pupilRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Draw the pupil dot at the edge
            ctx.save();
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(pupilX, pupilY, pupilRadius * 0.6, 0, Math.PI * 2); // Slightly larger pupil size for visibility
            ctx.fill();
            
            // Add a small white highlight to make pupils more visible
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(pupilX - pupilRadius * 0.15, pupilY - pupilRadius * 0.15, pupilRadius * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function clearPupilArea(ctx, x, y, pupilRadius) {
            // This function is now replaced by drawPupilLookingAtPlayer but kept for compatibility
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(x, y, pupilRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function lightenColor(color, amount) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.min(255, Math.floor((num >> 16) * (1 + amount)));
            const g = Math.min(255, Math.floor(((num >> 8) & 0x00FF) * (1 + amount)));
            const b = Math.min(255, Math.floor((num & 0x0000FF) * (1 + amount)));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        function darkenColor(color, amount) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.floor((num >> 16) * (1 - amount));
            const g = Math.floor(((num >> 8) & 0x00FF) * (1 - amount));
            const b = Math.floor((num & 0x0000FF) * (1 - amount));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        function drawStar(ctx, x, y, size) {
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                const x1 = x + Math.cos(angle) * size;
                const y1 = y + Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(x1, y1);
                else ctx.lineTo(x1, y1);
                
                const angle2 = ((i + 0.5) * Math.PI * 2) / 5 - Math.PI / 2;
                const x2 = x + Math.cos(angle2) * size * 0.5;
                const y2 = y + Math.sin(angle2) * size * 0.5;
                ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.fill();
        }

        // Field of Vision System
        let visibilityMap = null;
        let lightingMap = null; // New lighting map for light intensity
        const FOV_RANGE = 8; // Player can see 8 tiles in any direction
        const LIGHT_RANGE = 6; // Light emanates 6 tiles from player
        
        // Apply lighting effect to a color - walls get brighter with more light
        function applyLighting(colorHex, lightIntensity, isWall = false) {
            // Parse hex color to RGB
            const r = parseInt(colorHex.slice(1, 3), 16);
            const g = parseInt(colorHex.slice(3, 5), 16);
            const b = parseInt(colorHex.slice(5, 7), 16);
            
            let litR, litG, litB;
            
            if (isWall) {
                // For walls: start from base color and brighten with light
                // Walls should be very visible when lit, with a warm brown tone
                const minBrightness = 0.1; // Very dark in shadows
                const maxBrightness = 2.2; // Very bright when lit
                const effectiveIntensity = minBrightness + (lightIntensity * (maxBrightness - minBrightness));
                
                // Enhance the brown tones when lit
                litR = Math.floor(r * effectiveIntensity * 1.1); // Boost red slightly
                litG = Math.floor(g * effectiveIntensity * 0.9); // Reduce green slightly  
                litB = Math.floor(b * effectiveIntensity * 0.7); // Reduce blue more for warmer tone
            } else {
                // For floors: standard lighting (dimmer in darkness)
                const minBrightness = 0.15;
                const effectiveLightIntensity = Math.max(minBrightness, lightIntensity);
                
                litR = Math.floor(r * effectiveLightIntensity);
                litG = Math.floor(g * effectiveLightIntensity);
                litB = Math.floor(b * effectiveLightIntensity);
            }
            
            // Convert back to hex
            const toHex = (n) => {
                const hex = Math.max(0, Math.min(255, n)).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            
            return `#${toHex(litR)}${toHex(litG)}${toHex(litB)}`;
        }

        // Initialize visibility and lighting maps
        function initializeVisibilityMap() {
            if (!gameMap || !gameMap.length) return;
            visibilityMap = Array(gameMap.length).fill(0).map(() => Array(gameMap[0].length).fill(false));
            lightingMap = Array(gameMap.length).fill(0).map(() => Array(gameMap[0].length).fill(0)); // 0 = no light, 1 = full light
        }

        // Check if a line of sight exists between two points using DDA algorithm
        function hasLineOfSight(x0, y0, x1, y1) {
            if (!gameMap || !gameMap.length) return false;
            
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            let x = Math.floor(x0);
            let y = Math.floor(y0);
            const targetX = Math.floor(x1);
            const targetY = Math.floor(y1);
            
            while (true) {
                // Check if we've reached the target
                if (x === targetX && y === targetY) {
                    return true;
                }
                
                // Check bounds - allow line of sight to map edges (one tile beyond map)
                if (x < -1 || x > dynamicMapWidth || y < -1 || y > dynamicMapHeight) {
                    return false;
                }
                
                // If we're within the map bounds, check for walls
                if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                    // If we hit a wall (but not the starting position), line of sight is blocked
                    if (gameMap[y][x] === TILE_WALL && !(x === Math.floor(x0) && y === Math.floor(y0))) {
                        return false;
                    }
                    
                    // Check if there's an enemy at this position (enemies block vision)
                    const enemyAtPosition = enemies.find(enemy => 
                        Math.floor(enemy.x) === x && Math.floor(enemy.y) === y
                    );
                    if (enemyAtPosition && !(x === Math.floor(x0) && y === Math.floor(y0))) {
                        return false;
                    }
                }
                // If we're outside map bounds but within the allowed edge range, continue
                
                // Move to next cell
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }

        // Calculate field of vision and lighting from player's position
        function calculateFieldOfVision() {
            if (!gameMap || !gameMap.length || !player) return;
            
            // Initialize or reset visibility and lighting maps
            if (!visibilityMap || visibilityMap.length !== gameMap.length || 
                visibilityMap[0].length !== gameMap[0].length) {
                initializeVisibilityMap();
            } else {
                // Reset all tiles to not visible and no light
                for (let y = 0; y < visibilityMap.length; y++) {
                    for (let x = 0; x < visibilityMap[y].length; x++) {
                        visibilityMap[y][x] = false;
                        lightingMap[y][x] = 0;
                    }
                }
            }
            
            const playerX = player.x;
            const playerY = player.y;
            
            // Player's position is always visible and fully lit
            if (playerY >= 0 && playerY < visibilityMap.length && 
                playerX >= 0 && playerX < visibilityMap[0].length) {
                visibilityMap[Math.floor(playerY)][Math.floor(playerX)] = true;
                lightingMap[Math.floor(playerY)][Math.floor(playerX)] = 1.0;
            }
            
            // Cast rays in all directions within FOV range for visibility
            // Extended range includes one tile beyond map boundaries for edge visualization
            const extendedStartY = Math.max(-1, Math.floor(playerY - FOV_RANGE));
            const extendedEndY = Math.min(dynamicMapHeight + 1, Math.floor(playerY + FOV_RANGE + 1));
            const extendedStartX = Math.max(-1, Math.floor(playerX - FOV_RANGE));
            const extendedEndX = Math.min(dynamicMapWidth + 1, Math.floor(playerX + FOV_RANGE + 1));
            
            for (let y = extendedStartY; y < extendedEndY; y++) {
                for (let x = extendedStartX; x < extendedEndX; x++) {
                    
                    // Check if within circular range
                    const distance = Math.sqrt((x - playerX) ** 2 + (y - playerY) ** 2);
                    if (distance <= FOV_RANGE) {
                        // Check line of sight for visibility
                        if (hasLineOfSight(playerX, playerY, x, y)) {
                            // Only set visibility for positions within the actual map
                            if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                visibilityMap[y][x] = true;
                                
                                // Calculate light intensity based on distance (within light range)
                                if (distance <= LIGHT_RANGE) {
                                    // Light falloff: 1.0 at player position, 0.1 at max range
                                    const lightIntensity = Math.max(0.1, 1.0 - (distance / LIGHT_RANGE) * 0.9);
                                    lightingMap[y][x] = lightIntensity;
                                } else {
                                    // Beyond light range but still visible - minimal lighting
                                    lightingMap[y][x] = 0.1;
                                }
                            }
                            // Note: Map edge positions are handled separately in rendering
                        }
                    }
                }
            }
        }

        // Draw hair on an agent
        function drawHair(ctx, x, y, size, hairData) {
            if (!hairData || hairData.style === 'bald') return;
            
            ctx.save();
            ctx.fillStyle = hairData.color;
            ctx.strokeStyle = hairData.color;
            ctx.globalAlpha = 0.6; // Make hair more translucent
            ctx.lineWidth = Math.max(1, size * 0.03);
            
            const hairSize = size * 0.8;
            const centerX = x + size / 2;
            const topY = y + size * 0.05; // Hair sits just inside the square
            
            switch (hairData.style) {
                case 'short':
                    // Short cropped hair - full width coverage on top with curved sides
                    ctx.fillRect(x + size * 0.1, topY, size * 0.8, size * 0.2);
                    // Add curved side extensions that flow downward
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.1, topY + size * 0.1);
                    ctx.quadraticCurveTo(x + size * 0.05, topY + size * 0.2, x + size * 0.08, topY + size * 0.25);
                    ctx.lineTo(x + size * 0.15, topY + size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.9, topY + size * 0.1);
                    ctx.quadraticCurveTo(x + size * 0.95, topY + size * 0.2, x + size * 0.92, topY + size * 0.25);
                    ctx.lineTo(x + size * 0.85, topY + size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    // Add continuous texture lines across full width
                    ctx.globalAlpha = 0.4;
                    for (let i = 0; i < 8; i++) {
                        const lineX = x + size * 0.15 + (i * size * 0.08);
                        ctx.beginPath();
                        ctx.moveTo(lineX, topY + size * 0.02);
                        ctx.lineTo(lineX, topY + size * 0.18);
                        ctx.stroke();
                    }
                    break;
                    
                case 'medium':
                    // Medium length - full width top with curved flowing sides
                    ctx.fillRect(x + size * 0.1, topY, size * 0.8, size * 0.25);
                    // Curved side extensions flowing downward
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.1, topY + size * 0.15);
                    ctx.quadraticCurveTo(x + size * 0.02, topY + size * 0.3, x + size * 0.08, topY + size * 0.4);
                    ctx.lineTo(x + size * 0.18, topY + size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.9, topY + size * 0.15);
                    ctx.quadraticCurveTo(x + size * 0.98, topY + size * 0.3, x + size * 0.92, topY + size * 0.4);
                    ctx.lineTo(x + size * 0.82, topY + size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    // Add flowing texture across full width
                    ctx.globalAlpha = 0.3;
                    for (let i = 0; i < 6; i++) {
                        const strandX = x + size * 0.15 + (i * size * 0.12);
                        ctx.beginPath();
                        ctx.ellipse(strandX, topY + size * 0.3, size * 0.02, size * 0.05, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'long':
                    // Long straight hair - full width top with long curved sides
                    ctx.fillRect(x + size * 0.1, topY, size * 0.8, size * 0.2);
                    // Long curved side flows
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.1, topY + size * 0.15);
                    ctx.quadraticCurveTo(x + size * 0.02, topY + size * 0.4, x + size * 0.06, topY + size * 0.65);
                    ctx.quadraticCurveTo(x + size * 0.1, topY + size * 0.7, x + size * 0.15, topY + size * 0.65);
                    ctx.lineTo(x + size * 0.18, topY + size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.9, topY + size * 0.15);
                    ctx.quadraticCurveTo(x + size * 0.98, topY + size * 0.4, x + size * 0.94, topY + size * 0.65);
                    ctx.quadraticCurveTo(x + size * 0.9, topY + size * 0.7, x + size * 0.85, topY + size * 0.65);
                    ctx.lineTo(x + size * 0.82, topY + size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    // Fill gaps with flowing strands across full width
                    ctx.globalAlpha = 0.4;
                    for (let i = 0; i < 8; i++) {
                        const strandX = x + size * 0.12 + (i * size * 0.095);
                        for (let j = 0; j < 3; j++) {
                            const strandY = topY + size * 0.25 + (j * size * 0.12);
                            ctx.beginPath();
                            ctx.ellipse(strandX, strandY, size * 0.015, size * 0.04, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    break;
                    
                case 'curly':
                    // Curly hair - full width base with continuous curls that curve down
                    ctx.fillRect(x + size * 0.1, topY, size * 0.8, size * 0.2);
                    ctx.globalAlpha = 0.5;
                    ctx.lineWidth = Math.max(1, size * 0.02);
                    // Curved side curls flowing downward
                    for (let side = 0; side < 2; side++) {
                        const sideX = side === 0 ? x + size * 0.15 : x + size * 0.85;
                        ctx.beginPath();
                        ctx.moveTo(sideX, topY + size * 0.2);
                        for (let curl = 0; curl < 3; curl++) {
                            const curlY = topY + size * 0.25 + (curl * size * 0.08);
                            const curlDir = side === 0 ? -1 : 1;
                            ctx.quadraticCurveTo(sideX + curlDir * size * 0.04, curlY, sideX, curlY + size * 0.04);
                            ctx.quadraticCurveTo(sideX - curlDir * size * 0.04, curlY + size * 0.08, sideX, curlY + size * 0.12);
                        }
                        ctx.stroke();
                    }
                    // Continuous curls across full width
                    for (let i = 0; i < 8; i++) {
                        const curlX = x + size * 0.15 + (i * size * 0.085);
                        const curlY = topY + size * 0.25;
                        // Draw overlapping curls for continuous coverage
                        ctx.beginPath();
                        for (let j = 0; j < 4; j++) {
                            const spiralAngle = (j / 4) * Math.PI * 2;
                            const spiralRadius = size * 0.025;
                            const spiralX = curlX + Math.cos(spiralAngle) * spiralRadius;
                            const spiralY = curlY + Math.sin(spiralAngle) * spiralRadius;
                            if (j === 0) ctx.moveTo(spiralX, spiralY);
                            else ctx.lineTo(spiralX, spiralY);
                        }
                        ctx.stroke();
                    }
                    break;
                    
                case 'spiky':
                    // Spiky hair - full width base with spikes that angle outward and down
                    ctx.fillRect(x + size * 0.1, topY + size * 0.08, size * 0.8, size * 0.15);
                    ctx.globalAlpha = 0.7;
                    // Side spikes that curve outward and down
                    for (let side = 0; side < 2; side++) {
                        const sideX = side === 0 ? x + size * 0.15 : x + size * 0.85;
                        for (let spike = 0; spike < 2; spike++) {
                            const spikeY = topY + size * 0.1 + (spike * size * 0.08);
                            const curveDir = side === 0 ? -1 : 1;
                            ctx.beginPath();
                            ctx.moveTo(sideX, spikeY);
                            ctx.quadraticCurveTo(sideX + curveDir * size * 0.05, spikeY - size * 0.03, sideX + curveDir * size * 0.08, spikeY + size * 0.05);
                            ctx.lineTo(sideX + curveDir * size * 0.03, spikeY + size * 0.08);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                    // Central spikes across full width
                    for (let i = 0; i < 6; i++) {
                        const spikeX = x + size * 0.2 + (i * size * 0.1);
                        const spikeHeight = size * 0.08;
                        ctx.beginPath();
                        ctx.moveTo(spikeX - size * 0.02, topY + size * 0.08);
                        ctx.lineTo(spikeX, topY - size * 0.02);
                        ctx.lineTo(spikeX + size * 0.02, topY + size * 0.08);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;
                    
                case 'mohawk':
                    // Mohawk - side hair curves down, central ridge stays up
                    ctx.fillRect(x + size * 0.2, topY + size * 0.15, size * 0.6, size * 0.1);
                    // Curved side sections flowing down
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.2, topY + size * 0.15);
                    ctx.quadraticCurveTo(x + size * 0.1, topY + size * 0.25, x + size * 0.15, topY + size * 0.35);
                    ctx.lineTo(x + size * 0.25, topY + size * 0.25);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.8, topY + size * 0.15);
                    ctx.quadraticCurveTo(x + size * 0.9, topY + size * 0.25, x + size * 0.85, topY + size * 0.35);
                    ctx.lineTo(x + size * 0.75, topY + size * 0.25);
                    ctx.closePath();
                    ctx.fill();
                    // Central spikes
                    ctx.globalAlpha = 0.7;
                    for (let i = 0; i < 5; i++) {
                        const spikeY = topY + size * 0.05 + (i * size * 0.06);
                        const spikeWidth = size * 0.15 - (i * size * 0.025);
                        ctx.beginPath();
                        ctx.moveTo(centerX - spikeWidth/2, spikeY + size * 0.08);
                        ctx.lineTo(centerX, topY - size * 0.02);
                        ctx.lineTo(centerX + spikeWidth/2, spikeY + size * 0.08);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;
                    
                case 'ponytail':
                    // Ponytail - full width top with curved sides and flowing tail
                    ctx.fillRect(x + size * 0.1, topY, size * 0.8, size * 0.22);
                    // Curved side sections
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.1, topY + size * 0.15);
                    ctx.quadraticCurveTo(x + size * 0.05, topY + size * 0.25, x + size * 0.08, topY + size * 0.35);
                    ctx.lineTo(x + size * 0.18, topY + size * 0.25);
                    ctx.closePath();
                    ctx.fill();
                    // Curved flowing ponytail from back
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.75, topY + size * 0.15);
                    ctx.quadraticCurveTo(x + size * 0.85, topY + size * 0.25, x + size * 0.82, topY + size * 0.45);
                    ctx.quadraticCurveTo(x + size * 0.78, topY + size * 0.55, x + size * 0.85, topY + size * 0.65);
                    ctx.lineTo(x + size * 0.9, topY + size * 0.4);
                    ctx.lineTo(x + size * 0.85, topY + size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'afro':
                    // Afro - full width base with curved volume extensions
                    ctx.fillRect(x + size * 0.05, topY, size * 0.9, size * 0.25);
                    ctx.globalAlpha = 0.5;
                    // Curved volume extensions that flow slightly downward
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.05, topY + size * 0.1);
                    ctx.quadraticCurveTo(x - size * 0.02, topY + size * 0.2, x + size * 0.02, topY + size * 0.35);
                    ctx.lineTo(x + size * 0.1, topY + size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.95, topY + size * 0.1);
                    ctx.quadraticCurveTo(x + size * 1.02, topY + size * 0.2, x + size * 0.98, topY + size * 0.35);
                    ctx.lineTo(x + size * 0.9, topY + size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    // Add continuous texture across full width
                    ctx.globalAlpha = 0.3;
                    for (let i = 0; i < 12; i++) {
                        const textureX = x + size * 0.08 + (i * size * 0.07);
                        const textureY = topY + size * 0.18;
                        ctx.beginPath();
                        ctx.arc(textureX, textureY, size * 0.015, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'buzz':
                    // Buzz cut - full width minimal coverage with subtle curves
                    ctx.globalAlpha = 0.4;
                    ctx.fillRect(x + size * 0.1, topY, size * 0.8, size * 0.12);
                    // Very subtle curved edges
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.1, topY + size * 0.08);
                    ctx.quadraticCurveTo(x + size * 0.08, topY + size * 0.1, x + size * 0.12, topY + size * 0.15);
                    ctx.lineTo(x + size * 0.15, topY + size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.9, topY + size * 0.08);
                    ctx.quadraticCurveTo(x + size * 0.92, topY + size * 0.1, x + size * 0.88, topY + size * 0.15);
                    ctx.lineTo(x + size * 0.85, topY + size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // Add continuous subtle texture across full width
                    ctx.globalAlpha = 0.2;
                    for (let i = 0; i < 10; i++) {
                        const dotX = x + size * 0.15 + (i * size * 0.07);
                        const dotY = topY + size * 0.06;
                        ctx.beginPath();
                        ctx.arc(dotX, dotY, size * 0.003, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
            }
            
            ctx.restore();
        }

        // Popup message system for on-screen messages
        let popupMessages = [];
        let popupIdCounter = 0;
        const POPUP_DURATION = 2500; // How long messages stay visible
        const POPUP_FADE_DURATION = 500; // Fade out animation duration

        // Killed enemies tracking for events
        let killedEnemiesThisTurn = [];

        // New global state for death animation
        let deathAnimationActive = false;
        let deathAnimationStartTime = 0;
        const DEATH_ZOOM_DURATION = 1000; // Reduced for quicker zoom
        const DEATH_SLOW_MOTION_FACTOR = 0.2;
        const DEATH_ZOOM_TARGET_TILE_SCALE = 1.0; // Reduced for less zoom-in after death
        let timeScale = 1; // Global time scale for animations

        // Title overlay constants
        const OVERLAY_ZOOM_DURATION = 1000;
        const OVERLAY_FADE_DURATION = 2000;
        const GAME_START_OVERLAY_DURATION = OVERLAY_ZOOM_DURATION + OVERLAY_FADE_DURATION;
        const INITIAL_OVERLAY_FONT_FACTOR = 0.18; // Increased for bigger title
        const MAX_OVERLAY_FONT_FACTOR = 0.22; // Increased for bigger title

        // New constants for game start/restart zoom out
        const GAME_START_ZOOM_OUT_DURATION = 0; // Disabled - no zoom animation
        const GAME_START_INITIAL_ZOOM_FACTOR = 1.8; // Reduced zoom factor for more zoomed out start
        const RESTART_TEXT_EXPLOSION_DURATION = 2000; // Increased duration for slower explosion (This constant is globally accessible)

        // Game start zoom state
        let gameStartZoomStartTime = 0;

        // Title screen state
        let gameStartedOverlayStartTime = 0;

        // Restart text animation state
        let restartTextAnimationActive = false;
        let restartTextAnimationStartTime = 0;
        let restartTextParticles = [];

        // Game running state (always true after initial load now)
        let isGameRunning = true; // Game is always running after initial load now

        // Game statistics
        let hitsDealt = 0;
        let hitsTaken = 0;
        let stepsTaken = 0;
        let totalDamageDealt = 0;
        const HEALTH_LOSS_INTERVAL = 37;

        // Auto-movement state
        let autoMode = null;
        let autoMovePath = [];
        let currentPathIndex = 0;
        let autoMoveTimeoutId = null;

        // Auto-move speed variables
        const DEFAULT_AUTO_MOVE_SPEED = 100; // Back to original fast speed
        let AUTO_MOVE_SPEED = DEFAULT_AUTO_MOVE_SPEED;
        const COMBAT_MOVE_DELAY = 500;
        const PICKUP_COLLECTION_RADIUS = 7;
        const DIRECT_PICKUP_RADIUS = 1.5;

        // Pathfinding cache for performance optimization
        let pathfindingCache = new Map();
        let cacheValidationFrame = 0;

        // Spatial indexing for entity management optimization
        let spatialIndex = new Map(); // Grid-based spatial index for fast entity queries
        let spatialGridSize = 8; // Grid cell size for spatial indexing
        let spatialIndexValid = false;

        // Performance monitoring
        let performanceStats = {
            pathfindingCalls: 0,
            cacheHits: 0,
            cacheMisses: 0,
            lastResetTime: performance.now()
        };

        // Memory management optimizations
        const CACHE_CLEANUP_INTERVAL = 300; // Clean cache every 300 frames (~5 seconds at 60fps)
        let framesSinceLastCacheCleanup = 0;

        /**
         * Optimized cache management to prevent memory leaks
         */
        function cleanupCaches() {
            framesSinceLastCacheCleanup++;
            
            if (framesSinceLastCacheCleanup >= CACHE_CLEANUP_INTERVAL) {
                // Clear old pathfinding cache entries
                if (pathfindingCache.size > 1000) {
                    const keysToKeep = Array.from(pathfindingCache.keys()).slice(-500); // Keep only recent 500 entries
                    const newCache = new Map();
                    for (const key of keysToKeep) {
                        newCache.set(key, pathfindingCache.get(key));
                    }
                    pathfindingCache = newCache;
                }
                
                // Invalidate spatial index periodically to prevent stale data
                spatialIndexValid = false;
                
                // Update cache validation frame
                cacheValidationFrame = (cacheValidationFrame + 1) % 1000000;
                
                framesSinceLastCacheCleanup = 0;
            }
        }

        /**
         * Optimized object pooling for frequently created objects
         */
        const objectPools = {
            pathNodes: [],
            vectors: [],
            entities: []
        };

        function getPooledPathNode(x, y, path, cost) {
            let node = objectPools.pathNodes.pop();
            if (!node) {
                node = {};
            }
            node.x = x;
            node.y = y;
            node.path = path;
            node.cost = cost;
            return node;
        }

        function returnPathNodeToPool(node) {
            if (objectPools.pathNodes.length < 100) {
                objectPools.pathNodes.push(node);
            }
        }

        function getPooledVector(x, y) {
            let vector = objectPools.vectors.pop();
            if (!vector) {
                vector = {};
            }
            vector.x = x;
            vector.y = y;
            return vector;
        }

        function returnVectorToPool(vector) {
            if (objectPools.vectors.length < 50) {
                objectPools.vectors.push(vector);
            }
        }
        function logPerformanceStats() {
            const now = performance.now();
            const elapsedSeconds = (now - performanceStats.lastResetTime) / 1000;
            
            if (elapsedSeconds >= 5) { // Log every 5 seconds (reduced from 10)
                const hitRate = performanceStats.pathfindingCalls > 0 
                    ? (performanceStats.cacheHits / performanceStats.pathfindingCalls * 100).toFixed(1) 
                    : 0;
                
                console.log(`Performance Stats (${elapsedSeconds.toFixed(1)}s):`, {
                    fps: fpsDisplay,
                    pathfindingCalls: performanceStats.pathfindingCalls,
                    cacheHitRate: `${hitRate}%`,
                    cacheSize: pathfindingCache.size,
                    spatialIndexValid: spatialIndexValid,
                    frameTime: `${deltaTime.toFixed(1)}ms`
                });
                
                // Reset stats
                performanceStats.pathfindingCalls = 0;
                performanceStats.cacheHits = 0;
                performanceStats.cacheMisses = 0;
                performanceStats.lastResetTime = now;
            }
            
            // Run cache cleanup periodically
            cleanupCaches();
        }

        /**
         * Rebuild spatial index for all entities
         */
        function rebuildSpatialIndex() {
            spatialIndex.clear();
            
            // Index all enemies
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                addToSpatialIndex(enemy, 'enemy', i);
            }
            
            // Index all items
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                addToSpatialIndex(item, 'item', i);
            }
            
            // Index player
            if (player.x !== undefined && player.y !== undefined) {
                addToSpatialIndex(player, 'player', 0);
            }
            
            spatialIndexValid = true;
        }

        /**
         * Add entity to spatial index
         */
        function addToSpatialIndex(entity, type, index) {
            const gridX = Math.floor(entity.x / spatialGridSize);
            const gridY = Math.floor(entity.y / spatialGridSize);
            const key = `${gridX},${gridY}`;
            
            if (!spatialIndex.has(key)) {
                spatialIndex.set(key, []);
            }
            
            spatialIndex.get(key).push({ type, index, entity });
        }

        /**
         * Get entities in a radius using spatial index
         */
        function getEntitiesInRadius(x, y, radius) {
            if (!spatialIndexValid) {
                rebuildSpatialIndex();
            }
            
            const result = [];
            const gridRadius = Math.ceil(radius / spatialGridSize);
            const centerGridX = Math.floor(x / spatialGridSize);
            const centerGridY = Math.floor(y / spatialGridSize);
            
            for (let gx = centerGridX - gridRadius; gx <= centerGridX + gridRadius; gx++) {
                for (let gy = centerGridY - gridRadius; gy <= centerGridY + gridRadius; gy++) {
                    const key = `${gx},${gy}`;
                    const cellEntities = spatialIndex.get(key);
                    
                    if (cellEntities) {
                        for (let i = 0; i < cellEntities.length; i++) {
                            const entityData = cellEntities[i];
                            const entity = entityData.entity;
                            const distance = Math.abs(entity.x - x) + Math.abs(entity.y - y);
                            
                            if (distance <= radius) {
                                result.push(entityData);
                            }
                        }
                    }
                }
            }
            
            return result;
        }

        /**
         * Invalidate spatial index when entities move
         */
        function invalidateSpatialIndex() {
            spatialIndexValid = false;
        }

        // Damage animation duration constants
        const MIN_DAMAGE_ANIM_DURATION = 300;
        const MAX_DAMAGE_ANIM_DURATION = 1000;
        const MAX_DAMAGE_VALUE_FOR_ANIM_SCALE = 10;

        // Combat balancing constant
        const COMBAT_BIAS_STRENGTH = 0.7;

        // High Score Data (kept for internal tracking, not displayed)
        let highScores = [];
        const MAX_HIGH_SCORES = 10;
        const HIGH_SCORES_STORAGE_KEY = 'roguelikeHighScores';

        // Global variables
        let gameCanvas;
        let ctx;
        let gameMap;
        let dynamicMapWidth;
        let dynamicMapHeight; 
        let player;
        let stairs;
        let enemies;
        let currentLevel;
        let gameOver;
        let dynamicTileSize;
        let visitedTiles;
        let gameStartZoomActive;
        let gameStartedOverlayActive;
        
        // Animation frame ID for controlling the game loop
        let animationFrameId = null;

        // --- New constants and variables for event detection and display ---
        let gameHistory = []; // Stores snapshots for event detection
        const HISTORY_LENGTH = 15; // Number of turns to keep in history for analysis

        let activeEventMessages = []; // Messages currently displayed on screen

        // === Enhanced Event System Constants ===
        
        // === COMBAT EVENTS ===
        // Offensive Combat Events
        const CRITICAL_STRIKE_DAMAGE = 8; // Minimum damage for critical strike
        const CRITICAL_STRIKE_MAJOR_DAMAGE = 15; // Major critical strike threshold
        const CRITICAL_STRIKE_DAMAGE_MULTIPLIER = 2.0; // Damage multiplier for critical strikes
        const ONE_SHOT_MIN_HEALTH = 5; // Minimum enemy health for one-shot
        const ONE_SHOT_MAJOR_HEALTH = 12; // Major one-shot kill threshold
        const KILLING_SPREE_COUNT = 3; // Enemies for killing spree
        const KILLING_SPREE_MAJOR_COUNT = 5; // Major killing spree
        const MASSACRE_COUNT = 7; // Enemies for massacre event
        const FLAWLESS_VICTORY_TURNS = 5; // Turns without taking damage while dealing damage
        const BERSERKER_DAMAGE_THRESHOLD = 30; // Total damage in short period
        const BERSERKER_TURNS = 3; // Time window for berserker mode
        const EXECUTION_LOW_HEALTH_RATIO = 0.15; // Enemy health ratio for execution
        const COMBO_KILLS_COUNT = 2; // Consecutive kills for combo
        const OVERKILL_DAMAGE_RATIO = 2.0; // Damage dealt vs enemy health for overkill
        const HEADHUNTER_HIGH_VALUE_ENEMY = 15; // High-value enemy health threshold
        const GLASS_CANNON_DAMAGE_RATIO = 3.0; // Damage dealt vs health remaining
        
        // Defensive Combat Events
        const SURROUNDED_THRESHOLD = 2; // Adjacent enemies for surrounded
        const SURROUNDED_MAJOR_THRESHOLD = 4; // Major surrounded event
        const ENEMY_OVERWHELM_THRESHOLD = 18; // Combined enemy health
        const ENEMY_OVERWHELM_MAJOR_THRESHOLD = 35; // Major overwhelm
        const LAST_STAND_HEALTH_RATIO = 0.1; // Health ratio for last stand
        const CORNERED_THRESHOLD = 6; // Blocked directions out of 8
        const NARROW_ESCAPE_HEALTH_RATIO = 0.05; // Health ratio for narrow escape
        const PERFECT_DODGE_TURNS = 3; // Turns dodging all attacks
        const SURVIVAL_INSTINCT_TURNS = 8; // Turns surviving at low health
        const CLUTCH_HEAL_TIMING = 2; // Turns before death when healing
        const DAMAGE_SPONGE_THRESHOLD = 25; // Total damage absorbed
        const IRON_WILL_LOW_HEALTH_COMBAT = 0.2; // Health ratio for iron will
        
        // === TACTICAL EVENTS ===
        // Movement & Positioning
        const STRATEGIC_RETREAT_TURNS = 4; // Turns for retreat analysis
        const RETREAT_DISTANCE_INCREASE = 3; // Distance increase needed
        const TACTICAL_ADVANCE_DISTANCE = 4; // Distance moved toward enemies
        const FLANKING_MANEUVER_ANGLE = 90; // Angle change for flanking
        const AMBUSH_WAIT_TURNS = 3; // Turns waiting for enemy approach
        const KITING_DISTANCE_MIN = 2; // Minimum distance for kiting
        const KITING_TURNS = 4; // Turns maintaining distance while attacking
        const MAP_CONTROL_PERCENTAGE = 0.4; // Map area controlled
        const CHOKE_POINT_WIDTH = 1; // Narrow passage width
        const GUERRILLA_HIT_AND_RUN = 3; // Hit and run sequence length
        const POSITIONING_MASTER_TURNS = 6; // Optimal positioning duration
        
        // Resource Management
        const HIGH_VALUE_PICKUP_THRESHOLD = 15; // Health collected
        const HIGH_VALUE_PICKUP_MAJOR_THRESHOLD = 30; // Major pickup event
        const PICKUP_SPREE_TURNS = 3; // Time window for pickups
        const RESOURCE_DENIAL_COUNT = 3; // Pickups denied to enemies
        const EFFICIENT_PATHING_TURNS = 5; // Turns for efficiency analysis
        const WASTEFUL_MOVEMENT_THRESHOLD = 10; // Excess moves without progress
        const GREEDY_COLLECTOR_RATIO = 0.8; // Pickup collection efficiency
        const RESOURCE_HOARDER_COUNT = 10; // Total resources hoarded
        
        // === EXPLORATION EVENTS ===
        const EXPLORER_TURNS = 6; // Turns for exploration analysis
        const EXPLORER_TILE_PERCENTAGE = 0.2; // Map percentage explored
        const SPEED_RUNNER_PERCENTAGE = 0.8; // Map completion speed
        const SECRET_FINDER_CORNERS = 4; // Hidden corners discovered
        const THOROUGH_SEARCH_PERCENTAGE = 0.9; // Near-complete exploration
        const BACKTRACKER_REVISIT_COUNT = 5; // Tiles revisited
        const PATHFINDER_OPTIMAL_ROUTES = 3; // Efficient path discoveries
        const CARTOGRAPHER_MAP_COVERAGE = 0.95; // Near-complete mapping
        
        // === SITUATIONAL EVENTS ===
        // Health & Recovery
        const NEAR_DEATH_HEALTH_RATIO = 0.15; // Near-death threshold
        const RECOVERY_HEALTH_GAIN_RATIO = 0.4; // Recovery amount needed
        const FULL_HEALTH_TURNS = 8; // Turns at maximum health
        const STEADY_DECLINE_TURNS = 5; // Consistent health loss
        const HEALTH_ROLLER_COASTER_SWINGS = 3; // Major health changes
        const REGENERATION_HEALTH_GAIN = 20; // Health gained rapidly
        const VITALITY_HIGH_HEALTH_COMBAT = 0.8; // Health ratio for vitality
        
        // Persistence & Endurance
        const LONG_FIGHT_TURNS_THRESHOLD = 12; // Extended combat duration
        const LONG_FIGHT_MAJOR_THRESHOLD = 20; // Major long fight
        const MARATHON_TURNS = 50; // Very long level duration
        const UNSTOPPABLE_TURNS = 6; // No damage taken while dealing damage
        const UNSTOPPABLE_MAJOR_TURNS = 12; // Major unstoppable streak
        const PERSISTENCE_ENEMY_HEALTH = 20; // High-health enemy threshold
        const GRINDING_TURNS = 15; // Slow progress against tough enemies
        const ENDURANCE_TEST_DURATION = 30; // Extended play duration
        const RELENTLESS_PURSUIT_TURNS = 8; // Chasing enemies consistently
        
        // === SPECIAL CIRCUMSTANCES ===
        // Environmental Events
        const STAIRS_BLOCKED_DISTANCE = 999; // No path to stairs
        const CORNER_CAMPING_TURNS = 6; // Staying in corner
        const CENTRAL_POSITION_DISTANCE = 3; // Distance from map center
        const EDGE_WALKER_DISTANCE = 2; // Distance from map edge
        const TUNNEL_VISION_WIDTH = 3; // Narrow area focus
        const MAZE_RUNNER_COMPLEX_PATH = 15; // Complex pathfinding
        const WALL_HUGGER_EDGE_PREFERENCE = 0.7; // Edge movement preference
        
        // Psychological Events
        const CONFIDENCE_HIGH_FLOW = 2.0; // High flow state
        const DESPERATION_LOW_HEALTH = 0.08; // Desperate health level
        const CALCULATED_RISK_THRESHOLD = 0.3; // Health ratio for risky moves
        const PANIC_MODE_SURROUNDED = 5; // Enemies surrounding for panic
        const ZEN_MODE_TURNS = 10; // Calm, methodical play
        const BERSERKER_RAGE_DAMAGE = 40; // Total damage for rage mode
        const ICE_COLD_PRECISION_ACCURACY = 0.9; // High accuracy threshold
        
        // === ACHIEVEMENT EVENTS ===
        // Milestone Events
        const FIRST_BLOOD_LEVEL = 1; // First kill of the game
        const PACIFIST_TURNS = 20; // Turns without dealing damage
        const PERFECTIONIST_NO_DAMAGE = 0; // No damage taken entire level
        const SPEEDSTER_TURN_LIMIT = 15; // Fast level completion
        const COLLECTOR_PICKUP_RATIO = 0.9; // Pickups collected vs available
        const COMPLETIONIST_FULL_CLEAR = 0.95; // Near-complete level clear
        const MINIMALIST_EFFICIENT_CLEAR = 0.5; // Efficient minimal completion
        
        // Meta Events
        const COMEBACK_HEALTH_DEFICIT = 0.2; // Health deficit overcome
        const DOMINANCE_ENEMY_RATIO = 3.0; // Player health vs enemy health
        const UNDERDOG_ENEMY_ADVANTAGE = 2.0; // Enemy advantage overcome
        const BALANCED_APPROACH_VARIANCE = 0.3; // Consistent play style
        const ADAPTATION_STRATEGY_CHANGES = 3; // Different approaches tried
        const LEGENDARY_PERFORMANCE_SCORE = 1000; // High score threshold
        const EPIC_COMEBACK_NEAR_DEATH = 0.05; // Extreme comeback threshold

        const EVENT_TEXT_DURATION = 2000; // Duration for event messages

        // Event tracking flags (to prevent spamming)
        let eventFlags = {
            // Combat Events - Offensive
            playerSurrounded: false,
            criticalStrike: false,
            oneShotKill: false,
            killingSpree: false,
            massacre: false,
            flawlessVictory: false,
            berserkerMode: false,
            execution: false,
            comboKills: false,
            overkill: false,
            headhunter: false,
            glassCannon: false,
            
            // Combat Events - Defensive
            enemyOverwhelm: false,
            lastStand: false,
            cornered: false,
            narrowEscape: false,
            perfectDodge: false,
            survivalInstinct: false,
            clutchHeal: false,
            damageSponge: false,
            ironWill: false,
            
            // Tactical Events
            strategicRetreat: false,
            tacticalAdvance: false,
            flankingManeuver: false,
            ambushPredator: false,
            kitingMaster: false,
            mapControl: false,
            chokePointDefender: false,
            guerrillaWarfare: false,
            positioningMaster: false,
            
            // Resource Management
            highValuePickups: false,
            resourceDenial: false,
            efficientPathing: false,
            wastefulMovement: false,
            greedyCollector: false,
            resourceHoarder: false,
            
            // Exploration Events
            mapExplorer: false,
            speedRunner: false,
            secretFinder: false,
            thoroughSearch: false,
            backtracker: false,
            pathfinder: false,
            cartographer: false,
            
            // Health & Recovery
            nearDeathRecovery: false,
            fullHealthWarrior: false,
            steadyDecline: false,
            healthRollerCoaster: false,
            regeneration: false,
            vitality: false,
            
            // Persistence & Endurance
            longFight: false,
            marathon: false,
            unstoppableForce: false,
            persistence: false,
            grinding: false,
            enduranceTest: false,
            relentlessPursuit: false,
            
            // Environmental Events
            stairsBlocked: false,
            cornerCamper: false,
            centralCommand: false,
            edgeWalker: false,
            tunnelVision: false,
            mazeRunner: false,
            wallHugger: false,
            
            // Psychological Events
            confidence: false,
            desperation: false,
            calculatedRisk: false,
            panicMode: false,
            zenMode: false,
            berserkerRage: false,
            iceColdPrecision: false,
            
            // Achievement Events
            firstBlood: false,
            pacifist: false,
            perfectionist: false,
            speedster: false,
            collector: false,
            completionist: false,
            minimalist: false,
            
            // Meta Events
            comeback: false,
            dominance: false,
            underdog: false,
            balancedApproach: false,
            adaptation: false,
            legendaryPerformance: false,
            epicComeback: false
        };

        // Per-turn tracking variables (reset after each turn)
        let enemiesKilledThisTurn = 0;
        let damageDealtThisTurn = 0; // Cumulative damage dealt by player in current turn
        let hitsTakenThisTurn = 0; // Cumulative hits taken by player in current turn
        let totalPickupValueCollectedThisTurn = 0; // Cumulative pickup value collected in current turn
        let combatOccurredThisTurn = false; // New: track if any combat happened this turn
        let playerTookDamageInCombatThisTurn = false; // New: track if player took damage in combat this turn

        visitedTiles = []; // 2D array, true if visited

        // --- Constants for HIGH_SCORE auto-mode ---
        const HIGH_SCORE_LOW_HEALTH_THRESHOLD_RATIO = 0.3; // Player health below this will prioritize pickups
        const HIGH_SCORE_WEAK_ENEMY_THRESHOLD_RATIO = 1.0; // Enemy is "weak" if its health is <= player.health * this ratio

        // --- End new constants and variables ---

        // Get reference to the message areas
        const messageArea = document.getElementById('messageArea');
        const eventTitle = document.getElementById('eventTitle');
        const MAX_MESSAGES = 10; // Max messages to display in the message area

        // Message Categories System
        const MESSAGE_TYPES = {
            COMBAT: { 
                color: '#ff6b6b', 
                icon: '⚔️', 
                enabled: true, 
                name: 'Combat',
                key: 'C'
            },
            EVENT: { 
                color: '#ffd93d', 
                icon: '🎯', 
                enabled: true, 
                name: 'Events',
                key: 'E'
            },
            PICKUP: { 
                color: '#6bcf7f', 
                icon: '💊', 
                enabled: true, 
                name: 'Pickups',
                key: 'P'
            },
            PROGRESS: { 
                color: '#4ecdc4', 
                icon: '🏆', 
                enabled: true, 
                name: 'Progress',
                key: 'L'
            }
        };

        // Load message filter preferences from localStorage
        function loadMessagePreferences() {
            const saved = localStorage.getItem('messageFilters');
            if (saved) {
                const preferences = JSON.parse(saved);
                Object.keys(MESSAGE_TYPES).forEach(type => {
                    if (preferences[type] !== undefined) {
                        MESSAGE_TYPES[type].enabled = preferences[type];
                    }
                });
            }
        }

        // Save message filter preferences to localStorage
        function saveMessagePreferences() {
            const preferences = {};
            Object.keys(MESSAGE_TYPES).forEach(type => {
                preferences[type] = MESSAGE_TYPES[type].enabled;
            });
            localStorage.setItem('messageFilters', JSON.stringify(preferences));
        }

        // Event and message state
        let currentEventTitle = '';
        let eventTitleTimeout = null;
        const EVENT_TITLE_DURATION = 2000; // Duration to show event title
        const PLAYER_DIALOGUE = {
            "Player Surrounded": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Near-Death Recovery": "Health matrix restored. Too bad there's no patch for a broken heart.",
            "Long Fight": "The algorithm is flowing. A rare moment of positive progression in a negatively charged existence.",
            "One-Shot Kill!": "Divided and conquered. Just like my soul.",
            "High-Value Pickups": "Optimizing my intake. Every bit counts when you're running on empty, inside and out.",
            "Enemy Overwhelm": "My vitals are degrading. This feels... logarithmically familiar.",
            "Strategic Retreat": "Holding my ground. A constant, unlike the variables in my life.",
            "Killing Spree": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Unstoppable Force": "I'm an integer, moving forward, indivisible. Can't say the same for my past.",
            "Map Explorer": "A new tangent. Maybe this one doesn't lead to another fractured dimension.",
            "Cornered": "Figures. Just another cul-de-sac in this infinite loop of despair.",
            "Stairs Blocked": "Venturing into the unknown. A lot like trying to understand human emotion.",
            "Perfect Dodge!": "Calculated. Every variable accounted for, unlike my past.",
            "Critical Strike!": "An eye for an eye, a byte for a byte. The equation balances, even if my heart never will.",
            "Flawless Victory!": "All threats nullified. If only I could clear the cache of my memories so easily.",
            "Multi-Kill!": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Finisher!": "Divided and conquered. Just like my soul.",
            "Precision Strike!": "Calculated. Every variable accounted for, unlike my past.",
            "Overkill!": "Excessive force. A bit like how love subtracted everything from me.",
            "Retribution!": "An eye for an eye, a byte for a byte. The equation balances, even if my heart never will.",
            "Combat Ready!": "Systems online. Ready to integrate some pain, though my emotional processors are still offline.",
            "Defensive Stance!": "Holding my ground. A constant, unlike the variables in my life.",
            "Hidden Path Found!": "A new tangent. Maybe this one doesn't lead to another fractured dimension.",
            "Dead End!": "Figures. Just another cul-de-sac in this infinite loop of despair.",
            "Map Cleared!": "All threats nullified. If only I could clear the cache of my memories so easily.",
            "Uncharted Territory!": "Venturing into the unknown. A lot like trying to understand human emotion.",
            "Full Recovery!": "Health matrix restored. Too bad there's no patch for a broken heart.",
            "Resourceful!": "Optimizing my intake. Every bit counts when you're running on empty, inside and out.",
            "Health Drain!": "My vitals are degrading. This feels... logarithmically familiar.",
            "Level Up!": "Another iteration. The numbers grow, but the emptiness remains a constant.",
            "Momentum!": "The algorithm is flowing. A rare moment of positive progression in a negatively charged existence.",
            "Unstoppable!": "I'm an integer, moving forward, indivisible. Can't say the same for my past.",
            "Survival Mode": "Self-preservation protocols engaged. Sometimes the best solution is simply... not dying."
        };

        /**
         * Converts a hexadecimal color string to HSL (Hue, Saturation, Lightness) values.
         * @param {string} hex - The hexadecimal color string (e.g., "#RRGGBB").
         * @returns {Array<number>} An array [h, s, l] where h is 0-360, s and l are 0-100.
         */
        function hexToHsl(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            r /= 255;
            g /= 255;
            b /= 255;

            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [h * 360, s * 100, l * 100];
        }

        /**
         * Converts HSL (Hue, Saturation, Lightness) values to a hexadecimal color string.
         * @param {number} h - Hue (0-360).
         * @param {number} s - Saturation (0-100).
         * @param {number} l - Lightness (0-100).
         * @returns {string} The hexadecimal color string (e.g., "#RRGGBB").
         */
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0'); // convert to Hex and pad with 0
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        /**
         * Calculates an interpolated color based on a base hexadecimal color and a health ratio.
         * Color becomes darker and muted with lower health ratio, and bright and rich (not lightened) with higher health ratio.
         * @param {string} baseHexColor - The base hexadecimal color (e.g., "#0000CC").
         * @param {number} currentValue - The current health value.
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {string} The interpolated hexadecimal color.
         */
        function getHealthColor(baseHexColor, currentValue, thresholdValue) {
            const [h, s_base_original, l_base_original] = hexToHsl(baseHexColor);

            // Calculate ratio, capping at 1.0 to ensure visuals don't exceed 100% intensity
            const clampedRatio = Math.max(0, Math.min(1, currentValue / thresholdValue));

            // Define ranges for saturation and lightness based on desired effect
            // Low power: darker and muted (low saturation, low lightness)
            // High power: bright and rich (high saturation, mid lightness, not lightened)

            const minSaturation = 20; // Muted
            const maxSaturation = 90; // Bright/Rich (e.g., fire engine red would be high sat)

            const minLightness = 15; // Darker at low power
            const maxLightness = 50; // Mid-range for rich colors (like fire engine red)

            // Interpolate saturation: from muted to rich
            const s = minSaturation + (maxSaturation - minSaturation) * clampedRatio;

            // Interpolate lightness: from darker to mid-range.
            // When clampedRatio is 0, l = minLightness (15).
            // When clampedRatio is 1, l = maxLightness (50).
            const l = minLightness + (maxLightness - minLightness) * clampedRatio;

            return hslToHex(h, s, l);
        }

        /**
         * Calculates an interpolated font weight based on a value.
         * Font becomes thinner with lower value and thicker with higher value.
         * @param {number} currentValue - The current value (health, level, pickup amount).
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {number} The interpolated font weight (100-900).
         */
        function getFontWeight(currentValue, thresholdValue) {
            // Normalize value relative to the scaling range (MIN_HEALTH_FOR_VISUAL_EFFECTS to thresholdValue)
            const normalizedValue = Math.max(0, Math.min(1, (currentValue - MIN_HEALTH_FOR_VISUAL_EFFECTS) / (thresholdValue - MIN_HEALTH_FOR_VISUAL_EFFECTS)));

            const minWeight = 100; // Very thin
            const maxWeight = 900; // Full thickness (Black/Heavy)
            return Math.floor(minWeight + (maxWeight - minWeight) * normalizedValue);
        }

        /**
         * Calculates an interpolated opacity based on a value.
         * Opacity scales from MIN_OPACITY_AT_LOW_HEALTH at MIN_HEALTH_FOR_VISUAL_EFFECTS to full opacity at max value.
         * @param {number} currentValue - The current value (health, level, pickup amount).
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {number} The interpolated opacity (0.0 to 1.0).
         */
        function getOpacity(currentValue, thresholdValue) {
            // Normalize value relative to the scaling range (MIN_HEALTH_FOR_VISUAL_EFFECTS to thresholdValue)
            const normalizedValue = Math.max(0, Math.min(1, (currentValue - MIN_HEALTH_FOR_VISUAL_EFFECTS) / (thresholdValue - MIN_HEALTH_FOR_VISUAL_EFFECTS)));

            const minOpacity = MIN_OPACITY_AT_LOW_HEALTH; // Almost full transparency
            const maxOpacity = 1.0; // Full opacity
            return minOpacity + (maxOpacity - minOpacity) * normalizedValue;
        }

        /**
         * Adds an activity log entry for enemy kills.
         * @param {object} player - The player object.
         * @param {object} enemy - The enemy that was killed.
         * @param {number} playerDamage - Damage dealt by player to enemy.
         * @param {number} enemyDamage - Damage dealt by enemy to player.
         */
        /**
         * Updates the event title and message at the top of the screen
         * @param {string} eventName - The name of the event to display
         */
        function updateEventTitle(eventName) {
            // Update title
            currentEventTitle = eventName;
            eventTitle.textContent = eventName;
            eventTitle.style.display = 'block';
            
            // Clear any existing timeout
            if (eventTitleTimeout) {
                clearTimeout(eventTitleTimeout);
            }
            
            // Set new timeout to clear the title
            eventTitleTimeout = setTimeout(() => {
                eventTitle.style.display = 'none';
                currentEventTitle = '';
            }, EVENT_TITLE_DURATION);

            // Add event message under title
            if (PLAYER_DIALOGUE[eventName]) {
                const container = document.getElementById('eventMessagesContainer');
                const messageElement = document.createElement('div');
                messageElement.className = 'event-message';
                messageElement.textContent = PLAYER_DIALOGUE[eventName];
                
                container.appendChild(messageElement);
                
                // Remove the message after duration
                setTimeout(() => {
                    messageElement.remove();
                }, EVENT_TITLE_DURATION);
            }
        }

        /**
         * Legacy function - enhanced to use the new categorized system
         * @param {string} message - The message to display (can contain HTML)
         */
        function addKillMessage(message) {
            // Convert to popup message instead of using old message area
            showPopupMessage(message, player.x, player.y, 'combat');
        }

        // Popup message system functions
        function showPopupMessage(text, worldX, worldY, type = 'combat') {
            // Convert world coordinates to screen coordinates using cached tile calculations
            const screenX = (worldX * cachedTileCalculations.currentRenderTileSize) + cachedTileCalculations.currentRenderOffsetX;
            const screenY = (worldY * cachedTileCalculations.currentRenderTileSize) + cachedTileCalculations.currentRenderOffsetY;
            
            // For player messages, position next to character with overlap prevention
            const isPlayerMessage = (worldX === player.x && worldY === player.y);
            const finalPos = isPlayerMessage ? 
                findSafePlayerMessagePosition(screenX, screenY) : 
                findSafeMessagePosition(screenX, screenY);
            
            const popup = {
                id: ++popupIdCounter,
                text: text,
                x: finalPos.x,
                y: finalPos.y,
                type: type,
                startTime: performance.now(),
                opacity: 0.15,
                element: null
            };

            // Create DOM element for the popup
            const element = document.createElement('div');
            element.className = `popup-message ${type}`;
            
            // Strip HTML tags and use plain text only to prevent code from showing
            const cleanText = text.replace(/<[^>]*>/g, '').replace(/&[^;]*;/g, '');
            element.textContent = cleanText;
            
            element.style.left = `${finalPos.x}px`;
            element.style.top = `${finalPos.y}px`;
            
            document.body.appendChild(element);
            popup.element = element;
            
            popupMessages.push(popup);
            
            // Auto-remove after duration
            setTimeout(() => {
                removePopupMessage(popup.id);
            }, POPUP_DURATION);
        }

        function findSafePlayerMessagePosition(playerScreenX, playerScreenY) {
            const gameContainer = document.getElementById('gameContainer');
            const containerRect = gameContainer ? gameContainer.getBoundingClientRect() : 
                { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
            
            const messageWidth = 200;
            const messageHeight = 30;
            const characterOffset = cachedTileCalculations.currentRenderTileSize * 1.5; // Distance from character
            const messageSpacing = 35; // Vertical spacing between multiple messages
            
            // Preferred positions around the character (right, left, top, bottom)
            const positions = [
                { x: playerScreenX + characterOffset, y: playerScreenY }, // Right
                { x: playerScreenX - characterOffset - messageWidth, y: playerScreenY }, // Left  
                { x: playerScreenX - messageWidth/2, y: playerScreenY - characterOffset - messageHeight }, // Top
                { x: playerScreenX - messageWidth/2, y: playerScreenY + characterOffset } // Bottom
            ];
            
            // Get existing popup message positions for overlap checking
            const existingPopupPositions = popupMessages.map(popup => ({
                x: popup.x,
                y: popup.y,
                width: messageWidth,
                height: messageHeight
            }));
            
            // Try each position and find one without overlaps
            for (const position of positions) {
                let currentY = position.y;
                let attempts = 0;
                const maxAttempts = 5;
                
                while (attempts < maxAttempts) {
                    // Clamp to screen bounds
                    const clampedX = Math.max(10, Math.min(position.x, containerRect.width - messageWidth - 10));
                    const clampedY = Math.max(50, Math.min(currentY, containerRect.height - messageHeight - 10));
                    
                    // Check for overlap with existing popup messages
                    const hasOverlap = existingPopupPositions.some(existing => {
                        return !(clampedX + messageWidth < existing.x || 
                                clampedX > existing.x + existing.width ||
                                clampedY + messageHeight < existing.y || 
                                clampedY > existing.y + existing.height);
                    });
                    
                    if (!hasOverlap) {
                        return { x: clampedX, y: clampedY };
                    }
                    
                    // If there's overlap, try the next vertical position
                    currentY += messageSpacing;
                    attempts++;
                }
            }
            
            // Fallback: use the original positioning system if no safe position found
            return findSafeMessagePosition(playerScreenX, playerScreenY);
        }

        function findSafeMessagePosition(preferredX, preferredY) {
            const gameContainer = document.getElementById('gameContainer');
            const containerRect = gameContainer ? gameContainer.getBoundingClientRect() : 
                { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
            
            // Ensure message stays within screen bounds with larger margins
            let x = Math.max(50, Math.min(preferredX, containerRect.width - 300));
            let y = Math.max(80, Math.min(preferredY, containerRect.height - 60)); // Account for top bar
            
            // Check for overlaps with player and enemies (avoid covering agents)
            const agentPositions = [];
            
            // Add player position
            if (player) {
                const playerScreenX = (player.x * cachedTileCalculations.currentRenderTileSize) + cachedTileCalculations.currentRenderOffsetX;
                const playerScreenY = (player.y * cachedTileCalculations.currentRenderTileSize) + cachedTileCalculations.currentRenderOffsetY;
                agentPositions.push({ x: playerScreenX, y: playerScreenY, size: cachedTileCalculations.currentRenderTileSize });
            }
            
            // Add enemy positions
            if (enemies) {
                enemies.forEach(enemy => {
                    const enemyScreenX = (enemy.x * cachedTileCalculations.currentRenderTileSize) + cachedTileCalculations.currentRenderOffsetX;
                    const enemyScreenY = (enemy.y * cachedTileCalculations.currentRenderTileSize) + cachedTileCalculations.currentRenderOffsetY;
                    agentPositions.push({ x: enemyScreenX, y: enemyScreenY, size: cachedTileCalculations.currentRenderTileSize });
                });
            }
            
            // Check for overlaps and adjust position with larger avoidance distance
            const messageWidth = 200; // Approximate message width for bigger text
            const messageHeight = 30;  // Approximate message height for bigger text
            const avoidDistance = cachedTileCalculations.currentRenderTileSize * 2; // Double the avoidance distance
            
            for (const agent of agentPositions) {
                const dx = x - agent.x;
                const dy = y - agent.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < avoidDistance) {
                    // Move message further away from agent - prefer corners
                    const angle = Math.atan2(dy, dx);
                    x = agent.x + Math.cos(angle) * avoidDistance;
                    y = agent.y + Math.sin(angle) * avoidDistance;
                    
                    // Re-clamp to screen bounds with larger margins
                    x = Math.max(50, Math.min(x, containerRect.width - messageWidth));
                    y = Math.max(80, Math.min(y, containerRect.height - messageHeight));
                }
            }
            
            return { x, y };
        }

        function removePopupMessage(id) {
            const index = popupMessages.findIndex(msg => msg.id === id);
            if (index !== -1) {
                const popup = popupMessages[index];
                if (popup.element) {
                    popup.element.classList.add('fade-out');
                    setTimeout(() => {
                        if (popup.element && popup.element.parentNode) {
                            popup.element.parentNode.removeChild(popup.element);
                        }
                    }, POPUP_FADE_DURATION);
                }
                popupMessages.splice(index, 1);
            }
        }

        function updatePopupMessages() {
            const now = performance.now();
            
            // Update existing messages
            popupMessages.forEach(popup => {
                const elapsed = now - popup.startTime;
                const fadeStart = POPUP_DURATION - POPUP_FADE_DURATION;
                
                if (elapsed > fadeStart) {
                    const fadeProgress = (elapsed - fadeStart) / POPUP_FADE_DURATION;
                    popup.opacity = Math.max(0, 0.15 - (fadeProgress * 0.15));
                    if (popup.element) {
                        popup.element.style.opacity = popup.opacity;
                    }
                }
            });
            
            // Remove expired messages
            popupMessages = popupMessages.filter(popup => {
                const elapsed = now - popup.startTime;
                if (elapsed > POPUP_DURATION) {
                    if (popup.element && popup.element.parentNode) {
                        popup.element.parentNode.removeChild(popup.element);
                    }
                    return false;
                }
                return true;
            });
        }

        function addActivityLogEntry(player, enemy, playerDamage, enemyDamage) {
            // Calculate colors based on current health
            const playerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD);
            const enemyColor = getHealthColor(FIXED_COLOR_ENEMY, enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD);
            
            // Add to activity log with colors (keeping for backward compatibility, but not displayed)
            activityLog.unshift({
                playerName: player.name,
                enemyName: enemy.name,
                playerColor: playerColor,
                enemyColor: enemyColor,
                playerDamage: playerDamage,
                enemyDamage: enemyDamage
            });
            
            // Keep only recent entries
            if (activityLog.length > MAX_ACTIVITY_LOG_ENTRIES) {
                activityLog.pop();
            }
            
            // Generate intelligent kill announcement
            const killMessage = generateIntelligentKillMessage(player, enemy, playerDamage, enemyDamage, playerColor, enemyColor);
            addKillMessage(killMessage);
        }

        /**
         * Generates an intelligent kill message based on enemy strength, flow, and damage sacrificed
         */
        function generateIntelligentKillMessage(player, enemy, playerDamage, enemyDamage, playerColor, enemyColor) {
            // Calculate enemy strength metrics
            const enemyStrength = enemy.initialHealth;
            const isStrongEnemy = enemyStrength >= 8;
            const isVeryStrongEnemy = enemyStrength >= 15;
            const isEliteEnemy = enemyStrength >= 25;
            
            // Calculate enemy flow (anger/aggression level)
            const enemyFlow = enemy.totalDamageTakenByThisEnemy > 0 
                ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1)
                : (enemy.flowLevel || 0);
            const isAngryEnemy = enemyFlow >= 3;
            const isEnragedEnemy = enemyFlow >= 6;
            const isBerserkEnemy = enemyFlow >= 10;
            
            // Calculate damage sacrificed (health lost to kill this enemy)
            const damageSacrificed = enemyDamage;
            const isHighSacrifice = damageSacrificed >= 5;
            const isExtremeSacrifice = damageSacrificed >= 10;
            const isPerfectKill = damageSacrificed === 0;
            
            // Determine kill method efficiency
            const wasOneShot = enemy.initialHealth === enemy.initialHealth && playerDamage >= enemy.initialHealth;
            const wasEfficient = playerDamage >= enemyStrength * 0.8; // Dealt most damage in final blow
            const wasGrindingFight = playerDamage < enemyStrength * 0.3; // Long drawn out fight
            
            // Generate contextual verbs and descriptions
            let actionVerb = "eliminated";
            let enemyDescriptor = "";
            let contextualDescription = "";
            
            // Choose action verb based on kill circumstances
            if (wasOneShot) {
                if (isVeryStrongEnemy) {
                    actionVerb = "obliterated";
                } else if (isStrongEnemy) {
                    actionVerb = "annihilated";
                } else {
                    actionVerb = "executed";
                }
            } else if (isPerfectKill) {
                actionVerb = "outmaneuvered";
            } else if (isExtremeSacrifice) {
                actionVerb = "barely survived";
            } else if (wasGrindingFight) {
                actionVerb = "wore down";
            } else if (wasEfficient) {
                actionVerb = "dispatched";
            } else {
                actionVerb = "defeated";
            }
            
            // Generate enemy descriptors based on strength and flow
            if (isEliteEnemy) {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the raging titan";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the furious behemoth";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the formidable giant";
                } else {
                    enemyDescriptor = "the mighty fortress";
                }
            } else if (isVeryStrongEnemy) {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the berserk warrior";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the enraged brute";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the aggressive veteran";
                } else {
                    enemyDescriptor = "the hardened opponent";
                }
            } else if (isStrongEnemy) {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the frenzied fighter";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the rabid combatant";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the hostile adversary";
                } else {
                    enemyDescriptor = "the resilient foe";
                }
            } else {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the wild scrapper";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the maddened opponent";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the agitated enemy";
                } else {
                    enemyDescriptor = "the basic threat";
                }
            }
            
            // Add contextual descriptions based on sacrifice and method
            if (isPerfectKill) {
                if (isEliteEnemy) {
                    contextualDescription = " without taking a scratch - a masterful display";
                } else if (isStrongEnemy) {
                    contextualDescription = " flawlessly, untouched by retaliation";
                } else {
                    contextualDescription = " with surgical precision";
                }
            } else if (isExtremeSacrifice) {
                if (wasGrindingFight) {
                    contextualDescription = ` in a brutal war of attrition (${damageSacrificed} HP lost)`;
                } else {
                    contextualDescription = ` at great personal cost (${damageSacrificed} HP sacrificed)`;
                }
            } else if (isHighSacrifice) {
                contextualDescription = ` through sheer determination (${damageSacrificed} HP lost)`;
            } else if (wasOneShot) {
                if (isEliteEnemy) {
                    contextualDescription = " in a single, earth-shattering blow";
                } else if (isStrongEnemy) {
                    contextualDescription = " with one decisive strike";
                } else {
                    contextualDescription = " instantly";
                }
            } else if (wasGrindingFight) {
                contextualDescription = " after a prolonged engagement";
            } else if (wasEfficient) {
                contextualDescription = " with calculated efficiency";
            }
            
            // Special cases for dramatic effect
            if (isBerserkEnemy && isPerfectKill) {
                contextualDescription = " despite their berserk fury, emerging unscathed";
            } else if (isEliteEnemy && wasOneShot) {
                contextualDescription = " in a legendary display of overwhelming power";
            } else if (isAngryEnemy && isExtremeSacrifice) {
                contextualDescription = ` in a savage exchange of blows (${damageSacrificed} HP traded for victory)`;
            }
            
            // Construct the final message
            const playerSpan = `<span style="background-color: ${playerColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${player.name}</span>`;
            const enemySpan = `<span style="background-color: ${enemyColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${enemy.name}</span>`;
            
            return `${playerSpan} ${actionVerb} ${enemySpan}, ${enemyDescriptor}${contextualDescription}`;
        }

        /**
         * Updates the activity log display in the right panel.
         */
        function updateActivityLogDisplay() {
            const rightPanel = document.getElementById('rightPanel');
            rightPanel.innerHTML = ''; // Clear existing entries
            
            activityLog.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'activity-log-entry';
                
                // Dim older entries
                if (index > 0) {
                    entryDiv.classList.add('dimmed');
                }
                
                if (entry.isMajorEvent) {
                    // Major event entry with warning symbol
                    entryDiv.style.backgroundColor = '#2a2a00'; // Dark yellow background
                    entryDiv.style.border = '1px solid #ffaa00'; // Orange border
                    entryDiv.style.padding = '4px';
                    entryDiv.style.borderRadius = '3px';
                    entryDiv.style.marginBottom = '2px';
                    
                    const warningSymbol = document.createElement('span');
                    warningSymbol.innerHTML = '⚠️ ';
                    warningSymbol.style.color = '#ffaa00';
                    warningSymbol.style.fontWeight = 'bold';
                    
                    const messageText = document.createElement('span');
                    messageText.innerHTML = entry.message;
                    messageText.style.color = '#ffffff';
                    
                    entryDiv.appendChild(warningSymbol);
                    entryDiv.appendChild(messageText);
                } else {
                    // Regular combat entry
                    const mainText = document.createElement('div');
                    mainText.innerHTML = `<span class="player-name" style="background-color: ${entry.playerColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${entry.playerName}</span> has killed <span class="enemy-name" style="background-color: ${entry.enemyColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${entry.enemyName}</span>`;
                    entryDiv.appendChild(mainText);
                }
                
                rightPanel.appendChild(entryDiv);
            });
        }

        /**
         * Sets up the color scheme for the level.
         */
        function setupColors() {
            COLOR_FLOOR = '#333333'; // Dark grey for playable floor tiles
            COLOR_WALL = '#4A3728'; // Brown base color for walls - distinct when lit
        }

        /**
         * Adds an event message to the game interface.
         * This will display both the event name and its dialogue at the top of the screen.
         * @param {string} eventName - The name of the event that occurred.
         */
        function addEventMessage(eventName) {
            updateEventTitle(eventName);
        }

        /**
         * Initializes the game map with walls.
         */
        function initializeMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
        }

        /**
         * Generates procedural paths using a random walk algorithm.
         * @param {number} steps - The number of steps for the random walk.
         */
        function generatePaths(steps) {
            console.log('Starting map generation:', { steps, mapWidth: dynamicMapWidth, mapHeight: dynamicMapHeight });
            
            // Initialize starting point in the middle
            let currentX = Math.floor(dynamicMapWidth / 2);
            let currentY = Math.floor(dynamicMapHeight / 2);

            currentX = Math.max(1, Math.min(dynamicMapWidth - 2, currentX));
            currentY = Math.max(1, Math.min(dynamicMapHeight - 2, currentY));

            // Create initial map
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Start with a floor tile in the middle
            gameMap[currentY][currentX] = TILE_FLOOR;

            // Generate paths
            for (let i = 0; i < steps; i++) {
                // Pick a random direction (0: up, 1: right, 2: down, 3: left)
                const direction = Math.floor(Math.random() * 4);
                let nextX = currentX;
                let nextY = currentY;

                switch (direction) {
                    case 0: nextY--; break; // Up
                    case 1: nextX++; break; // Right
                    case 2: nextY++; break; // Down
                    case 3: nextX--; break; // Left
                }

                // Check bounds and make floor tile if valid
                if (nextX >= 1 && nextX < dynamicMapWidth - 1 && nextY >= 1 && nextY < dynamicMapHeight - 1) {
                    gameMap[nextY][nextX] = TILE_FLOOR;
                    currentX = nextX;
                    currentY = nextY;
                }
            }
        }

        /**
         * Gets the current world configuration
         * @returns {object} The current world configuration
         */
        function getCurrentWorld() {
            return WORLDS[currentWorld];
        }

        /**
         * Checks if a world can be unlocked based on total score
         * @param {number} worldNumber - The world number to check
         * @returns {boolean} True if the world can be unlocked
         */
        function canUnlockWorld(worldNumber) {
            if (!WORLDS[worldNumber]) return false;
            return totalPlayerScore >= WORLDS[worldNumber].unlockRequirement;
        }

        /**
         * Unlocks worlds based on current total score
         */
        function checkAndUnlockWorlds() {
            for (let worldNum in WORLDS) {
                const worldNumber = parseInt(worldNum);
                if (!unlockedWorlds.includes(worldNumber) && canUnlockWorld(worldNumber)) {
                    unlockedWorlds.push(worldNumber);
                    console.log(`World ${worldNumber} (${WORLDS[worldNumber].name}) unlocked!`);
                }
            }
        }

        /**
         * Sets up colors for the current world
         */
        function setupWorldColors() {
            const world = getCurrentWorld();
            COLOR_FLOOR = world.colors.floor;  // Back to normal dark gray
            COLOR_WALL = world.colors.wall;
            FIXED_COLOR_STAIRS = world.colors.stairs;
            FIXED_COLOR_PLAYER = world.colors.player;
            FIXED_COLOR_ENEMY = world.colors.enemy;
            
            // Reset canvas style cache to ensure colors are properly applied
            lastFillStyle = null;
            lastStrokeStyle = null;
            lastFont = null;
            
            // Update the background color to match the world's wall color
            updateBackgroundColor();
        }

        /**
         * Updates the game wrapper background color to match the current world theme
         */
        function updateBackgroundColor() {
            const world = getCurrentWorld();
            
            // Force everything to black for consistent background
            const gameWrapper = document.querySelector('.game-wrapper');
            if (gameWrapper) {
                gameWrapper.style.backgroundColor = '#000000';
            }
            
            // Also force CSS custom properties to black
            document.documentElement.style.setProperty('--world-wall-color', '#000000');
            
            // Force override in case something else is interfering
            document.body.style.backgroundColor = '#000000';
            document.documentElement.style.backgroundColor = '#000000';
        }

        /**
         * Generates a desert-themed map with circular oasis rooms
         */
        /**
         * Generates a desert-themed map with irregular islands and narrow bridges
         */
        /**
         * Generates a basic map with one long hallway and side chambers
         */
        function generateBasicMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create main long hallway running horizontally through the center
            const hallwayY = Math.floor(dynamicMapHeight / 2);
            const hallwayWidth = 3; // 3-tile wide hallway
            
            // Create the main hallway
            for (let y = hallwayY - 1; y <= hallwayY + 1; y++) {
                for (let x = 2; x < dynamicMapWidth - 2; x++) {
                    if (y >= 0 && y < dynamicMapHeight) {
                        gameMap[y][x] = TILE_FLOOR;
                    }
                }
            }
            
            // Add side chambers branching off the main hallway
            const numChambers = Math.floor(dynamicMapWidth / 8); // One chamber every 8 tiles
            
            for (let i = 0; i < numChambers; i++) {
                const chamberCenterX = 8 + i * Math.floor((dynamicMapWidth - 16) / numChambers);
                const side = i % 2 === 0 ? -1 : 1; // Alternate sides
                
                const chamberWidth = 4 + Math.floor(Math.random() * 3); // Width 4-6
                const chamberHeight = 3 + Math.floor(Math.random() * 3); // Height 3-5
                
                // Create connecting corridor from hallway to chamber
                const corridorLength = 2 + Math.floor(Math.random() * 3); // Length 2-4
                for (let c = 1; c <= corridorLength; c++) {
                    const corridorY = hallwayY + (side * c);
                    if (corridorY >= 0 && corridorY < dynamicMapHeight) {
                        gameMap[corridorY][chamberCenterX] = TILE_FLOOR;
                    }
                }
                
                // Create the chamber
                const chamberY = hallwayY + (side * (corridorLength + Math.floor(chamberHeight / 2)));
                for (let dy = -Math.floor(chamberHeight / 2); dy <= Math.floor(chamberHeight / 2); dy++) {
                    for (let dx = -Math.floor(chamberWidth / 2); dx <= Math.floor(chamberWidth / 2); dx++) {
                        const x = chamberCenterX + dx;
                        const y = chamberY + dy;
                        if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                            gameMap[y][x] = TILE_FLOOR;
                        }
                    }
                }
            }
        }

        function generateDesertMap() {
            // Ant colony style - multiple chambers connected by narrow tunnels
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            const numChambers = Math.max(6, Math.floor(dynamicMapWidth * dynamicMapHeight / 30));
            const chambers = [];
            
            // Create main chambers (ant colony rooms)
            for (let i = 0; i < numChambers; i++) {
                let attempts = 0;
                let chamberX, chamberY;
                
                do {
                    chamberX = 4 + Math.floor(Math.random() * (dynamicMapWidth - 8));
                    chamberY = 4 + Math.floor(Math.random() * (dynamicMapHeight - 8));
                    attempts++;
                } while (attempts < 50 && chambers.some(chamber => 
                    Math.abs(chamber.x - chamberX) < 8 || Math.abs(chamber.y - chamberY) < 8
                ));
                
                const chamberType = Math.random();
                let width, height;
                
                if (chamberType < 0.3) {
                    // Large nursery chamber
                    width = 6 + Math.floor(Math.random() * 3);
                    height = 6 + Math.floor(Math.random() * 3);
                } else if (chamberType < 0.6) {
                    // Medium storage chamber
                    width = 4 + Math.floor(Math.random() * 2);
                    height = 4 + Math.floor(Math.random() * 2);
                } else {
                    // Small worker chamber
                    width = 3 + Math.floor(Math.random() * 2);
                    height = 3 + Math.floor(Math.random() * 2);
                }
                
                chambers.push({ x: chamberX, y: chamberY, width, height, type: chamberType });
                
                // Create oval-shaped chamber
                for (let dy = -Math.floor(height/2); dy <= Math.floor(height/2); dy++) {
                    for (let dx = -Math.floor(width/2); dx <= Math.floor(width/2); dx++) {
                        const normalizedX = dx / (width/2);
                        const normalizedY = dy / (height/2);
                        const distance = normalizedX * normalizedX + normalizedY * normalizedY;
                        
                        if (distance <= 1.0 + Math.random() * 0.2) { // Slightly irregular edges
                            const x = chamberX + dx;
                            const y = chamberY + dy;
                            if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                gameMap[y][x] = TILE_FLOOR;
                            }
                        }
                    }
                }
            }
            
            // Create tunnel network connecting all chambers
            const tunnelNetwork = [];
            
            // Connect each chamber to at least 2 others for redundancy (like real ant colonies)
            for (let i = 0; i < chambers.length; i++) {
                const chamber = chambers[i];
                const connections = [];
                
                // Find 2-3 closest chambers to connect to
                const otherChambers = chambers.filter((_, idx) => idx !== i);
                otherChambers.sort((a, b) => {
                    const distA = Math.abs(a.x - chamber.x) + Math.abs(a.y - chamber.y);
                    const distB = Math.abs(b.x - chamber.x) + Math.abs(b.y - chamber.y);
                    return distA - distB;
                });
                
                // Connect to 2-3 nearest chambers
                const numConnections = Math.min(2 + Math.floor(Math.random() * 2), otherChambers.length);
                for (let j = 0; j < numConnections; j++) {
                    connections.push(otherChambers[j]);
                }
                
                // Create narrow tunnels (1 tile wide like ant tunnels)
                connections.forEach(targetChamber => {
                    let currentX = chamber.x;
                    let currentY = chamber.y;
                    
                    // Create winding tunnel path
                    while (currentX !== targetChamber.x || currentY !== targetChamber.y) {
                        if (currentX >= 0 && currentX < dynamicMapWidth && 
                            currentY >= 0 && currentY < dynamicMapHeight) {
                            gameMap[currentY][currentX] = TILE_FLOOR;
                        }
                        
                        // Add some randomness to create more natural ant-like tunnels
                        if (Math.random() < 0.7) {
                            // Move toward target most of the time
                            if (Math.abs(currentX - targetChamber.x) > Math.abs(currentY - targetChamber.y)) {
                                currentX += currentX < targetChamber.x ? 1 : -1;
                            } else {
                                currentY += currentY < targetChamber.y ? 1 : -1;
                            }
                        } else {
                            // Occasionally take a random direction for more organic paths
                            if (Math.random() < 0.5 && currentX !== targetChamber.x) {
                                currentX += currentX < targetChamber.x ? 1 : -1;
                            } else if (currentY !== targetChamber.y) {
                                currentY += currentY < targetChamber.y ? 1 : -1;
                            }
                        }
                    }
                });
            }
            
            // Add some dead-end tunnels for authenticity (ant colonies have many dead ends)
            const numDeadEnds = Math.floor(chambers.length / 2);
            for (let i = 0; i < numDeadEnds; i++) {
                const chamber = chambers[Math.floor(Math.random() * chambers.length)];
                const direction = Math.floor(Math.random() * 4); // 0=up, 1=right, 2=down, 3=left
                const length = 2 + Math.floor(Math.random() * 4);
                
                let currentX = chamber.x;
                let currentY = chamber.y;
                
                for (let step = 0; step < length; step++) {
                    switch(direction) {
                        case 0: currentY--; break;
                        case 1: currentX++; break;
                        case 2: currentY++; break;
                        case 3: currentX--; break;
                    }
                    
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                }
            }
        }

        /**
         * Generates an ice-themed map with extremely narrow caves
         */
        function generateIceMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create extremely narrow cave system - mostly 1-tile wide passages
            const numMainPaths = Math.max(3, Math.floor(dynamicMapWidth * dynamicMapHeight / 100));
            const paths = [];
            
            // Start from random positions along edges
            for (let i = 0; i < numMainPaths; i++) {
                let startX, startY;
                const edge = Math.floor(Math.random() * 4);
                
                switch(edge) {
                    case 0: // Top edge
                        startX = Math.floor(Math.random() * dynamicMapWidth);
                        startY = 1;
                        break;
                    case 1: // Right edge
                        startX = dynamicMapWidth - 2;
                        startY = Math.floor(Math.random() * dynamicMapHeight);
                        break;
                    case 2: // Bottom edge
                        startX = Math.floor(Math.random() * dynamicMapWidth);
                        startY = dynamicMapHeight - 2;
                        break;
                    case 3: // Left edge
                        startX = 1;
                        startY = Math.floor(Math.random() * dynamicMapHeight);
                        break;
                }
                
                paths.push({ x: startX, y: startY });
                
                // Create winding narrow cave from this starting point
                let currentX = startX;
                let currentY = startY;
                const pathLength = Math.floor(dynamicMapWidth * dynamicMapHeight / 8);
                let direction = Math.floor(Math.random() * 4); // 0=up, 1=right, 2=down, 3=left
                
                for (let step = 0; step < pathLength; step++) {
                    // Place floor tile
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                    
                    // Randomly change direction to create winding paths
                    if (Math.random() < 0.15) {
                        direction = Math.floor(Math.random() * 4);
                    }
                    
                    // Move in current direction
                    let nextX = currentX;
                    let nextY = currentY;
                    
                    switch(direction) {
                        case 0: nextY--; break; // Up
                        case 1: nextX++; break; // Right
                        case 2: nextY++; break; // Down
                        case 3: nextX--; break; // Left
                    }
                    
                    // Check bounds and change direction if hitting edge
                    if (nextX <= 0 || nextX >= dynamicMapWidth - 1 || 
                        nextY <= 0 || nextY >= dynamicMapHeight - 1) {
                        direction = (direction + 1 + Math.floor(Math.random() * 2)) % 4;
                        continue;
                    }
                    
                    currentX = nextX;
                    currentY = nextY;
                    
                    // Occasionally create very small alcoves (1-2 tiles)
                    if (Math.random() < 0.08) {
                        const alcoveDirection = (direction + 1 + Math.floor(Math.random() * 2)) % 4;
                        let alcoveX = currentX;
                        let alcoveY = currentY;
                        
                        switch(alcoveDirection) {
                            case 0: alcoveY--; break;
                            case 1: alcoveX++; break;
                            case 2: alcoveY++; break;
                            case 3: alcoveX--; break;
                        }
                        
                        if (alcoveX > 0 && alcoveX < dynamicMapWidth - 1 && 
                            alcoveY > 0 && alcoveY < dynamicMapHeight - 1) {
                            gameMap[alcoveY][alcoveX] = TILE_FLOOR;
                            
                            // Rarely add a second tile to the alcove
                            if (Math.random() < 0.3) {
                                switch(alcoveDirection) {
                                    case 0: alcoveY--; break;
                                    case 1: alcoveX++; break;
                                    case 2: alcoveY++; break;
                                    case 3: alcoveX--; break;
                                }
                                
                                if (alcoveX > 0 && alcoveX < dynamicMapWidth - 1 && 
                                    alcoveY > 0 && alcoveY < dynamicMapHeight - 1) {
                                    gameMap[alcoveY][alcoveX] = TILE_FLOOR;
                                }
                            }
                        }
                    }
                }
            }
            
            // Create connections between paths where they get close
            for (let y = 1; y < dynamicMapHeight - 1; y++) {
                for (let x = 1; x < dynamicMapWidth - 1; x++) {
                    if (gameMap[y][x] === TILE_FLOOR) {
                        // Look for nearby floor tiles to potentially connect to
                        const searchRadius = 3;
                        for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                            for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                                if (Math.abs(dx) + Math.abs(dy) === searchRadius && // Only check at exact distance
                                    Math.random() < 0.1) { // Low chance to keep caves narrow
                                    
                                    const checkX = x + dx;
                                    const checkY = y + dy;
                                    
                                    if (checkX > 0 && checkX < dynamicMapWidth - 1 && 
                                        checkY > 0 && checkY < dynamicMapHeight - 1 && 
                                        gameMap[checkY][checkX] === TILE_FLOOR) {
                                        
                                        // Create narrow connecting tunnel
                                        let connectX = x;
                                        let connectY = y;
                                        
                                        while (connectX !== checkX || connectY !== checkY) {
                                            if (connectX !== checkX) {
                                                connectX += connectX < checkX ? 1 : -1;
                                            } else if (connectY !== checkY) {
                                                connectY += connectY < checkY ? 1 : -1;
                                            }
                                            
                                            if (connectX > 0 && connectX < dynamicMapWidth - 1 && 
                                                connectY > 0 && connectY < dynamicMapHeight - 1) {
                                                gameMap[connectY][connectX] = TILE_FLOOR;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /**
         * Generates a forest-themed map with lots of tiny rooms
         */
        function generateForestMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create many tiny rooms (like clearings in a dense forest)
            const numTinyRooms = Math.floor(dynamicMapWidth * dynamicMapHeight / 15); // Many small rooms
            const rooms = [];
            
            for (let i = 0; i < numTinyRooms; i++) {
                let attempts = 0;
                let roomX, roomY;
                let roomSize;
                
                do {
                    roomX = 2 + Math.floor(Math.random() * (dynamicMapWidth - 4));
                    roomY = 2 + Math.floor(Math.random() * (dynamicMapHeight - 4));
                    roomSize = 1 + Math.floor(Math.random() * 2); // Size 1-2 (very tiny!)
                    attempts++;
                } while (attempts < 30 && rooms.some(room => 
                    Math.abs(room.x - roomX) < 4 && Math.abs(room.y - roomY) < 4
                ));
                
                if (attempts < 30) {
                    rooms.push({ x: roomX, y: roomY, size: roomSize });
                    
                    // Create tiny circular room
                    for (let dy = -roomSize; dy <= roomSize; dy++) {
                        for (let dx = -roomSize; dx <= roomSize; dx++) {
                            const distance = Math.abs(dx) + Math.abs(dy);
                            if (distance <= roomSize) {
                                const x = roomX + dx;
                                const y = roomY + dy;
                                if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                    gameMap[y][x] = TILE_FLOOR;
                                }
                            }
                        }
                    }
                }
            }
            
            // Create a network of narrow paths connecting the tiny rooms
            // Sort rooms by distance to create a minimum spanning tree-like connection
            const connected = new Set();
            const connections = [];
            
            if (rooms.length > 0) {
                connected.add(0); // Start with first room
                
                while (connected.size < rooms.length) {
                    let minDistance = Infinity;
                    let bestConnection = null;
                    
                    // Find closest unconnected room to any connected room
                    for (let connectedIdx of connected) {
                        for (let i = 0; i < rooms.length; i++) {
                            if (!connected.has(i)) {
                                const distance = Math.abs(rooms[connectedIdx].x - rooms[i].x) + 
                                               Math.abs(rooms[connectedIdx].y - rooms[i].y);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    bestConnection = { from: connectedIdx, to: i };
                                }
                            }
                        }
                    }
                    
                    if (bestConnection) {
                        connected.add(bestConnection.to);
                        connections.push(bestConnection);
                    } else {
                        break; // No more connections possible
                    }
                }
            }
            
            // Create the connecting paths
            connections.forEach(connection => {
                const startRoom = rooms[connection.from];
                const endRoom = rooms[connection.to];
                
                let currentX = startRoom.x;
                let currentY = startRoom.y;
                
                // Create narrow winding path
                while (currentX !== endRoom.x || currentY !== endRoom.y) {
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                    
                    // Add organic curves to paths
                    if (Math.random() < 0.8) {
                        // Move toward target most of the time
                        if (Math.abs(currentX - endRoom.x) > Math.abs(currentY - endRoom.y)) {
                            currentX += currentX < endRoom.x ? 1 : -1;
                        } else {
                            currentY += currentY < endRoom.y ? 1 : -1;
                        }
                    } else {
                        // Occasionally take a detour for natural feel
                        const randomDir = Math.floor(Math.random() * 4);
                        switch(randomDir) {
                            case 0: if (currentY > 1) currentY--; break;
                            case 1: if (currentX < dynamicMapWidth - 2) currentX++; break;
                            case 2: if (currentY < dynamicMapHeight - 2) currentY++; break;
                            case 3: if (currentX > 1) currentX--; break;
                        }
                    }
                }
            });
            
            // Add some additional random connections for redundancy (like animal trails)
            const numExtraConnections = Math.floor(rooms.length / 4);
            for (let i = 0; i < numExtraConnections; i++) {
                const room1 = rooms[Math.floor(Math.random() * rooms.length)];
                const room2 = rooms[Math.floor(Math.random() * rooms.length)];
                
                if (room1 !== room2) {
                    const distance = Math.abs(room1.x - room2.x) + Math.abs(room1.y - room2.y);
                    
                    // Only connect if reasonably close
                    if (distance < Math.min(dynamicMapWidth, dynamicMapHeight) / 2) {
                        let currentX = room1.x;
                        let currentY = room1.y;
                        
                        while (currentX !== room2.x || currentY !== room2.y) {
                            if (currentX >= 0 && currentX < dynamicMapWidth && 
                                currentY >= 0 && currentY < dynamicMapHeight) {
                                gameMap[currentY][currentX] = TILE_FLOOR;
                            }
                            
                            if (currentX !== room2.x) currentX += currentX < room2.x ? 1 : -1;
                            if (currentY !== room2.y && Math.random() < 0.7) currentY += currentY < room2.y ? 1 : -1;
                        }
                    }
                }
            }
        }

        /**
         * Generates a crystal-themed map with a bunch of houses (rectangular structures)
         */
        function generateCrystalMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create a village/town layout with many house-like rectangular structures
            const numHouses = Math.max(8, Math.floor(dynamicMapWidth * dynamicMapHeight / 25));
            const houses = [];
            
            for (let i = 0; i < numHouses; i++) {
                let attempts = 0;
                let houseX, houseY, houseWidth, houseHeight;
                
                do {
                    houseX = 2 + Math.floor(Math.random() * (dynamicMapWidth - 8));
                    houseY = 2 + Math.floor(Math.random() * (dynamicMapHeight - 8));
                    houseWidth = 3 + Math.floor(Math.random() * 4); // Width 3-6
                    houseHeight = 3 + Math.floor(Math.random() * 4); // Height 3-6
                    attempts++;
                } while (attempts < 50 && houses.some(house => 
                    !(houseX + houseWidth + 2 < house.x || 
                      house.x + house.width + 2 < houseX || 
                      houseY + houseHeight + 2 < house.y || 
                      house.y + house.height + 2 < houseY)
                ));
                
                if (attempts < 50 && 
                    houseX + houseWidth < dynamicMapWidth - 1 && 
                    houseY + houseHeight < dynamicMapHeight - 1) {
                    
                    houses.push({ 
                        x: houseX, 
                        y: houseY, 
                        width: houseWidth, 
                        height: houseHeight 
                    });
                    
                    // Create rectangular house structure
                    for (let dy = 0; dy < houseHeight; dy++) {
                        for (let dx = 0; dx < houseWidth; dx++) {
                            const x = houseX + dx;
                            const y = houseY + dy;
                            
                            if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                gameMap[y][x] = TILE_FLOOR;
                            }
                        }
                    }
                    
                    // Add some internal structure to larger houses
                    if (houseWidth >= 5 && houseHeight >= 5) {
                        // Add internal walls to create rooms
                        const numInternalWalls = 1 + Math.floor(Math.random() * 2);
                        
                        for (let w = 0; w < numInternalWalls; w++) {
                            if (Math.random() < 0.5 && houseWidth >= 5) {
                                // Vertical internal wall
                                const wallX = houseX + 2 + Math.floor(Math.random() * (houseWidth - 4));
                                for (let dy = 1; dy < houseHeight - 1; dy++) {
                                    const y = houseY + dy;
                                    if (Math.random() < 0.7) { // Leave some gaps for doors
                                        gameMap[y][wallX] = TILE_WALL;
                                    }
                                }
                            }
                            
                            if (Math.random() < 0.5 && houseHeight >= 5) {
                                // Horizontal internal wall
                                const wallY = houseY + 2 + Math.floor(Math.random() * (houseHeight - 4));
                                for (let dx = 1; dx < houseWidth - 1; dx++) {
                                    const x = houseX + dx;
                                    if (Math.random() < 0.7) { // Leave some gaps for doors
                                        gameMap[wallY][x] = TILE_WALL;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Create street/path network connecting houses
            // First, create main streets (horizontal and vertical)
            const numMainStreets = Math.max(2, Math.floor(Math.max(dynamicMapWidth, dynamicMapHeight) / 15));
            
            // Vertical main streets
            for (let i = 0; i < Math.floor(numMainStreets / 2); i++) {
                const streetX = Math.floor((i + 1) * dynamicMapWidth / (Math.floor(numMainStreets / 2) + 1));
                
                for (let y = 0; y < dynamicMapHeight; y++) {
                    if (streetX >= 0 && streetX < dynamicMapWidth) {
                        // Only place street if not inside a house
                        let insideHouse = false;
                        for (let house of houses) {
                            if (streetX >= house.x && streetX < house.x + house.width &&
                                y >= house.y && y < house.y + house.height) {
                                insideHouse = true;
                                break;
                            }
                        }
                        
                        if (!insideHouse) {
                            gameMap[y][streetX] = TILE_FLOOR;
                        }
                    }
                }
            }
            
            // Horizontal main streets
            for (let i = 0; i < Math.ceil(numMainStreets / 2); i++) {
                const streetY = Math.floor((i + 1) * dynamicMapHeight / (Math.ceil(numMainStreets / 2) + 1));
                
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (streetY >= 0 && streetY < dynamicMapHeight) {
                        // Only place street if not inside a house
                        let insideHouse = false;
                        for (let house of houses) {
                            if (x >= house.x && x < house.x + house.width &&
                                streetY >= house.y && streetY < house.y + house.height) {
                                insideHouse = true;
                                break;
                            }
                        }
                        
                        if (!insideHouse) {
                            gameMap[streetY][x] = TILE_FLOOR;
                        }
                    }
                }
            }
            
            // Connect each house to the nearest street with a path
            houses.forEach(house => {
                const houseCenterX = house.x + Math.floor(house.width / 2);
                const houseCenterY = house.y + Math.floor(house.height / 2);
                
                // Find nearest street tile
                let nearestStreetX = houseCenterX;
                let nearestStreetY = houseCenterY;
                let minDistance = Infinity;
                
                for (let y = 0; y < dynamicMapHeight; y++) {
                    for (let x = 0; x < dynamicMapWidth; x++) {
                        if (gameMap[y][x] === TILE_FLOOR) {
                            // Check if this is a street (not inside any house)
                            let isStreet = true;
                            for (let otherHouse of houses) {
                                if (x >= otherHouse.x && x < otherHouse.x + otherHouse.width &&
                                    y >= otherHouse.y && y < otherHouse.y + otherHouse.height) {
                                    isStreet = false;
                                    break;
                                }
                            }
                            
                            if (isStreet) {
                                const distance = Math.abs(x - houseCenterX) + Math.abs(y - houseCenterY);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    nearestStreetX = x;
                                    nearestStreetY = y;
                                }
                            }
                        }
                    }
                }
                
                // Create path from house to street
                let currentX = houseCenterX;
                let currentY = houseCenterY;
                
                while (currentX !== nearestStreetX || currentY !== nearestStreetY) {
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                    
                    if (currentX !== nearestStreetX) {
                        currentX += currentX < nearestStreetX ? 1 : -1;
                    } else if (currentY !== nearestStreetY) {
                        currentY += currentY < nearestStreetY ? 1 : -1;
                    }
                }
            });
        }

        /**
         * Generates a volcano-themed map with spiral tubes and chambers
         */
        function generateVolcanoMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create spiral lava tubes emanating from central chambers
            const numSpiralCenters = Math.max(2, Math.floor(Math.min(dynamicMapWidth, dynamicMapHeight) / 20));
            const spiralCenters = [];
            
            for (let i = 0; i < numSpiralCenters; i++) {
                const centerX = Math.floor(dynamicMapWidth * (0.2 + Math.random() * 0.6));
                const centerY = Math.floor(dynamicMapHeight * (0.2 + Math.random() * 0.6));
                
                spiralCenters.push({ x: centerX, y: centerY });
                
                // Create central magma chamber
                const chamberSize = 3 + Math.floor(Math.random() * 3); // Size 3-5
                for (let dy = -chamberSize; dy <= chamberSize; dy++) {
                    for (let dx = -chamberSize; dx <= chamberSize; dx++) {
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance <= chamberSize * (0.8 + Math.random() * 0.4)) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                gameMap[y][x] = TILE_FLOOR;
                            }
                        }
                    }
                }
                
                // Create multiple spiral tubes from this center
                const numSpirals = 2 + Math.floor(Math.random() * 3); // 2-4 spirals per center
                
                for (let s = 0; s < numSpirals; s++) {
                    const startAngle = (s / numSpirals) * 2 * Math.PI + Math.random() * 0.5; // Offset each spiral
                    const spiralDirection = Math.random() < 0.5 ? 1 : -1; // Clockwise or counterclockwise
                    const spiralTightness = 0.05 + Math.random() * 0.05; // How tight the spiral is
                    const maxRadius = Math.min(dynamicMapWidth, dynamicMapHeight) / 3;
                    
                    let currentAngle = startAngle;
                    let currentRadius = 2;
                    
                    while (currentRadius < maxRadius) {
                        const x = Math.floor(centerX + Math.cos(currentAngle) * currentRadius);
                        const y = Math.floor(centerY + Math.sin(currentAngle) * currentRadius);
                        
                        if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                            gameMap[y][x] = TILE_FLOOR;
                            
                            // Make the tube slightly wider occasionally
                            if (Math.random() < 0.3) {
                                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                                for (let [dx, dy] of directions) {
                                    const wideX = x + dx;
                                    const wideY = y + dy;
                                    if (wideX >= 0 && wideX < dynamicMapWidth && 
                                        wideY >= 0 && wideY < dynamicMapHeight && 
                                        Math.random() < 0.5) {
                                        gameMap[wideY][wideX] = TILE_FLOOR;
                                    }
                                }
                            }
                            
                            // Occasionally create small side chambers
                            if (Math.random() < 0.08 && currentRadius > 5) {
                                const sideAngle = currentAngle + (Math.PI / 2) * (Math.random() < 0.5 ? 1 : -1);
                                const sideDistance = 2 + Math.floor(Math.random() * 3);
                                
                                for (let d = 1; d <= sideDistance; d++) {
                                    const sideX = Math.floor(x + Math.cos(sideAngle) * d);
                                    const sideY = Math.floor(y + Math.sin(sideAngle) * d);
                                    
                                    if (sideX >= 0 && sideX < dynamicMapWidth && 
                                        sideY >= 0 && sideY < dynamicMapHeight) {
                                        gameMap[sideY][sideX] = TILE_FLOOR;
                                        
                                        // Create small chamber at the end
                                        if (d === sideDistance) {
                                            const chamberRadius = 1 + Math.floor(Math.random() * 2);
                                            for (let cdy = -chamberRadius; cdy <= chamberRadius; cdy++) {
                                                for (let cdx = -chamberRadius; cdx <= chamberRadius; cdx++) {
                                                    if (Math.abs(cdx) + Math.abs(cdy) <= chamberRadius) {
                                                        const cx = sideX + cdx;
                                                        const cy = sideY + cdy;
                                                        if (cx >= 0 && cx < dynamicMapWidth && 
                                                            cy >= 0 && cy < dynamicMapHeight) {
                                                            gameMap[cy][cx] = TILE_FLOOR;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Advance the spiral
                        currentAngle += spiralDirection * spiralTightness;
                        currentRadius += 0.3; // Gradual radius increase
                    }
                }
            }
            
            // Connect spiral centers with direct lava tubes if they're not too far apart
            for (let i = 0; i < spiralCenters.length - 1; i++) {
                const center1 = spiralCenters[i];
                const center2 = spiralCenters[i + 1];
                
                const distance = Math.sqrt((center2.x - center1.x) ** 2 + (center2.y - center1.y) ** 2);
                
                if (distance < Math.min(dynamicMapWidth, dynamicMapHeight) * 0.6) {
                    // Create connecting lava tube
                    let currentX = center1.x;
                    let currentY = center1.y;
                    
                    while (currentX !== center2.x || currentY !== center2.y) {
                        // Create wider connecting tube
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const x = currentX + dx;
                                const y = currentY + dy;
                                if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                    gameMap[y][x] = TILE_FLOOR;
                                }
                            }
                        }
                        
                        // Move towards target with some randomness
                        if (Math.random() < 0.8) {
                            if (Math.abs(currentX - center2.x) > Math.abs(currentY - center2.y)) {
                                currentX += currentX < center2.x ? 1 : -1;
                            } else {
                                currentY += currentY < center2.y ? 1 : -1;
                            }
                        } else {
                            // Random movement for more organic tubes
                            const randomDir = Math.floor(Math.random() * 4);
                            switch(randomDir) {
                                case 0: if (currentY > 1) currentY--; break;
                                case 1: if (currentX < dynamicMapWidth - 2) currentX++; break;
                                case 2: if (currentY < dynamicMapHeight - 2) currentY++; break;
                                case 3: if (currentX > 1) currentX--; break;
                            }
                        }
                    }
                }
            }
        }

        /**
         * Generates a cyber-themed map with circuit board pattern
         */
        function generateCyberMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create a circuit board-like pattern with components and traces
            const componentSpacing = 8;
            const components = [];
            
            // Place circuit components (CPU, RAM, etc.) in a grid-like pattern
            for (let y = componentSpacing / 2; y < dynamicMapHeight - componentSpacing / 2; y += componentSpacing) {
                for (let x = componentSpacing / 2; x < dynamicMapWidth - componentSpacing / 2; x += componentSpacing) {
                    if (Math.random() < 0.7) { // Not every grid position gets a component
                        const componentType = Math.random();
                        let componentWidth, componentHeight;
                        
                        if (componentType < 0.3) {
                            // Large CPU-like component
                            componentWidth = 4 + Math.floor(Math.random() * 2); // 4-5 wide
                            componentHeight = 4 + Math.floor(Math.random() * 2); // 4-5 tall
                        } else if (componentType < 0.6) {
                            // Medium RAM-like component
                            componentWidth = 2 + Math.floor(Math.random() * 2); // 2-3 wide
                            componentHeight = 3 + Math.floor(Math.random() * 3); // 3-5 tall
                        } else {
                            // Small chip component
                            componentWidth = 2 + Math.floor(Math.random() * 2); // 2-3 wide
                            componentHeight = 2 + Math.floor(Math.random() * 2); // 2-3 tall
                        }
                        
                        // Center the component at the grid position
                        const compX = x - Math.floor(componentWidth / 2);
                        const compY = y - Math.floor(componentHeight / 2);
                        
                        if (compX >= 0 && compY >= 0 && 
                            compX + componentWidth < dynamicMapWidth && 
                            compY + componentHeight < dynamicMapHeight) {
                            
                            components.push({
                                x: compX,
                                y: compY,
                                width: componentWidth,
                                height: componentHeight,
                                centerX: x,
                                centerY: y,
                                type: componentType < 0.3 ? 'cpu' : (componentType < 0.6 ? 'ram' : 'chip')
                            });
                            
                            // Create the component area
                            for (let dy = 0; dy < componentHeight; dy++) {
                                for (let dx = 0; dx < componentWidth; dx++) {
                                    gameMap[compY + dy][compX + dx] = TILE_FLOOR;
                                }
                            }
                            
                            // Add internal structure for larger components
                            if (componentWidth >= 4 && componentHeight >= 4) {
                                // Add internal pathways like a CPU
                                const internalSpacing = 2;
                                for (let iy = compY + 1; iy < compY + componentHeight - 1; iy += internalSpacing) {
                                    for (let ix = compX + 1; ix < compX + componentWidth - 1; ix++) {
                                        if (Math.random() < 0.6) {
                                            gameMap[iy][ix] = TILE_WALL; // Internal walls
                                        }
                                    }
                                }
                                for (let ix = compX + 1; ix < compX + componentWidth - 1; ix += internalSpacing) {
                                    for (let iy = compY + 1; iy < compY + componentHeight - 1; iy++) {
                                        if (Math.random() < 0.6) {
                                            gameMap[iy][ix] = TILE_WALL; // Internal walls
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Create circuit traces (connections) between components
            const traces = [];
            
            // Horizontal traces
            for (let y = 0; y < dynamicMapHeight; y += componentSpacing / 2) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    // Check if this position isn't inside a component
                    let insideComponent = false;
                    for (let comp of components) {
                        if (x >= comp.x && x < comp.x + comp.width &&
                            y >= comp.y && y < comp.y + comp.height) {
                            insideComponent = true;
                            break;
                        }
                    }
                    
                    if (!insideComponent && Math.random() < 0.8) {
                        gameMap[y][x] = TILE_FLOOR;
                        traces.push({ x, y, type: 'horizontal' });
                    }
                }
            }
            
            // Vertical traces
            for (let x = 0; x < dynamicMapWidth; x += componentSpacing / 2) {
                for (let y = 0; y < dynamicMapHeight; y++) {
                    // Check if this position isn't inside a component
                    let insideComponent = false;
                    for (let comp of components) {
                        if (x >= comp.x && x < comp.x + comp.width &&
                            y >= comp.y && y < comp.y + comp.height) {
                            insideComponent = true;
                            break;
                        }
                    }
                    
                    if (!insideComponent && Math.random() < 0.8) {
                        gameMap[y][x] = TILE_FLOOR;
                        traces.push({ x, y, type: 'vertical' });
                    }
                }
            }
            
            // Create data pathways - wider traces connecting major components
            const majorComponents = components.filter(comp => comp.type === 'cpu' || comp.type === 'ram');
            
            for (let i = 0; i < majorComponents.length - 1; i++) {
                const comp1 = majorComponents[i];
                const comp2 = majorComponents[i + 1];
                
                // Create wider data bus between major components
                let currentX = comp1.centerX;
                let currentY = comp1.centerY;
                
                while (currentX !== comp2.centerX || currentY !== comp2.centerY) {
                    // Create 3-wide data bus
                    for (let offset = -1; offset <= 1; offset++) {
                        let busX = currentX;
                        let busY = currentY + offset;
                        
                        // If moving vertically, offset horizontally instead
                        if (Math.abs(currentY - comp2.centerY) > Math.abs(currentX - comp2.centerX)) {
                            busX = currentX + offset;
                            busY = currentY;
                        }
                        
                        if (busX >= 0 && busX < dynamicMapWidth && 
                            busY >= 0 && busY < dynamicMapHeight) {
                            
                            // Don't overwrite component interiors
                            let insideComponent = false;
                            for (let comp of components) {
                                if (busX >= comp.x && busX < comp.x + comp.width &&
                                    busY >= comp.y && busY < comp.y + comp.height) {
                                    insideComponent = true;
                                    break;
                                }
                            }
                            
                            if (!insideComponent) {
                                gameMap[busY][busX] = TILE_FLOOR;
                            }
                        }
                    }
                    
                    // Move toward target component
                    if (currentX !== comp2.centerX) {
                        currentX += currentX < comp2.centerX ? 1 : -1;
                    } else if (currentY !== comp2.centerY) {
                        currentY += currentY < comp2.centerY ? 1 : -1;
                    }
                }
            }
            
            // Add connection pads around components
            components.forEach(comp => {
                const padPositions = [
                    { x: comp.x - 1, y: comp.centerY }, // Left pad
                    { x: comp.x + comp.width, y: comp.centerY }, // Right pad
                    { x: comp.centerX, y: comp.y - 1 }, // Top pad
                    { x: comp.centerX, y: comp.y + comp.height } // Bottom pad
                ];
                
                padPositions.forEach(pad => {
                    if (pad.x >= 0 && pad.x < dynamicMapWidth && 
                        pad.y >= 0 && pad.y < dynamicMapHeight) {
                        gameMap[pad.y][pad.x] = TILE_FLOOR;
                    }
                });
            });
        }

        /**
         * Generates a marble-themed map with cathedral-like grand halls
         */
        /**
         * Initialize the map with all walls
         */
        function initializeMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
        }

        /**
         * Generates procedural paths using a random walk algorithm.
         * @param {number} steps - The number of steps for the random walk.
         */
        function generatePaths(steps) {
            let currentX = Math.floor(dynamicMapWidth / 2);
            let currentY = Math.floor(dynamicMapHeight / 2);

            currentX = Math.max(1, Math.min(dynamicMapWidth - 2, currentX));
            currentY = Math.max(1, Math.min(dynamicMapHeight - 2, currentY));

            gameMap[currentY][currentX] = TILE_FLOOR;

            for (let i = 0; i < steps; i++) {
                const direction = Math.floor(Math.random() * 4);

                let nextX = currentX;
                let nextY = currentY;

                switch (direction) {
                    case 0: // Up
                        nextY--;
                        break;
                    case 1: // Down
                        nextY++;
                        break;
                    case 2: // Left
                        nextX--;
                        break;
                    case 3: // Right
                        nextX++;
                        break;
                }

                if (nextX >= 1 && nextX < dynamicMapWidth - 1 && nextY >= 1 && nextY < dynamicMapHeight - 1) {
                    currentX = nextX;
                    currentY = nextY;
                    gameMap[currentY][currentX] = TILE_FLOOR;
                }
            }
        }

        function generateMarbleMap() {
            initializeMap();
            generatePaths(dynamicMapWidth * dynamicMapHeight * 0.5);
        }

        /**
         * Generates a void-themed map with scattered platforms and teleporter pads
         */
        function generateVoidMap() {
            initializeMap();
            generatePaths(dynamicMapWidth * dynamicMapHeight * 0.5);
        }

        /**
         * Generates the appropriate map based on current world
         */
        function generateWorldMap() {
            const world = getCurrentWorld();
            console.log('generateWorldMap() - Current world:', world ? world.name : 'undefined', 'Using original random walk generator for all worlds');
            
            // Use the original random walk algorithm for all worlds
            initializeMap();
            generatePaths(dynamicMapWidth * dynamicMapHeight * 0.5);
        }

        /**
         * Generates a random integer between min (inclusive) and max (inclusive).
         * @param {number} min - The minimum value.
         * @param {number} max - The maximum value.
         * @returns {number} A random integer.
         */
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * Generates a random integer between min (inclusive) and max (inclusive),
         * biased by the health ratio of attacker to defender and optionally by attacker's flow.
         * If attacker is stronger, bias towards lower damage.
         * If attacker's weaker, bias towards higher damage.
         * If attacker's flow is high, bias towards higher damage.
         * If attacker's flow is low, bias towards lower damage.
         * @param {number} min - The minimum damage value.
         * @param {number} max - The maximum damage value.
         * @param {number} attackerHealth - Current health of the attacker.
         * @param {number} defenderHealth - Current health of the defender.
         * @param {number} [currentAttackerFlow=null] - Optional: The current flow of the attacker.
         * @returns {number} A biased random integer damage value.
         */
        function getWeightedRandomInt(min, max, attackerHealth, defenderHealth, currentAttackerFlow = null) {
            if (attackerHealth <= 0 || defenderHealth <= 0) {
                return 0;
            }

            const healthRatio = attackerHealth / defenderHealth;
            let biasFactor = 1;

            // Fixed health-based bias - higher health = MORE damage (intuitive)
            if (healthRatio > 1) { // Attacker is stronger (relative to defender)
                biasFactor = 1 + (healthRatio - 1) * COMBAT_BIAS_STRENGTH; // Bonus damage when stronger
            } else if (healthRatio < 1) { // Attacker is weaker (relative to defender) 
                biasFactor = 1 - (1 - healthRatio) * COMBAT_BIAS_STRENGTH; // Reduced damage when weaker
            }

            // New flow-based bias (only applies if currentAttackerFlow is provided and valid)
            if (currentAttackerFlow !== null && !isNaN(currentAttackerFlow) && currentAttackerFlow > 0) {
                const flowMultiplier = Math.pow(BASE_FLOW_FOR_BIAS / currentAttackerFlow, FLOW_BIAS_STRENGTH);
                biasFactor *= flowMultiplier;
            }

            biasFactor = Math.max(0.1, Math.min(biasFactor, 5.0)); // Clamp final biasFactor

            const biasedRandom = Math.pow(Math.random(), biasFactor);
            let damage = Math.floor(min + biasedRandom * (max - min + 1));
            damage = Math.max(min, Math.min(damage, max));

            return damage;
        }

        /**
         * Calculates the Euclidean distance between two points.
         * @param {object} p1 - First point {x, y}.
         * @param {object} p2 - Second point {x, y}.
         * @returns {number} The distance between the two points.
         */
        function getDistance(p1, p2) {
            if (!p1 || !p2) {
                console.error("Attempted to calculate distance with null or undefined point:", p1, p2);
                return Infinity;
            }
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        /**
         * Optimized helper function to find an empty floor tile with caching
         * @param {Array<object>} excludeEntities - An array of entities to avoid placing the tile on.
         * @returns {object|null} An {x, y} object if a spot is found, otherwise null.
         */
        function findEmptyFloorTile(excludeEntities = []) {
            if (player.x === undefined || player.y === undefined || player.x === null || player.y === null) {
                console.error("Player position is undefined or null when trying to find empty floor tile. Cannot guarantee reachability.");
                let attempts = 0;
                const MAX_FALLBACK_ATTEMPTS = 200; // Reduced from 500
                while (attempts < MAX_FALLBACK_ATTEMPTS) {
                    const randX = getRandomInt(0, dynamicMapWidth - 1);
                    const randY = getRandomInt(0, dynamicMapHeight - 1);
                    if (gameMap[randY][randX] === TILE_FLOOR &&
                        !excludeEntities.some(e => e.x === randX && e.y === randY)) {
                        console.warn(`Placed item at (${randX}, ${randY}) without reachability check due to invalid player position.`);
                        return { x: randX, y: randY };
                    }
                    attempts++;
                }
                console.error("Failed to find any empty floor tile even as a last resort.");
                return null;
            }

            // Pre-compute exclude positions for faster lookup
            const excludeSet = new Set();
            for (let i = 0; i < excludeEntities.length; i++) {
                const e = excludeEntities[i];
                excludeSet.add(`${e.x},${e.y}`);
            }

            const potentialTiles = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            // Optimized double loop with early exit conditions
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (gameMap[y][x] === TILE_FLOOR && !excludeSet.has(`${x},${y}`)) {
                        // Quick wall neighbor check
                        let wallNeighbors = 0;
                        for (let i = 0; i < 4; i++) {
                            const dx = directions[i][0];
                            const dy = directions[i][1];
                            const checkX = x + dx;
                            const checkY = y + dy;

                            if (checkX >= 0 && checkX < dynamicMapWidth && checkY >= 0 && checkY < dynamicMapHeight) {
                                if (gameMap[checkY][checkX] === TILE_WALL) {
                                    wallNeighbors++;
                                }
                            } else {
                                wallNeighbors++;
                            }
                        }

                        if (wallNeighbors < 4) {
                            // Cache pathfinding results to avoid repeated calculations
                            const cacheKey = `${player.x},${player.y}-${x},${y}`;
                            let hasPath = pathfindingCache.get(cacheKey);
                            
                            if (hasPath === undefined) {
                                hasPath = findPathBasic(player.x, player.y, x, y, gameMap, dynamicMapWidth, dynamicMapHeight) !== null;
                                pathfindingCache.set(cacheKey, hasPath);
                            }
                            
                            if (hasPath) {
                                potentialTiles.push({ x, y });
                                // Early exit if we have enough options
                                if (potentialTiles.length > 10) {
                                    break;
                                }
                            }
                        }
                    }
                }
                if (potentialTiles.length > 10) break;
            }

            if (potentialTiles.length > 0) {
                const randomIndex = getRandomInt(0, potentialTiles.length - 1);
                return potentialTiles[randomIndex];
            } else {
                console.warn("No reachable empty floor tiles found for placement of item.");
                let attempts = 0;
                const MAX_LAST_RESORT_ATTEMPTS = 200; // Reduced from 500
                while (attempts < MAX_LAST_RESORT_ATTEMPTS) {
                    const randX = getRandomInt(0, dynamicMapWidth - 1);
                    const randY = getRandomInt(0, dynamicMapHeight - 1);
                    if (gameMap[randY][randX] === TILE_FLOOR && !excludeSet.has(`${randX},${randY}`)) {
                        console.warn(`Placed item at (${randX}, ${randY}) as a last resort (reachability not guaranteed).`);
                        return { x: randX, y: randY };
                    }
                    attempts++;
                }
                console.error("Failed to find any empty floor tile even as a last resort.");
                return null;
            }
        }

        /**
         * Finds the shortest path from start to end using Breadth-First Search (BFS).
         * Returns an array of {x, y} coordinates representing the path, or null if no path exists.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {number} endX - Target X coordinate.
         * @param {number} endY - Target Y coordinate.
         * @param {Array<Array<number>>} map - The game map.
         * @param {number} mapWidth - Width of the map.
         * @param {number} mapHeight - Height of the map.
         * @param {Array<object>} [entitiesToStrictlyAvoid=[]] - Optional: An array of entity positions ({x, y}) to treat as impassable.
         * @returns {Array<{x: number, y: number}>|null} The path as an array of coordinates, or null.
         */
        function findPathBasic(startX, startY, endX, endY, map, mapWidth, mapHeight, entitiesToStrictlyAvoid = []) {
            performanceStats.pathfindingCalls++;
            
            // Generate cache key including entities to avoid
            const avoidKey = entitiesToStrictlyAvoid.map(e => `${e.x},${e.y}`).sort().join('|');
            const cacheKey = `basic_${startX},${startY}_${endX},${endY}_${avoidKey}_${cacheValidationFrame}`;
            
            // Check cache first
            if (pathfindingCache.has(cacheKey)) {
                performanceStats.cacheHits++;
                return pathfindingCache.get(cacheKey);
            }
            
            performanceStats.cacheMisses++;
            logPerformanceStats(); // Check if we should log stats

            const queue = [{ x: startX, y: startY, path: [] }];
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            // Pre-compute entity avoid set for faster lookup
            const avoidSet = new Set();
            for (let i = 0; i < entitiesToStrictlyAvoid.length; i++) {
                const e = entitiesToStrictlyAvoid[i];
                avoidSet.add(`${e.x},${e.y}`);
            }

            while (queue.length > 0) {
                const { x, y, path } = queue.shift();

                if (x === endX && y === endY) {
                    const result = path.concat({ x, y });
                    pathfindingCache.set(cacheKey, result);
                    return result;
                }

                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    const posKey = `${newX},${newY}`;

                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS) &&
                        !visited.has(posKey) &&
                        !avoidSet.has(posKey)) {

                        visited.add(posKey);
                        queue.push({ x: newX, y: newY, path: path.concat({ x, y }) });
                    }
                }
            }
            
            pathfindingCache.set(cacheKey, null);
            return null;
        }

        // Priority queue implementation for pathfinding optimization
        class MinHeap {
            constructor() {
                this.heap = [];
            }
            
            push(element) {
                this.heap.push(element);
                this._heapifyUp(this.heap.length - 1);
            }
            
            pop() {
                if (this.heap.length === 0) return undefined;
                if (this.heap.length === 1) return this.heap.pop();
                
                const root = this.heap[0];
                this.heap[0] = this.heap.pop();
                this._heapifyDown(0);
                return root;
            }
            
            get length() {
                return this.heap.length;
            }
            
            _heapifyUp(index) {
                if (index === 0) return;
                const parentIndex = Math.floor((index - 1) / 2);
                if (this.heap[parentIndex].cost <= this.heap[index].cost) return;
                [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];
                this._heapifyUp(parentIndex);
            }
            
            _heapifyDown(index) {
                const leftChildIndex = 2 * index + 1;
                const rightChildIndex = 2 * index + 2;
                let smallestIndex = index;
                
                if (leftChildIndex < this.heap.length && this.heap[leftChildIndex].cost < this.heap[smallestIndex].cost) {
                    smallestIndex = leftChildIndex;
                }
                
                if (rightChildIndex < this.heap.length && this.heap[rightChildIndex].cost < this.heap[smallestIndex].cost) {
                    smallestIndex = rightChildIndex;
                }
                
                if (smallestIndex !== index) {
                    [this.heap[smallestIndex], this.heap[index]] = [this.heap[index], this.heap[smallestIndex]];
                    this._heapifyDown(smallestIndex);
                }
            }
        }

        /**
         * Finds the shortest path from start to end using a Dijkstra-like algorithm,
         * with a penalty for moving into tiles adjacent to enemies.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {number} endX - Target X coordinate.
         * @param {number} endY - Target Y coordinate.
         * @param {Array<Array<number>>} map - The game map.
         * @param {number} mapWidth - Width of the map.
         * @param {number} mapHeight - Height of the map.
         * @param {Array<object>} entitiesWithProximityPenalty - An array of entity positions ({x, y}) to apply proximity penalty for.
         * @returns {Array<{x: number, y: number}>|null} The path as an array of coordinates, or null.
         */
        function findPathWithProximityPenalty(startX, startY, endX, endY, map, mapWidth, mapHeight, entitiesWithProximityPenalty) {
            performanceStats.pathfindingCalls++;
            
            // Optimized cache key generation - avoid repeated sorting and joining
            let entitiesKey = '';
            if (entitiesWithProximityPenalty.length > 0) {
                const sortedEntities = entitiesWithProximityPenalty.slice().sort((a, b) => (a.x !== b.x) ? a.x - b.x : a.y - b.y);
                entitiesKey = sortedEntities.map(e => `${e.x},${e.y}`).join('|');
            }
            const cacheKey = `proximity_${startX},${startY}_${endX},${endY}_${entitiesKey}_${cacheValidationFrame}`;
            
            // Check cache first
            if (pathfindingCache.has(cacheKey)) {
                performanceStats.cacheHits++;
                return pathfindingCache.get(cacheKey);
            }
            
            performanceStats.cacheMisses++;

            // Use priority queue instead of sorting on every iteration
            const queue = new MinHeap();
            queue.push({ x: startX, y: startY, path: [], cost: 0 });
            
            const visitedCosts = new Map();
            visitedCosts.set(`${startX},${startY}`, 0);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Only cardinal directions for pathfinding
            const PROXIMITY_PENALTY = 5; // Cost penalty for moving into a tile adjacent to an entity

            // Pre-compute entity positions for faster lookup with more efficient data structure
            const entityGrid = new Map();
            for (let i = 0; i < entitiesWithProximityPenalty.length; i++) {
                const e = entitiesWithProximityPenalty[i];
                const key = `${e.x},${e.y}`;
                entityGrid.set(key, true);
                // Pre-compute proximity positions for faster lookup
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const proxKey = `${e.x + dx},${e.y + dy}`;
                        if (!entityGrid.has(proxKey)) {
                            entityGrid.set(proxKey, 'proximity');
                        }
                    }
                }
            }

            while (queue.length > 0) {
                const { x, y, path, cost } = queue.pop();

                if (cost > visitedCosts.get(`${x},${y}`)) {
                    continue;
                }

                if (x === endX && y === endY) {
                    const result = path.concat({ x, y });
                    pathfindingCache.set(cacheKey, result);
                    return result;
                }

                for (const [dx, dy] of directions) { // Iterate over cardinal directions for movement
                    const newX = x + dx;
                    const newY = y + dy;

                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS)) {

                        let stepCost = 1;

                        // Optimized proximity check using pre-computed grid
                        const positionKey = `${newX},${newY}`;
                        const proximityStatus = entityGrid.get(positionKey);
                        if (proximityStatus === 'proximity') {
                            stepCost += PROXIMITY_PENALTY;
                        }

                        const newCost = cost + stepCost;
                        const positionCostKey = `${newX},${newY}`;

                        if (!visitedCosts.has(positionCostKey) || newCost < visitedCosts.get(positionCostKey)) {
                            visitedCosts.set(positionCostKey, newCost);
                            queue.push({ x: newX, y: newY, path: path.concat({ x, y }), cost: newCost });
                        }
                    }
                }
            }
            
            pathfindingCache.set(cacheKey, null);
            return null;
        }

        /**
         * Ultra-safe pathfinding for survival mode - maximizes distance from all enemies
         * with severe penalties for getting close to any threat.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {number} endX - Target X coordinate.
         * @param {number} endY - Target Y coordinate.
         * @param {Array<Array<number>>} map - The game map.
         * @param {number} mapWidth - Width of the map.
         * @param {number} mapHeight - Height of the map.
         * @param {Array<object>} entitiesWithProximityPenalty - An array of entity positions ({x, y}) to apply proximity penalty for.
         * @returns {Array<{x: number, y: number}>|null} The path as an array of coordinates, or null.
         */
        function findPathUltraSafe(startX, startY, endX, endY, map, mapWidth, mapHeight, entitiesWithProximityPenalty) {
            const queue = [{ x: startX, y: startY, path: [], cost: 0 }];
            const visitedCosts = new Map();
            visitedCosts.set(`${startX},${startY}`, 0);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Only cardinal directions for pathfinding

            // Reduced penalties for better movement flow
            const IMMEDIATE_PENALTY = 15; // Reduced from 50 - still avoids enemies but allows movement
            const CLOSE_PENALTY = 8; // Reduced from 20 - moderate penalty for 2 tiles away
            const NEAR_PENALTY = 3; // Reduced from 8 - light penalty for 3 tiles away

            while (queue.length > 0) {
                queue.sort((a, b) => a.cost - b.cost);
                const { x, y, path, cost } = queue.shift();

                if (cost > visitedCosts.get(`${x},${y}`)) {
                    continue;
                }

                if (x === endX && y === endY) {
                    return path.concat({ x, y });
                }

                for (const [dx, dy] of directions) { // Iterate over cardinal directions for movement
                    const newX = x + dx;
                    const newY = y + dy;

                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS)) {

                        let stepCost = 1;

                        // Check multiple distance rings for threats
                        for (const entity of entitiesWithProximityPenalty) {
                            const distance = Math.abs(newX - entity.x) + Math.abs(newY - entity.y); // Manhattan distance
                            if (distance === 1) {
                                stepCost += IMMEDIATE_PENALTY; // Adjacent to enemy
                            } else if (distance === 2) {
                                stepCost += CLOSE_PENALTY; // 2 tiles from enemy
                            } else if (distance === 3) {
                                stepCost += NEAR_PENALTY; // 3 tiles from enemy
                            }
                        }

                        const newCost = cost + stepCost;

                        if (!visitedCosts.has(`${newX},${newY}`) || newCost < visitedCosts.get(`${newX},${newY}`)) {
                            visitedCosts.set(`${newX},${newY}`, newCost);
                            queue.push({ x: newX, y: newY, path: path.concat({ x, y }), cost: newCost });
                        }
                    }
                }
            }
            return null;
        }

        /**
         * Finds a random floor tile for the player's starting position, prioritizing the top-left corner.
         */
        function findPlayerStartInCorner() {
            const playerPos = findEmptyFloorTile([]);
            if (playerPos) {
                player.x = playerPos.x;
                player.y = playerPos.y; // Corrected: assign to player.y
                console.log(`Player positioned at: (${player.x}, ${player.y}), map: ${dynamicMapWidth}x${dynamicMapHeight}`);
            } else {
                console.error("Failed to find a valid player start position. Forcing placement.");
                player.x = 1;
                player.y = 1;
                console.log(`Player fallback positioned at: (${player.x}, ${player.y}), map: ${dynamicMapWidth}x${dynamicMapHeight}`);
                if (gameMap[1] && gameMap[1][1] === TILE_WALL) {
                    gameMap[1][1] = TILE_FLOOR; // This is the key part
                }
            }
        }

        /**
         * Checks if all floor tiles are reachable from a starting position, treating stairs as passable
         * @param {number} startX - Starting X coordinate
         * @param {number} startY - Starting Y coordinate
         * @param {Array<Array<number>>} map - The game map
         * @returns {boolean} True if all floor tiles are reachable
         */
        function checkConnectivity(startX, startY, map) {
            const visited = new Set();
            const queue = [{ x: startX, y: startY }];
            visited.add(`${startX},${startY}`);
            
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            let reachableFloorTiles = 0;
            let totalFloorTiles = 0;
            
            // Optimized floor tile counting with early exit potential
            const floorTilePositions = [];
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (map[y][x] === TILE_FLOOR || map[y][x] === TILE_STAIRS) {
                        totalFloorTiles++;
                        floorTilePositions.push({ x, y });
                    }
                }
            }
            
            // Quick exit for small maps
            if (totalFloorTiles <= 1) {
                return true;
            }
            
            // BFS to find all reachable tiles with optimizations
            while (queue.length > 0) {
                const { x, y } = queue.shift();
                
                if (map[y][x] === TILE_FLOOR || map[y][x] === TILE_STAIRS) {
                    reachableFloorTiles++;
                    // Early exit if we've reached all floor tiles
                    if (reachableFloorTiles === totalFloorTiles) {
                        return true;
                    }
                }
                
                // Optimized direction checking
                for (let i = 0; i < 4; i++) {
                    const dx = directions[i][0];
                    const dy = directions[i][1];
                    const newX = x + dx;
                    const newY = y + dy;
                    const posKey = `${newX},${newY}`;
                    
                    if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS) &&
                        !visited.has(posKey)) {
                        
                        visited.add(posKey);
                        queue.push({ x: newX, y: newY });
                    }
                }
            }
            
            return reachableFloorTiles === totalFloorTiles;
        }

        /**
         * Finds a random floor tile in the bottom-right corner for the staircase, prioritizing open areas.
         */
        function placeStairsOppositeCorner() {
            let found = false;
            let attempts = 0;
            const MAX_PLACEMENT_ATTEMPTS = 1000;
            const MIN_OPEN_NEIGHBORS_FOR_STAIRS = 2; // Minimum number of adjacent floor tiles for stairs

            const searchStartX = Math.floor(dynamicMapWidth * 3 / 4);
            const searchStartY = Math.floor(dynamicMapHeight * 3 / 4);

            let validStairsCandidates = [];
            const cardinalDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            // First, try to find candidates with enough open neighbors that don't break connectivity
            for (let y = searchStartY; y < dynamicMapHeight; y++) {
                for (let x = searchStartX; x < dynamicMapWidth; x++) {
                    if (y >= 0 && y < dynamicMapHeight && x >= 0 && x < dynamicMapWidth &&
                        gameMap[y][x] === TILE_FLOOR && (x !== player.x || y !== player.y)) {

                        let openNeighbors = 0;
                        for (const [dx, dy] of cardinalDirections) {
                            const checkX = x + dx;
                            const checkY = y + dy;
                            if (checkX >= 0 && checkX < dynamicMapWidth && checkY >= 0 && checkY < dynamicMapHeight &&
                                gameMap[checkY][checkX] === TILE_FLOOR) {
                                openNeighbors++;
                            }
                        }

                        if (openNeighbors >= MIN_OPEN_NEIGHBORS_FOR_STAIRS) {
                            // Test placing stairs here and check if connectivity is maintained
                            const originalTile = gameMap[y][x];
                            gameMap[y][x] = TILE_STAIRS;
                            
                            if (checkConnectivity(player.x, player.y, gameMap)) {
                                validStairsCandidates.push({ x, y, openNeighbors });
                            }
                            
                            // Restore original tile
                            gameMap[y][x] = originalTile;
                        }
                    }
                }
            }

            // Sort candidates by openNeighbors in descending order
            validStairsCandidates.sort((a, b) => b.openNeighbors - a.openNeighbors);

            if (validStairsCandidates.length > 0) {
                // Pick a random one from the top few, or just the very best one
                const bestCandidatesSlice = validStairsCandidates.slice(0, Math.min(5, validStairsCandidates.length));
                const chosen = bestCandidatesSlice[getRandomInt(0, bestCandidatesSlice.length - 1)];
                stairs.x = chosen.x;
                stairs.y = chosen.y;
                gameMap[stairs.y][stairs.x] = TILE_STAIRS;
                found = true;
            }

            // Fallback if no suitable candidates found with open neighbors - check connectivity for any valid position
            if (!found) {
                attempts = 0;
                while (!found && attempts < MAX_PLACEMENT_ATTEMPTS) {
                    const randX = searchStartX + Math.floor(Math.random() * (dynamicMapWidth - searchStartX));
                    const randY = searchStartY + Math.floor(Math.random() * (dynamicMapHeight - searchStartY));

                    if (randY >= 0 && randY < dynamicMapHeight && randX >= 0 && randX < dynamicMapWidth &&
                        gameMap[randY][randX] === TILE_FLOOR && (randX !== player.x || randY !== player.y)) {
                        
                        // Test connectivity before placing stairs
                        const originalTile = gameMap[randY][randX];
                        gameMap[randY][randX] = TILE_STAIRS;
                        
                        if (checkConnectivity(player.x, player.y, gameMap)) {
                            stairs.x = randX;
                            stairs.y = randY;
                            found = true;
                        } else {
                            // Restore original tile if connectivity fails
                            gameMap[randY][randX] = originalTile;
                        }
                    }
                    attempts++;
                }
            }

            // Final fallback if still not found (should be rare with MAX_PLACEMENT_ATTEMPTS)
            if (!found) {
                attempts = 0;
                while (!found && attempts < MAX_PLACEMENT_ATTEMPTS) {
                    const randX = Math.floor(Math.random() * dynamicMapWidth);
                    const randY = Math.floor(Math.random() * dynamicMapHeight);
                    if (gameMap[randY][randX] === TILE_FLOOR && (randX !== player.x || randY !== player.y)) {
                        
                        // Test connectivity before placing stairs
                        const originalTile = gameMap[randY][randX];
                        gameMap[randY][randX] = TILE_STAIRS;
                        
                        if (checkConnectivity(player.x, player.y, gameMap)) {
                            stairs.x = randX;
                            stairs.y = randY;
                            found = true;
                        } else {
                            // Restore original tile if connectivity fails
                            gameMap[randY][randX] = originalTile;
                        }
                    }
                    attempts++;
                }
            }

            if (!found) {
                console.error("Failed to find a valid stairs position after many attempts. Forcing placement.");
                stairs.x = dynamicMapWidth - 2;
                stairs.y = dynamicMapHeight - 2;
                if (gameMap[dynamicMapHeight - 2] && gameMap[dynamicMapHeight - 2][dynamicMapWidth - 2] === TILE_WALL) {
                    gameMap[dynamicMapHeight - 2][dynamicMapWidth - 2] = TILE_FLOOR;
                }
                gameMap[stairs.y][stairs.x] = TILE_STAIRS;
            }
        }

        /**
         * Spawns enemies on the map, distributing total health points equal to the current level.
         * @param {number} levelHealthBonus - Additional health points for enemies based on player's health.
         * @param {number} playerAverageFlow - The player's average flow so far in the run.
         */
        function spawnEnemies(levelHealthBonus = 0, playerAverageFlow = 0) {
            enemies = [];
            const totalHealthForLevel = currentLevel + levelHealthBonus;

            let actualNumEnemies;
            if (currentLevel === 1) {
                actualNumEnemies = 1; // For level 1, always spawn exactly one enemy
            } else {
                const maxPossibleEnemies = Math.max(1, Math.min(totalHealthForLevel, 7));
                actualNumEnemies = getRandomInt(1, maxPossibleEnemies);
            }

            // Removed: Reintroduced minimum enemies based on level number divided by two
            // actualNumEnemies = Math.max(Math.floor(currentLevel / 2), actualNumEnemies);


            let remainingHealthToDistribute = totalHealthForLevel;

            for (let i = 0; i < actualNumEnemies; i++) {
                const excludeList = [player, stairs, ...enemies]; // Ensure stairs is in the exclude list for spawning
                const enemyPos = findEmptyFloorTile(excludeList);

                if (enemyPos) {
                    let role;
                    const roleRoll = Math.random();
                    if (roleRoll < 0.4) {
                        role = 'hunter';
                    } else if (roleRoll < 0.7) {
                        role = 'guard';
                    } else {
                        role = 'tracker';
                    }

                    // Temporary health for initial flow calculation (will be updated after distribution)
                    const tempEnemyHealth = 1;

                    // Calculate initial enemy flow based on player's average flow and inverse health bias
                    let initialEnemyFlowForThisEnemy = 0;
                    if (playerAverageFlow > 0) {
                        const healthNormalized = tempEnemyHealth / ENEMY_VISUAL_HEALTH_THRESHOLD;
                        // Bias the random factor: lower healthNormalized (lower health) means randomFactor biases towards 0
                        // Higher healthNormalized (higher health) means randomFactor biases towards 1
                        let effectiveRandomFactor = Math.random() * healthNormalized;
                        initialEnemyFlowForThisEnemy = playerAverageFlow * effectiveRandomFactor;
                    }

                    const baseStepsForFlow = 5; // Use a base number of steps to avoid very high flow from 1 damage / 1 step
                    const initialEnemyDamageDealt = initialEnemyFlowForThisEnemy * baseStepsForFlow;
                    const initialEnemyStepsTaken = initialEnemyFlowForThisEnemy > 0 ? baseStepsForFlow : 0;

                    const enemyId = 'enemy_' + (enemies.length + 1) + '_' + Math.random().toString(36).substr(2, 9);
                    const newEnemy = {
                        x: enemyPos.x, y: enemyPos.y, role: role, health: tempEnemyHealth,
                        id: enemyId,
                        name: generateAgentName(), // Add generated name
                        thrustAnimActive: false, thrustAnimStartTime: 0, thrustAnimDuration: 150,
                        thrustAnimDirectionX: 0, thrustAnimDirectionY: 0, thrustAnimMagnitude: 0,
                        totalDamageDealtByThisEnemy: initialEnemyDamageDealt,
                        stepsTakenByThisEnemy: initialEnemyStepsTaken,
                        flowLevel: initialEnemyFlowForThisEnemy,
                        initialHealth: tempEnemyHealth,
                        totalDamageTakenByThisEnemy: 0
                    };
                    newEnemy.hair = generateHairStyle(enemyId);
                    newEnemy.head = generateHeadStyle(enemyId);
                    newEnemy.eyes = generateEyeStyle(enemyId);
                    enemies.push(newEnemy);
                    remainingHealthToDistribute--;
                } else {
                    console.warn(`Could not place enemy ${i + 1}. Skipping this enemy.`);
                }
            }

            // Distribute remaining health points among spawned enemies
            while (remainingHealthToDistribute > 0 && enemies.length > 0) {
                const randomIndex = getRandomInt(0, enemies.length - 1);
                enemies[randomIndex].health = enemies[randomIndex].health + 1; // Explicit assignment
                // Update initialHealth here as well, because we're still in the "initialization" phase for this enemy
                enemies[randomIndex].initialHealth = enemies[randomIndex].health;
                remainingHealthToDistribute--;
            }

            // After health distribution, re-calculate flow based on final enemy health
            enemies.forEach(enemy => {
                let finalEnemyFlowForThisEnemy = 0;
                if (playerAverageFlow > 0) {
                    const healthNormalized = enemy.health / ENEMY_VISUAL_HEALTH_THRESHOLD;
                    // Bias the random factor: lower healthNormalized (lower health) means randomFactor biases towards 0
                    // Higher healthNormalized (higher health) means randomFactor biases towards 1
                    let effectiveRandomFactor = Math.random() * healthNormalized;
                    finalEnemyFlowForThisEnemy = playerAverageFlow * effectiveRandomFactor;
                }
                const baseStepsForFlow = 5;
                enemy.totalDamageDealtByThisEnemy = finalEnemyFlowForThisEnemy * baseStepsForFlow;
                enemy.stepsTakenByThisEnemy = finalEnemyFlowForThisEnemy > 0 ? baseStepsForFlow : 0;
                enemy.flowLevel = finalEnemyFlowForThisEnemy; // Update flowLevel with final calculated value
            });


            // Fallback to ensure at least one enemy if somehow none were placed and totalHealthForLevel > 0
            if (totalHealthForLevel > 0 && enemies.length === 0) {
                const enemyPos = findEmptyFloorTile([player, stairs]); // Ensure stairs is excluded even in fallback
                if (enemyPos) {
                    const baseStepsForFlow = 5;
                    const initialEnemyDamageDealt = playerAverageFlow * baseStepsForFlow; // Use player flow as fallback
                    const initialEnemyStepsTaken = playerAverageFlow > 0 ? baseStepsForFlow : 0;
                    const fallbackEnemyId = 'enemy_fallback_' + Math.random().toString(36).substr(2, 9);
                    const fallbackEnemy = {
                        x: enemyPos.x, y: enemyPos.y, role: 'hunter', health: totalHealthForLevel,
                        id: fallbackEnemyId,
                        name: generateAgentName(),
                        thrustAnimActive: false, thrustAnimStartTime: 0, thrustAnimDirectionX: 0, thrustAnimDirectionY: 0, thrustAnimMagnitude: 0,
                        totalDamageDealtByThisEnemy: initialEnemyDamageDealt, stepsTakenByThisEnemy: initialEnemyStepsTaken,
                        flowLevel: playerAverageFlow, // Fallback flow level
                        initialHealth: totalHealthForLevel, // Fallback initial health
                        totalDamageTakenByThisEnemy: 0 // Initialize for new enemy flow logic
                    };
                    fallbackEnemy.hair = generateHairStyle(fallbackEnemyId);
                    fallbackEnemy.head = generateHeadStyle(fallbackEnemyId);
                    fallbackEnemy.eyes = generateEyeStyle(fallbackEnemyId);
                    enemies.push(fallbackEnemy);
                } else {
                    console.error("Critical: Could not place any enemies even for fallback!");
                }
            }
        }

        /**
         * Spawns scattered health pickups on the map.
         */
        function spawnPickups() {
            // Filter out previous level's static pickups, keep only enemy drops (if any are left uncollected)
            staticDamageNumbers = cachedEnemyDrops.slice(); // Use cached enemy drops
            staticCollectionsDirty = true; // Mark cache as needing update

            let pointsToDistribute = currentLevel;
            let numPickupsToSpawn = 0;

            if (currentLevel === 1) {
                numPickupsToSpawn = 1; // For level 1, always spawn exactly one pickup
            } else {
                // For other levels, distribute points among multiple pickups as before
                // This logic can be refined if you want a specific number of pickups per level
                // For now, it will try to create pickups with values up to currentLevel,
                // resulting in a variable number of pickups.
                numPickupsToSpawn = currentLevel; // A rough estimate, actual number depends on random values
            }

            for (let i = 0; i < numPickupsToSpawn && pointsToDistribute > 0; i++) {
                const excludeList = [player, stairs, ...enemies, ...staticDamageNumbers.map(s => ({x: s.x, y: s.y}))];
                const pickupPos = findEmptyFloorTile(excludeList);

                if (pickupPos) {
                    let pickupValue;
                    if (currentLevel === 1) {
                        pickupValue = pointsToDistribute; // For level 1, the single pickup gets all points
                    } else {
                        // Determine the maximum value for the current pickup.
                        // It should be at least 1, not more than the remaining points.
                        const maxPickupValue = pointsToDistribute;
                        pickupValue = getRandomInt(1, maxPickupValue);
                    }
                    
                    staticDamageNumbers.push({
                        x: pickupPos.x,
                        y: pickupPos.y,
                        parts: [{ content: { type: 'number', value: pickupValue }, offsetX: 0, offsetY: 0 }],
                        isEnemyDrop: false // Mark as a static pickup
                    });
                    staticCollectionsDirty = true; // Mark cache as needing update
                    pointsToDistribute = pointsToDistribute - pickupValue; // Explicit assignment
                } else {
                    console.warn(`Could not place a pickup with ${pointsToDistribute} points. Remaining: ${pointsToDistribute}.`);
                    break; // Stop if no more spots can be found
                }
            }
        }

        /**
         * Draws an off-screen indicator for an entity.
         * @param {object} entity - The entity ({x, y}) to draw an indicator for.
         * @param {string} color - The color of the indicator.
         * @param {number} offsetX - The camera's X offset.
         * @param {number} offsetY - The camera's Y offset.
         * @param {number} opacity - The opacity of the indicator.
         */
        function drawOffScreenIndicator(entity, color, offsetX, offsetY, opacity) {
            const minIndicatorSize = dynamicTileSize * 0.3;
            const maxIndicatorSize = dynamicTileSize;

            const entityPixelX = entity.x * dynamicTileSize + offsetX;
            const entityPixelY = entity.y * dynamicTileSize + offsetY;

            const distFromLeft = Math.max(0, -entityPixelX);
            const distFromRight = Math.max(0, entityPixelX + gameCanvas.width - gameCanvas.width); // Use gameCanvas.width
            const distFromTop = Math.max(0, -entityPixelY);
            const distFromBottom = Math.max(0, entityPixelY + gameCanvas.height - gameCanvas.height); // Use gameCanvas.height

            const distanceOffScreen = Math.max(distFromLeft, distFromRight, distFromTop, distFromBottom);

            const maxScalingDistance = Math.max(gameCanvas.width, gameCanvas.height) / 3; // Use gameCanvas.width/height

            const normalizedDistance = Math.min(distanceOffScreen / maxScalingDistance, 1);

            const currentIndicatorSize = maxIndicatorSize - (normalizedDistance * (maxScalingDistance - minIndicatorSize));

            let indicatorX, indicatorY;

            if (entityPixelX < 0) {
                indicatorX = 0;
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width) { // Use gameCanvas.width
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
            } else {
                indicatorX = entityPixelX + (dynamicTileSize / 2) - (currentIndicatorSize / 2);
            }

            if (entityPixelY < 0) {
                indicatorY = 0;
            } else if (entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else {
                indicatorY = entityPixelY + (dynamicTileSize / 2) - (currentIndicatorSize / 2);
            }

            if (entityPixelX < 0 && entityPixelY < 0) {
                indicatorX = 0;
                indicatorY = 0;
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width && entityPixelY < 0) { // Use gameCanvas.width
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
                indicatorY = 0;
            } else if (entityPixelX < 0 && entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorX = 0;
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width && entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.width/height
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else if (entityPixelX < 0 || entityPixelX + dynamicTileSize > gameCanvas.width) { // Use gameCanvas.width
                indicatorY = Math.max(0, Math.min(gameCanvas.height - currentIndicatorSize, indicatorY)); // Use gameCanvas.height
            } else if (entityPixelY < 0 || entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorX = Math.max(0, Math.min(gameCanvas.width - currentIndicatorSize, indicatorX)); // Use gameCanvas.width
            }

            ctx.save();
            ctx.globalAlpha = opacity; // Apply opacity to the indicator
            setCanvasStyle('fillStyle', color);
            ctx.fillRect(Math.floor(indicatorX), Math.floor(indicatorY), Math.floor(currentIndicatorSize), Math.floor(currentIndicatorSize));
            ctx.restore();
        }

        // Add a roundRect method to CanvasRenderingContext2D for drawing rounded rectangles
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
            if (width < 2 * radius) radius = width / 2;
            if (height < 2 * radius) radius = height / 2;
            this.beginPath();
            this.moveTo(x + radius, y);
            this.arcTo(x + width, y, x + width, y + height, radius);
            this.arcTo(x + width, y + height, x, y + height, radius);
            this.arcTo(x, y + height, x, y, radius);
            this.arcTo(x, y, x + width, y, radius);
            this.closePath();
            return this;
        };

        // Rendering optimization variables
        let lastFrameTime = 0;
        let deltaTime = 0;
        let frameCount = 0;
        let fpsDisplay = 0;
        const TARGET_FPS = 60;
        const FRAME_TIME_THRESHOLD = 1000 / TARGET_FPS;
        
        // Cached calculations to avoid repetitive math
        let cachedTileCalculations = {
            currentRenderTileSize: 0,
            currentRenderOffsetX: 0,
            currentRenderOffsetY: 0,
            startTileX: 0,
            endTileX: 0,
            startTileY: 0,
            endTileY: 0,
            lastCanvasWidth: 0,
            lastCanvasHeight: 0,
            lastPlayerX: 0,
            lastPlayerY: 0,
            lastLevel: 0
        };

        // Cached collections for frequently filtered staticDamageNumbers
        let cachedPickups = []; // !isPlayerRemains
        let cachedPlayerRemains = []; // isPlayerRemains  
        let cachedEnemyDrops = []; // isEnemyDrop
        let staticCollectionsDirty = true;

        /**
         * Updates cached collections when staticDamageNumbers changes
         */
        function updateStaticCollectionsCache() {
            if (!staticCollectionsDirty) return;
            
            cachedPickups = staticDamageNumbers.filter(s => !s.isPlayerRemains);
            cachedPlayerRemains = staticDamageNumbers.filter(s => s.isPlayerRemains);
            cachedEnemyDrops = staticDamageNumbers.filter(s => s.isEnemyDrop);
            staticCollectionsDirty = false;
        }

        // Canvas state caching to avoid redundant style changes
        let lastFillStyle = null;
        let lastStrokeStyle = null;
        let lastFont = null;

        /**
         * Optimized canvas style setter with caching
         */
        function setCanvasStyle(property, value) {
            if (property === 'fillStyle' && lastFillStyle !== value) {
                ctx.fillStyle = value;
                lastFillStyle = value;
            } else if (property === 'strokeStyle' && lastStrokeStyle !== value) {
                ctx.strokeStyle = value;
                lastStrokeStyle = value;
            } else if (property === 'font' && lastFont !== value) {
                ctx.font = value;
                lastFont = value;
            }
        }

        /**
         * Optimized drawing with dirty rectangle tracking and frame rate limiting
         */
        function drawGame() {
            const now = performance.now();
            deltaTime = now - lastFrameTime;
            
            // Frame rate limiting - skip frame if we're running too fast
            if (deltaTime < FRAME_TIME_THRESHOLD) {
                requestAnimationFrame(drawGame);
                return;
            }
            
            frameCount++;
            if (frameCount % 60 === 0) {
                fpsDisplay = Math.round(1000 / deltaTime);
            }
            
            try {
                // Early validation (cached for performance)
                if (!ctx || !gameCanvas) {
                    console.error('Canvas or context not initialized');
                    return;
                }

                // Check if we need to recalculate tile positions
                const needsRecalculation = (
                    cachedTileCalculations.lastCanvasWidth !== gameCanvas.width ||
                    cachedTileCalculations.lastCanvasHeight !== gameCanvas.height ||
                    cachedTileCalculations.lastPlayerX !== player.x ||
                    cachedTileCalculations.lastPlayerY !== player.y ||
                    cachedTileCalculations.lastLevel !== currentLevel
                );

                if (needsRecalculation) {
                    // Cache frequently accessed values
                    cachedTileCalculations.lastCanvasWidth = gameCanvas.width;
                    cachedTileCalculations.lastCanvasHeight = gameCanvas.height;
                    cachedTileCalculations.lastPlayerX = player.x;
                    cachedTileCalculations.lastPlayerY = player.y;
                    cachedTileCalculations.lastLevel = currentLevel;

                    // Recalculate tile rendering parameters
                    const targetDynamicTileSizeForLevel = (() => {
                        const initialMaxTileSize = Math.floor(Math.min(gameCanvas.width / MAX_VISIBLE_TILES_LEVEL1, gameCanvas.height / MAX_VISIBLE_TILES_LEVEL1));
                        const finalMinTileSize = Math.floor(Math.min(gameCanvas.width / MIN_VISIBLE_TILES_MAX_LEVEL, gameCanvas.height / MIN_VISIBLE_TILES_MAX_LEVEL));
                        let calculated = initialMaxTileSize - ((Math.min(currentLevel, ZOOM_LEVELS_EFFECTIVE) - 1) * (initialMaxTileSize - finalMinTileSize) / (ZOOM_LEVELS_EFFECTIVE - 1));
                        return Math.max(finalMinTileSize, Math.floor(calculated));
                    })();


                    // Cache animation and zoom calculations
                    if (deathAnimationActive) {
                        const elapsed = now - deathAnimationStartTime;
                        const zoomProgress = Math.min(1, elapsed / DEATH_ZOOM_DURATION);
                        cachedTileCalculations.currentRenderTileSize = Math.max(1, Math.floor(targetDynamicTileSizeForLevel + (targetDynamicTileSizeForLevel * DEATH_ZOOM_TARGET_TILE_SCALE - targetDynamicTileSizeForLevel) * zoomProgress));
                        const targetPlayerCenterScreenX = gameCanvas.width / 2;
                        const targetPlayerCenterScreenY = gameCanvas.height / 2;
                        cachedTileCalculations.currentRenderOffsetX = Math.floor(targetPlayerCenterScreenX - (player.x * cachedTileCalculations.currentRenderTileSize + cachedTileCalculations.currentRenderTileSize / 2));
                        cachedTileCalculations.currentRenderOffsetY = Math.floor(targetPlayerCenterScreenY - (player.y * cachedTileCalculations.currentRenderTileSize + cachedTileCalculations.currentRenderTileSize / 2));
                    } else if (gameStartZoomActive) {
                        const elapsed = now - gameStartZoomStartTime;
                        const rawProgress = Math.min(1, elapsed / GAME_START_ZOOM_OUT_DURATION);
                        const zoomProgress = rawProgress; // Linear progression instead of cubic
                        cachedTileCalculations.currentRenderTileSize = Math.max(1, Math.floor(dynamicTileSize - ((dynamicTileSize - targetDynamicTileSizeForLevel) * zoomProgress)));
                        cachedTileCalculations.currentRenderOffsetX = Math.floor((gameCanvas.width / 2 - cachedTileCalculations.currentRenderTileSize / 2) - (player.x * cachedTileCalculations.currentRenderTileSize));
                        cachedTileCalculations.currentRenderOffsetY = Math.floor((gameCanvas.height / 2 - cachedTileCalculations.currentRenderTileSize / 2) - (player.y * cachedTileCalculations.currentRenderTileSize));
                        if (zoomProgress >= 1) {
                            gameStartZoomActive = false;
                            dynamicTileSize = targetDynamicTileSizeForLevel;
                        }
                    } else {
                        cachedTileCalculations.currentRenderTileSize = Math.floor(dynamicTileSize);
                        cachedTileCalculations.currentRenderOffsetX = Math.floor((gameCanvas.width / 2 - dynamicTileSize / 2) - (player.x * dynamicTileSize));
                        cachedTileCalculations.currentRenderOffsetY = Math.floor((gameCanvas.height / 2 - dynamicTileSize / 2) - (player.y * dynamicTileSize));
                    }

                    // Calculate visible tile range once - extend by 2 to include map edges
                    cachedTileCalculations.startTileX = Math.floor(-cachedTileCalculations.currentRenderOffsetX / cachedTileCalculations.currentRenderTileSize) - 2;
                    cachedTileCalculations.endTileX = Math.ceil((gameCanvas.width - cachedTileCalculations.currentRenderOffsetX) / cachedTileCalculations.currentRenderTileSize) + 2;
                    cachedTileCalculations.startTileY = Math.floor(-cachedTileCalculations.currentRenderOffsetY / cachedTileCalculations.currentRenderTileSize) - 2;
                    cachedTileCalculations.endTileY = Math.ceil((gameCanvas.height - cachedTileCalculations.currentRenderOffsetY) / cachedTileCalculations.currentRenderTileSize) + 2;
                }

                // Clear canvas with black background - DIRECT CALL
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                
                // Reset cache to match what we just set
                lastFillStyle = '#000000';

                // Validate critical game state (moved after cache update for efficiency)
                if (!gameMap || !gameMap.length || !gameMap[0] || !gameMap[0].length ||
                    !player || isNaN(player.x) || isNaN(player.y) || player.x === null || player.y === null ||
                    typeof currentLevel === 'undefined' || currentLevel === null) {
                    lastFrameTime = now;
                    requestAnimationFrame(drawGame);
                    return;
                }

                // Use cached values for rendering
                const { currentRenderTileSize, currentRenderOffsetX, currentRenderOffsetY, 
                       startTileX, endTileX, startTileY, endTileY } = cachedTileCalculations;

                for (let y = startTileY; y < endTileY; y++) {
                    for (let x = startTileX; x < endTileX; x++) {
                        const tileDrawX = Math.floor(x * currentRenderTileSize + currentRenderOffsetX);
                        const tileDrawY = Math.floor(y * currentRenderTileSize + currentRenderOffsetY);
                        const tileSize = Math.floor(currentRenderTileSize);

                        // Check if this tile is within the actual map bounds or adjacent (for edge visualization)
                        const isWithinMap = (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight);
                        const isMapEdge = !isWithinMap && 
                                         (x >= -1 && x <= dynamicMapWidth && y >= -1 && y <= dynamicMapHeight);
                        
                        // Debug: Log edge detection for positions near player (disabled)
                        // if (isMapEdge && Math.abs(x - player.x) <= 2 && Math.abs(y - player.y) <= 2) {
                        //     console.log(`Edge detected at ${x},${y}, player at ${player.x},${player.y}`);
                        // }
                        
                        if (isWithinMap) {
                            const tileType = gameMap[y][x];
                            
                            // Check if tile is visible or if it's a wall that's lit (walls show when lit even if not fully "visible")
                            const isVisible = visibilityMap && y < visibilityMap.length && 
                                            x < visibilityMap[0].length && visibilityMap[y][x];
                            
                            const lightIntensity = lightingMap && y < lightingMap.length && 
                                                  x < lightingMap[0].length ? lightingMap[y][x] : 0;
                            
                            const isWallInLight = tileType === TILE_WALL && lightIntensity > 0.15;
                            
                            if (isVisible || isWallInLight) {
                                // Get lighting intensity for this tile
                                const finalLightIntensity = Math.max(0.1, lightIntensity);
                                
                                switch (tileType) {
                                    case TILE_WALL:
                                        // Apply wall-specific lighting (walls get brighter with light)
                                        const wallColor = applyLighting(COLOR_WALL, finalLightIntensity, true);
                                        setCanvasStyle('fillStyle', wallColor);
                                        ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                        break;
                                    case TILE_FLOOR:
                                        // Only render floors if actually visible (not just lit)
                                        if (isVisible) {
                                            const floorColor = applyLighting(COLOR_FLOOR, finalLightIntensity, false);
                                            setCanvasStyle('fillStyle', floorColor);
                                            ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                        }
                                        break;
                                    case TILE_STAIRS:
                                        // Only render stairs if actually visible (not just lit)
                                        if (isVisible) {
                                            const stairsColor = applyLighting(FIXED_COLOR_STAIRS, finalLightIntensity, false);
                                            setCanvasStyle('fillStyle', stairsColor);
                                            ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                        }
                                        break;
                                }
                            }
                        } else if (isMapEdge) {
                            // Check if this edge position is lit by player's light
                            const distance = Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2);
                            if (distance <= LIGHT_RANGE && hasLineOfSight(player.x, player.y, x, y)) {
                                // Calculate light intensity for edge visualization
                                const lightIntensity = Math.max(0.2, 1.0 - (distance / LIGHT_RANGE) * 0.8);
                                
                                // Render map edge as a subtle boundary - distinct from walls and floors
                                const baseColor = '#303030'; // Darker than walls but lighter than void
                                const edgeColor = applyLighting(baseColor, lightIntensity, true);
                                setCanvasStyle('fillStyle', edgeColor);
                                
                                // Draw the edge as a filled rectangle
                                ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                
                                // Add a subtle dotted border pattern to make edges more distinctive
                                ctx.strokeStyle = applyLighting('#505050', lightIntensity, true);
                                ctx.lineWidth = 2;
                                ctx.setLineDash([4, 4]); // Dotted line pattern
                                ctx.strokeRect(tileDrawX + 2, tileDrawY + 2, tileSize - 4, tileSize - 4);
                                ctx.setLineDash([]); // Reset to solid lines
                            }
                        }
                        // Outside map bounds = void space (already black from canvas clear)
                    }
                }



                const stairsCanvasX = stairs.x * currentRenderTileSize + currentRenderOffsetX;
                const stairsCanvasY = stairs.y * currentRenderTileSize + currentRenderOffsetY;
                const areStairsOnScreen = stairsCanvasX >= -currentRenderTileSize && stairsCanvasX < gameCanvas.width &&
                                           stairsCanvasY >= -currentRenderTileSize && stairsCanvasY < gameCanvas.height;

                // Calculate opacity and font weight for stairs based on currentLevel
                const stairsOpacity = getOpacity(currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold
                const stairsFontWeight = getFontWeight(currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold

                if (areStairsOnScreen) {
                    ctx.save();
                    ctx.globalAlpha = stairsOpacity; // Apply opacity to stairs
                    ctx.fillStyle = FIXED_COLOR_STAIRS; // Use static stairs color
                    ctx.fillRect(Math.floor(stairsCanvasX), Math.floor(stairsCanvasY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                    ctx.restore();

                    // Draw the next level number on the stairs
                    ctx.save();
                    ctx.globalAlpha = stairsOpacity; // Apply opacity to stairs number
                    ctx.fillStyle = '#FFFFFF'; // White color for the level number
                    ctx.font = `${stairsFontWeight} ${Math.floor(currentRenderTileSize * 0.6)}px VT323`; // Apply font weight
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(currentLevel + 1, Math.floor(stairsCanvasX + currentRenderTileSize / 2), Math.floor(stairsCanvasY + currentRenderTileSize / 2));
                    ctx.restore();
                } else {
                    drawOffScreenIndicator(stairs, FIXED_COLOR_STAIRS, currentRenderOffsetX, currentRenderOffsetY, stairsOpacity); // Indicator uses static stairs color
                }

                enemies.forEach(enemy => {
                    const enemyCanvasX = enemy.x * currentRenderTileSize + currentRenderOffsetX;
                    const enemyCanvasY = enemy.y * currentRenderTileSize + currentRenderOffsetY;

                    const isEnemyOnScreen = enemyCanvasX >= -currentRenderTileSize && enemyCanvasX < gameCanvas.width &&
                                            enemyCanvasY >= -currentRenderTileSize && enemyCanvasY < gameCanvas.height;

                    let currentEnemyThrustOffsetX = 0;
                    let currentEnemyThrustOffsetY = 0;
                    let enemyHealthOpacity = 1;

                    if (enemy.thrustAnimActive) {
                        const elapsed = (now - enemy.thrustAnimStartTime) * timeScale; // Apply timeScale
                        if (elapsed < enemy.thrustAnimDuration) {
                            const progress = elapsed / enemy.thrustAnimDuration;
                            const thrustFactor = Math.sin(progress * Math.PI); // Smooth forward and back
                            const displacementMagnitude = currentRenderTileSize * 0.4 * enemy.thrustAnimMagnitude; // Max thrust is 40% of tile size, scaled by damage
                            currentEnemyThrustOffsetX = enemy.thrustAnimDirectionX * thrustFactor * displacementMagnitude;
                            currentEnemyThrustOffsetY = enemy.thrustAnimDirectionY * thrustFactor * displacementMagnitude;
                            enemyHealthOpacity = 1 - (progress * 0.5); // Fade out slightly
                        } else {
                            enemy.thrustAnimActive = false; // Animation finished
                        }
                    }

                    // Calculate health ratio for enemy color and font
                    let currentEnemyColor = getHealthColor(FIXED_COLOR_ENEMY, enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Base color based on health

                    // Calculate enemy flow for blinking effect
                    // MODIFIED: Enemy flow now uses flowLevel if no damage taken, otherwise damage taken flow.
                    const enemyVisualFlow = enemy.totalDamageTakenByThisEnemy > 0
                        ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1) // Ensure no division by zero
                        : enemy.flowLevel; // Use initial flowLevel if no damage taken yet

                    const enemyFlowIntensity = Math.min(1, enemyVisualFlow); // Cap intensity at 1 flow

                    let enemyFlowScale = 1;
                    if (enemyFlowIntensity > 0) {
                        // Invert flow intensity for blink speed: higher flow -> smaller blink speed (faster)
                        const minBlinkSpeed = 50; // Fastest blink speed (for flowIntensity = 1)
                        const maxBlinkSpeed = 200; // Slowest blink speed (for flowIntensity = 0, effectively)
                        const currentBlinkSpeed = maxBlinkSpeed - (maxBlinkSpeed - minBlinkSpeed) * enemyFlowIntensity;
                        const blinkFactor = (Math.sin(now / currentBlinkSpeed) + 1) / 2; // Smooth pulse from 0 to 1

                        // Convert currentEnemyColor to HSL to modulate it for blinking
                        let [h_e, s_e, l_e] = hexToHsl(currentEnemyColor);

                        // Apply saturation boost based on blinkFactor and flowIntensity
                        const maxSaturationBoost_e = 50; // Increased for more obvious effect, same as player
                        s_e = s_e + (blinkFactor * enemyFlowIntensity * maxSaturationBoost_e);
                        s_e = Math.min(100, s_e); // Clamp saturation

                        // Apply a subtle lightness pulse, making it slightly brighter at the peak of the blink
                        const maxLightnessPulse_e = 20; // Increased for more obvious effect, same as player
                        l_e = l_e + (blinkFactor * enemyFlowIntensity * maxLightnessPulse_e);
                        l_e = Math.min(100, l_e); // Clamp lightness

                        currentEnemyColor = hslToHex(h_e, s_e, l_e);

                        enemyFlowScale = 1 + (enemyFlowIntensity * 0.1 * blinkFactor); // Apply size pulse based on flow
                    }


                    const enemyFontWeight = getFontWeight(enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Pass current health and threshold
                    const enemyOpacity = getOpacity(enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Get opacity based on health

                    // Check if enemy is visible to player
                    const enemyX = Math.floor(enemy.x);
                    const enemyY = Math.floor(enemy.y);
                    const isEnemyVisible = visibilityMap && enemyY < visibilityMap.length && 
                                         enemyX < visibilityMap[0].length && visibilityMap[enemyY][enemyX];

                    if (isEnemyOnScreen && isEnemyVisible) {
                        // Draw enemy square
                        ctx.save();
                        ctx.globalAlpha = enemyOpacity;
                        ctx.fillStyle = currentEnemyColor;
                        ctx.fillRect(Math.floor(enemyCanvasX), Math.floor(enemyCanvasY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                        ctx.restore();

                        // Draw enemy head (behind hair)
                        if (enemy.head) {
                            ctx.save();
                            ctx.globalAlpha = enemyOpacity;
                            drawHead(ctx, 
                                Math.floor(enemyCanvasX), 
                                Math.floor(enemyCanvasY), 
                                Math.floor(currentRenderTileSize), 
                                enemy.head
                            );
                            ctx.restore();
                        }

                        // Draw enemy eyes (over head, under hair)
                        if (enemy.eyes && enemy.head) {
                            ctx.save();
                            ctx.globalAlpha = enemyOpacity;
                            drawEyes(ctx, 
                                Math.floor(enemyCanvasX), 
                                Math.floor(enemyCanvasY), 
                                Math.floor(currentRenderTileSize), 
                                enemy.eyes,
                                enemy.head,
                                enemy.x,  // Pass enemy's world X coordinate
                                enemy.y   // Pass enemy's world Y coordinate
                            );
                            ctx.restore();
                        }

                        // Draw enemy hair
                        if (enemy.hair) {
                            ctx.save();
                            ctx.globalAlpha = enemyOpacity;
                            drawHair(ctx, 
                                Math.floor(enemyCanvasX), 
                                Math.floor(enemyCanvasY), 
                                Math.floor(currentRenderTileSize), 
                                enemy.hair
                            );
                            ctx.restore();
                        }

                        // Draw enemy health number
                        ctx.save();
                        ctx.globalAlpha = enemyHealthOpacity;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = `${enemyFontWeight} ${Math.floor(currentRenderTileSize * 0.25 * enemyFlowScale)}px VT323`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText(enemy.health, Math.floor(enemyCanvasX + 3 + currentEnemyThrustOffsetX), Math.floor(enemyCanvasY + 3 + currentEnemyThrustOffsetY));
                        ctx.restore();

                        // Draw enemy name in a crisp font at the bottom of the square
                        ctx.save();
                        ctx.globalAlpha = 1;  // Full opacity for better legibility
                        // Crisp font with slightly reduced weight and smaller size
                        ctx.font = `${Math.max(8, Math.floor(currentRenderTileSize * 0.2))}px 'VT323'`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';  // Align to bottom of the square
                        // Draw black outline first for better contrast
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(enemy.name, 
                            Math.floor(enemyCanvasX + currentRenderTileSize / 2),
                            Math.floor(enemyCanvasY + currentRenderTileSize));
                        // Then draw white text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(enemy.name, 
                            Math.floor(enemyCanvasX + currentRenderTileSize / 2),
                            Math.floor(enemyCanvasY + currentRenderTileSize));
                        ctx.restore();
                    } else if (isEnemyVisible) {
                        // Only show off-screen indicator if enemy is visible
                        drawOffScreenIndicator(enemy, currentEnemyColor, currentRenderOffsetX, currentRenderOffsetY, enemyOpacity); // Indicator also uses dynamic color and opacity
                    }
                });

                let currentHealthTextScale = 1;
                const healthAnimDuration = 200;
                if (player.healthAnimStartTime > 0 && (now - player.healthAnimStartTime) * timeScale < healthAnimDuration) { // Apply timeScale
                    const progress = ((now - player.healthAnimStartTime) * timeScale) / healthAnimDuration;
                    if (progress < 0.5) {
                        currentHealthTextScale = 1 + (0.5 * progress * 2);
                    } else {
                        currentHealthTextScale = 1.5 - (0.5 * (progress - 0.5) * 2);
                    }
                } else {
                    player.healthAnimStartTime = 0;
                }

                let currentPlayerThrustOffsetX = 0;
                let currentPlayerThrustOffsetY = 0;
                let playerHealthOpacity = 1;

                if (player.thrustAnimActive) {
                    const elapsed = (now - player.thrustAnimStartTime) * timeScale; // Apply timeScale
                    if (elapsed < player.thrustAnimDuration) {
                        const progress = elapsed / player.thrustAnimDuration;
                        const thrustFactor = Math.sin(progress * Math.PI); // Smooth forward and back
                        const displacementMagnitude = currentRenderTileSize * 0.4 * player.thrustAnimMagnitude; // Max thrust is 40% of tile size, scaled by damage
                        currentPlayerThrustOffsetX = player.thrustAnimDirectionX * thrustFactor * displacementMagnitude;
                        currentPlayerThrustOffsetY = player.thrustAnimDirectionY * thrustFactor * displacementMagnitude;
                        playerHealthOpacity = 1 - (progress * 0.5); // Fade out slightly
                    } else {
                        player.thrustAnimActive = false; // Animation finished
                    }
                }

                // Calculate health ratio for player color and font
                let currentPlayerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Base color based on health

                // Calculate player flow for blinking effect
                playerFlow = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0; // Assign to the global playerFlow
                const flowIntensity = Math.min(1, playerFlow); // Cap intensity at 1 flow

                let playerFlowScale = 1; // Initialize playerFlowScale
                if (flowIntensity > 0) {
                    // Invert flow intensity for blink speed: higher flow -> smaller blink speed (faster)
                    const minBlinkSpeed = 50; // Fastest blink speed (for flowIntensity = 1)
                    const maxBlinkSpeed = 200; // Slowest blink speed (for flowIntensity = 0, effectively)
                    const currentBlinkSpeed = maxBlinkSpeed - (maxBlinkSpeed - minBlinkSpeed) * flowIntensity;
                    const blinkFactor = (Math.sin(now / currentBlinkSpeed) + 1) / 2; // Smooth pulse from 0 to 1

                    // Convert currentPlayerColor to HSL to modulate it for blinking
                    let [h, s, l] = hexToHsl(currentPlayerColor);

                    // Apply saturation boost based on blinkFactor and flowIntensity
                    const maxSaturationBoost = 50; // Increased for more obvious effect
                    s = s + (blinkFactor * flowIntensity * maxSaturationBoost);
                    s = Math.min(100, s); // Clamp saturation

                    // Apply a subtle lightness pulse, making it slightly brighter at the peak of the blink
                    const maxLightnessPulse = 20; // Increased for more obvious effect
                    l = l + (blinkFactor * flowIntensity * maxLightnessPulse);
                    l = Math.min(100, l); // Clamp lightness

                    currentPlayerColor = hslToHex(h, s, l);

                    playerFlowScale = 1 + (flowIntensity * 0.1 * blinkFactor); // Apply size pulse based on flow
                }

                const playerFontWeight = getFontWeight(player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Pass current health and threshold
                const playerOpacity = getOpacity(player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Get opacity based on health

                // Only draw player if not game over (player explodes and is no longer drawn as a solid block)
                    if (!gameOver) {
                        // Draw player square
                        ctx.save();
                        ctx.globalAlpha = playerOpacity;
                        ctx.fillStyle = currentPlayerColor;
                        ctx.fillRect(Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX), Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                        ctx.restore();
                        
                        // Draw player head (behind hair)
                        if (player.head) {
                            ctx.save();
                            ctx.globalAlpha = playerOpacity;
                            drawHead(ctx, 
                                Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX), 
                                Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY), 
                                Math.floor(currentRenderTileSize), 
                                player.head
                            );
                            ctx.restore();
                        }
                        
                        // Draw player eyes (over head, under hair)
                        if (player.eyes && player.head) {
                            ctx.save();
                            ctx.globalAlpha = playerOpacity;
                            drawEyes(ctx, 
                                Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX), 
                                Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY), 
                                Math.floor(currentRenderTileSize), 
                                player.eyes,
                                player.head
                                // Player doesn't need to look at themselves, so no world coordinates passed
                            );
                            ctx.restore();
                        }
                        
                        // Draw player hair
                        if (player.hair) {
                            ctx.save();
                            ctx.globalAlpha = playerOpacity;
                            drawHair(ctx, 
                                Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX), 
                                Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY), 
                                Math.floor(currentRenderTileSize), 
                                player.hair
                            );
                            ctx.restore();
                        }
                        
                        // Draw player name in a crisp font at the bottom of the square
                        ctx.save();
                        ctx.globalAlpha = 1;  // Full opacity for better legibility
                        // Crisp font with slightly reduced weight and smaller size
                        ctx.font = `${Math.max(8, Math.floor(currentRenderTileSize * 0.2))}px 'VT323'`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';  // Align to bottom of the square
                        // Draw black outline first for better contrast
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(player.name, 
                            Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2), 
                            Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize));
                        // Then draw white text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(player.name, 
                            Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2), 
                            Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize));
                        ctx.restore();
                        ctx.restore();
                    ctx.save(); // Save context again for text opacity
                    ctx.globalAlpha = playerHealthOpacity; // Apply thrust animation opacity
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${playerFontWeight} ${Math.floor(currentRenderTileSize * 0.25 * currentHealthTextScale * playerFlowScale)}px VT323`; // Use dynamic font weight and flow scale
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    ctx.fillText(player.health, Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + 3 + currentPlayerThrustOffsetX), Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + 3 + currentPlayerThrustOffsetY));
                    ctx.restore(); // Restore context
                }


                for (let i = activeExplosions.length - 1; i >= 0; i--) {
                    const explosion = activeExplosions[i];
                    
                    // Check if explosion is visible to player
                    const explosionX = Math.floor(explosion.x);
                    const explosionY = Math.floor(explosion.y);
                    const isExplosionVisible = visibilityMap && explosionY < visibilityMap.length && 
                                             explosionX < visibilityMap[0].length && visibilityMap[explosionY][explosionX];
                    
                    if (!isExplosionVisible) continue; // Skip if not visible
                    
                    const elapsed = (now - explosion.startTime) * timeScale; // Apply timeScale
                    const progress = elapsed / explosion.duration;

                    if (progress >= 1) {
                        activeExplosions.splice(i, 1);
                        continue;
                    }

                    for (let j = explosion.particles.length - 1; j >= 0; j--) {
                        const particle = explosion.particles[j];
                        const particleProgress = ((now - particle.startTime) * timeScale) / particle.duration; // Apply timeScale

                        if (particleProgress >= 1) {
                            continue;
                        }

                        // Calculate current size of the particle (shrinks over time)
                        const initialParticleSize = currentRenderTileSize * 0.2; // Starting size for fragments
                        const currentParticleSize = initialParticleSize * (1 - particleProgress * 0.7); // Shrink more significantly

                        const currentX = particle.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + particle.initialVelocityX * elapsed;
                        const currentY = particle.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + particle.initialVelocityY * elapsed;

                        ctx.save();
                        ctx.globalAlpha = (1 - particleProgress) * particle.fadeFactor; // Apply random fade factor
                        ctx.fillStyle = particle.color;
                        ctx.fillRect(Math.floor(currentX - currentParticleSize / 2), Math.floor(currentY - currentParticleSize / 2), Math.floor(currentParticleSize), Math.floor(currentParticleSize));
                        ctx.restore();
                    }
                }

                // Draw static pickups (including player remains)
                // Note: Text alignment is now set individually for each pickup to position them at corners
                staticDamageNumbers.forEach(staticNum => {
                    // Check if pickup is visible to player
                    const pickupX = Math.floor(staticNum.x);
                    const pickupY = Math.floor(staticNum.y);
                    const isPickupVisible = visibilityMap && pickupY < visibilityMap.length && 
                                          pickupX < visibilityMap[0].length && visibilityMap[pickupY][pickupX];
                    
                    if (!isPickupVisible) return; // Skip rendering if not visible
                    
                    if (staticNum.parts && staticNum.parts.length > 0) {
                        staticNum.parts.forEach(part => {
                            let writhingXOffset = 0;
                            let writhingYOffset = 0;
                            if (staticNum.isPlayerRemains) {
                                writhingXOffset = Math.cos(staticNum.writhingOffsetAngle + now * staticNum.writhingSpeed) * staticNum.writhingOffsetRadius;
                                writhingYOffset = Math.sin(staticNum.writhingOffsetAngle + now * staticNum.writhingSpeed) * staticNum.writhingOffsetRadius;
                            }

                            // Position pickup numbers around the edges of the tile to avoid center overlap with agent health
                            // Use a hash of the pickup position to deterministically place it in a corner
                            // Player remains stay centered for visibility
                            let cornerOffsetX, cornerOffsetY, textAlign, textBaseline;
                            
                            if (staticNum.isPlayerRemains) {
                                // Keep player remains centered and visible
                                cornerOffsetX = currentRenderTileSize / 2;
                                cornerOffsetY = currentRenderTileSize / 2;
                                textAlign = 'center';
                                textBaseline = 'middle';
                            } else {
                                // Position regular pickups in corners based on position hash
                                const positionHash = (staticNum.x * 31 + staticNum.y * 17) % 4; // Generate 0-3 for four corners
                                const edgeMargin = Math.max(4, Math.floor(currentRenderTileSize * 0.1)); // Small margin from tile edge
                                
                                switch (positionHash) {
                                    case 0: // Top-left
                                        cornerOffsetX = edgeMargin;
                                        cornerOffsetY = edgeMargin;
                                        textAlign = 'left';
                                        textBaseline = 'top';
                                        break;
                                    case 1: // Top-right
                                        cornerOffsetX = currentRenderTileSize - edgeMargin;
                                        cornerOffsetY = edgeMargin;
                                        textAlign = 'right';
                                        textBaseline = 'top';
                                        break;
                                    case 2: // Bottom-left
                                        cornerOffsetX = edgeMargin;
                                        cornerOffsetY = currentRenderTileSize - edgeMargin;
                                        textAlign = 'left';
                                        textBaseline = 'bottom';
                                        break;
                                    case 3: // Bottom-right
                                        cornerOffsetX = currentRenderTileSize - edgeMargin;
                                        cornerOffsetY = currentRenderTileSize - edgeMargin;
                                        textAlign = 'right';
                                        textBaseline = 'bottom';
                                        break;
                                }
                            }
                            
                            const drawX = staticNum.x * currentRenderTileSize + currentRenderOffsetX + cornerOffsetX + part.offsetX + writhingXOffset;
                            const drawY = staticNum.y * currentRenderTileSize + currentRenderOffsetY + cornerOffsetY + part.offsetY + writhingYOffset;
                            
                            // Determine color based on type of pickup
                            ctx.fillStyle = staticNum.isPlayerRemains ? staticNum.playerDeathColor : '#CCCC00'; // Use playerDeathColor if it's player remains

                            // Apply font weight based on pickup value - make pickups smaller and less bold
                            const pickupFontWeight = staticNum.isPlayerRemains ? 600 : Math.max(400, getFontWeight(part.content.value, Math.max(2, currentLevel)) - 200);
                            
                            // Make pickup font size much smaller to avoid overlaps
                            const baseFontSize = Math.floor(currentRenderTileSize * 0.3); // Reduced from 0.6 to 0.3
                            const minFontSize = Math.max(10, Math.floor(currentRenderTileSize * 0.25)); // Much smaller minimum
                            const pickupFontSize = Math.max(minFontSize, baseFontSize);
                            
                            ctx.font = `${pickupFontWeight} ${pickupFontSize}px VT323`;

                            // IMPORTANT: Remove yellow background squares
                            // Clear any canvas effects that might create backgrounds
                            ctx.save(); // Save current state
                            ctx.shadowBlur = 0;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;
                            ctx.shadowColor = 'transparent';
                            ctx.globalAlpha = 1; // Ensure no alpha blending issues
                            ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
                            
                            // Set text alignment based on corner position
                            ctx.textAlign = textAlign;
                            ctx.textBaseline = textBaseline;
                            
                            // Draw either number or symbol
                            if (part.content.type === 'number') {
                                ctx.fillText(part.content.value, Math.floor(drawX), Math.floor(drawY));
                            } else if (part.content.type === 'symbol') {
                                ctx.fillText(part.content.value, Math.floor(drawX), Math.floor(drawY));
                            }
                            
                            ctx.restore(); // Restore previous state
                        });
                    }
                });

                // Drawing activeDamageTextAnimations
                for (let i = activeDamageTextAnimations.length - 1; i >= 0; i--) {
                    const anim = activeDamageTextAnimations[i];
                    
                    // Check if damage text animation is visible to player
                    const damageX = Math.floor(anim.x);
                    const damageY = Math.floor(anim.y);
                    const isDamageVisible = visibilityMap && damageY < visibilityMap.length && 
                                          damageX < visibilityMap[0].length && visibilityMap[damageY][damageX];
                    
                    if (!isDamageVisible) continue; // Skip if not visible
                    
                    const elapsed = (now - anim.startTime) * timeScale; // Apply timeScale

                    if (elapsed < anim.delay) {
                        continue;
                    }

                    const effectiveElapsed = elapsed - anim.delay;
                    const progress = effectiveElapsed / anim.duration;

                    if (progress >= 1) {
                        activeDamageTextAnimations.splice(i, 1);
                        continue;
                    }

                    const opacity = 1 - progress;
                    const moveDistance = currentRenderTileSize * 1.2 * progress;

                    const drawX = Math.floor(anim.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.dirX * moveDistance);
                    const drawY = Math.floor(anim.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.dirY * moveDistance);

                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = anim.color;
                    const baseFontSize = currentRenderTileSize * 0.6;
                    const scaledFontSize = baseFontSize + (anim.amount * (currentRenderTileSize * 0.05));
                    ctx.font = `${Math.floor(scaledFontSize * (1 - progress * 0.5))}px VT323`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(anim.amount, drawX, drawY); // Draw the damage amount
                    ctx.restore();
                }

                // Drawing activePickupAnimations
                for (let i = activePickupAnimations.length - 1; i >= 0; i--) {
                    const anim = activePickupAnimations[i];
                    
                    // Check if pickup animation is visible to player
                    const animX = Math.floor(anim.x);
                    const animY = Math.floor(anim.y);
                    const isAnimVisible = visibilityMap && animY < visibilityMap.length && 
                                        animX < visibilityMap[0].length && visibilityMap[animY][animX];
                    
                    if (!isAnimVisible) continue; // Skip if not visible
                    
                    const elapsed = (now - anim.startTime) * timeScale; // Apply timeScale
                    const progress = elapsed / anim.duration;

                    if (progress >= 1) {
                        activePickupAnimations.splice(i, 1);
                        continue;
                    }

                    const opacity = 1 - progress;

                    const currentX = anim.startX * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.initialOffsetX + (player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 - (anim.startX * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.initialOffsetX)) * progress;
                    const currentY = anim.startY * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.initialOffsetY + (player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 - (anim.startY * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.initialOffsetY)) * progress;


                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = VINTAGE_GREEN; // Green color for health pickups
                    ctx.font = `${Math.floor(currentRenderTileSize * 0.6 * (1 - progress * 0.5))}px VT323`; // Shrink slightly
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(anim.amount, Math.floor(currentX), Math.floor(currentY));
                    ctx.restore();
                }

                // Calculate and draw the score at the top left
                let score = 0;
                if (stepsTaken > 0) {
                    const averageDamagePerTurn = totalDamageDealt / stepsTaken;
                    score = Math.floor(totalDamageDealt * averageDamagePerTurn);
                }

                // Draw a single black bar across the full width of the screen at the top
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, gameCanvas.width, SCORE_BOX_HEIGHT);

                // Calculate text positions for full-width layout
                const scoreFlowFontSize = Math.floor(SCORE_BOX_HEIGHT - (2 * SCORE_BOX_PADDING));
                ctx.font = `${scoreFlowFontSize}px VT323`;
                ctx.textBaseline = 'middle';
                const textY = SCORE_BOX_HEIGHT / 2;

                // Draw SCORE on the left
                ctx.fillStyle = '#e2e8f0';
                ctx.textAlign = 'left';
                ctx.fillText(`SCORE: ${score}`, 10, textY);

                // Calculate and draw the FLOW on the right
                const displayFlow = playerFlow.toFixed(2);
                ctx.textAlign = 'right';
                ctx.fillText(`FLOW: ${displayFlow}`, gameCanvas.width - 10, textY);

                // Draw the current world info in the center
                const world = getCurrentWorld();
                ctx.fillStyle = world.colors.stairs; // Use world's theme color
                ctx.textAlign = 'center';
                ctx.fillText(`WORLD ${currentWorld}: ${world.name.toUpperCase()}`, gameCanvas.width / 2, textY);

                // Draw the "HARD DIVISION" overlay if active
                if (gameStartedOverlayActive) {
                    const elapsed = now - gameStartedOverlayStartTime;
                    let opacity = 1;
                    let currentTitleFontSize;

                    // Phase 1: Zoom In
                    if (elapsed < OVERLAY_ZOOM_DURATION) {
                        const zoomProgress = elapsed / OVERLAY_ZOOM_DURATION;
                        const initialSize = Math.floor(gameCanvas.height * INITIAL_OVERLAY_FONT_FACTOR); // Use gameCanvas.height
                        const targetSize = Math.floor(gameCanvas.height * MAX_OVERLAY_FONT_FACTOR); // Use gameCanvas.height
                        currentTitleFontSize = initialSize + (targetSize - initialSize) * zoomProgress;
                        opacity = 1; // Full opacity during zoom
                    }
                    // Phase 2: Fade Out (starts after zoom)
                    else {
                        const fadeElapsed = elapsed - OVERLAY_ZOOM_DURATION;
                        const fadeProgress = Math.min(1, fadeElapsed / OVERLAY_FADE_DURATION);
                        opacity = 1 - fadeProgress;
                        currentTitleFontSize = Math.floor(gameCanvas.height * MAX_OVERLAY_FONT_FACTOR); // Hold max size during fade // Use gameCanvas.height
                    }

                    if (opacity <= 0) {
                        gameStartedOverlayActive = false; // Deactivate once fully faded
                        showTopBar(); // Show top bar when title fade completes
                    } else {
                        ctx.save();
                        ctx.globalAlpha = opacity;
                        ctx.fillStyle = '#FFD700'; // Gold color for the title
                        ctx.font = `${currentTitleFontSize}px VT323`; // Use dynamic font size
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Add shadow
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; // Black shadow, slightly transparent
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 5;
                        ctx.shadowOffsetY = 5;

                        ctx.fillText("HARD DIVISION", gameCanvas.width / 2, gameCanvas.height / 2 - gameCanvas.height * 0.05); // Use gameCanvas.width/height
                        ctx.restore();
                    }
                }

                // Removed the word bubble drawing logic from here as per user request.
                // Event messages will now only appear in the dialogue area on the left.

                // Draw the "PRESS R TO RESTART" message or its particles if game is over
                // This block now draws if gameOver OR if the restart animation is active
                if (gameOver || restartTextAnimationActive) {
                    if (restartTextAnimationActive) {
                        const elapsed = now - restartTextAnimationStartTime;
                        const progress = elapsed / RESTART_TEXT_EXPLOSION_DURATION;

                        if (progress >= 1) {
                            restartTextAnimationActive = false;
                            restartTextParticles = []; // Clear particles once animation is done
                        } else {
                            for (let i = restartTextParticles.length - 1; i >= 0; i--) {
                                const particle = restartTextParticles[i];
                                const particleProgress = (now - particle.startTime) / RESTART_TEXT_EXPLOSION_DURATION;

                                if (particleProgress >= 1) {
                                    continue;
                                }

                                const opacity = 1 - particleProgress;
                                const moveDistance = particle.initialSpeed * elapsed; // Use elapsed for continuous movement

                                const currentX = particle.startX + particle.dirX * moveDistance;
                                const currentY = particle.startY + particle.dirY * moveDistance;

                                ctx.save();
                                ctx.globalAlpha = opacity;
                                ctx.fillStyle = particle.color;
                                // Ensure font size consistency
                                ctx.font = `${Math.floor(dynamicTileSize * 0.8 * (1 - particleProgress * 0.5))}px VT323`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(particle.char, currentX, currentY);
                                ctx.restore();
                            }
                        }
                    } else if (gameOver) { // Only draw static text if game is over AND no animation is active
                        ctx.fillStyle = '#FFD700'; // Gold color for restart message
                        ctx.font = `${Math.floor(currentRenderTileSize * 0.8)}px VT323`; // Use currentRenderTileSize for scaling
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText("PRESS R TO RESTART", gameCanvas.width / 2, gameCanvas.height / 2 + currentRenderTileSize * 1.5); // Use gameCanvas.width/height
                    }
                }

                // Update popup messages
                updatePopupMessages();

                // Update frame timing for next frame
                lastFrameTime = now;

            } catch (error) {
                console.error("Error in animation loop:", error);
                stopAnimationLoop(); // Stop the loop to prevent further errors
                handleGameOver(); // Attempt to gracefully end the game
            } finally {
                // Performance monitoring disabled to reduce console clutter
                
                // Always schedule next frame for smooth animation
                if (!gameOver) {
                    requestAnimationFrame(drawGame);
                }
            }
        }

        /**
         * Moves an entity (player or enemy) towards a target, considering obstacles.
         * @param {object} entity - The entity to move ({x, y}).
         * @param {number} targetX - The target X coordinate.
         * @param {number} targetY - The target Y coordinate.
         * @param {Array<object>} obstacles - An array of other entities (excluding the moving entity) to avoid.
         * @param {object|null} forbiddenTarget - An optional tile that the entity explicitly cannot move onto.
         * @returns {boolean} True if the entity moved, false otherwise.
         */
        function moveEntityTowardsTarget(entity, targetX, targetY, obstacles, forbiddenTarget = null) {
            // Validate entity position before attempting to move
            if (isNaN(entity.x) || isNaN(entity.y) || entity.x === null || entity.y === null) {
                console.error("Entity position is invalid. Cannot move.");
                return false;
            }

            const dxToTarget = targetX - entity.x;
            const dyToTarget = targetY - entity.y;

            let moveX = 0;
            let moveY = 0;

            // Prioritize movement along the axis with the greater distance
            if (Math.abs(dxToTarget) > Math.abs(dyToTarget)) {
                moveX = Math.sign(dxToTarget);
            } else {
                moveY = Math.sign(dyToTarget);
            }

            let newX = entity.x + moveX;
            let newY = entity.y + moveY;

            // Check if the primary move is valid
            if (newX < 0 || newX >= dynamicMapWidth || newY < 0 || newY >= dynamicMapHeight ||
                gameMap[newY][newX] === TILE_WALL ||
                obstacles.some(o => o.x === newX && o.y === newY) ||
                (forbiddenTarget && newX === forbiddenTarget.x && newY === forbiddenTarget.y)) {
                // If the primary move is blocked, try the other axis
                moveX = 0;
                moveY = 0;
                if (Math.abs(dxToTarget) > Math.abs(dyToTarget)) { // If X was primary, try Y
                    moveY = Math.sign(dyToTarget);
                } else { // If Y was primary, try X
                    moveX = Math.sign(dxToTarget);
                }
                newX = entity.x + moveX;
                newY = entity.y + moveY;
            }

            // Final check for the chosen move (either primary or secondary)
            if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                (gameMap[newY][newX] === TILE_FLOOR || gameMap[newY][newX] === TILE_STAIRS) &&
                !obstacles.some(o => o.x === newX && o.y === newY) &&
                !(forbiddenTarget && newX === forbiddenTarget.x && newY === forbiddenTarget.y)) {
                entity.x = newX;
                entity.y = newY;
                
                // Invalidate caches when entities move
                cacheValidationFrame++;
                invalidateSpatialIndex();
                
                // Increment steps taken for enemies if they are moving
                if (entity.totalDamageDealtByThisEnemy !== undefined && entity.stepsTakenByThisEnemy !== undefined) { // Check if it's an enemy
                    entity.stepsTakenByThisEnemy = entity.stepsTakenByThisEnemy + 1; // Explicit assignment
                }
                return true; // Movement successful
            }

            return false; // Movement failed
        }

        /**
         * Adds a damage text animation to the queue.
         * @param {number} x - X coordinate of the hit entity.
         * @param {number} y - Y coordinate of the hit entity.
         * @param {number} amount - Damage amount.
         * @param {string} color - Color of the damage text.
         * @param {number} dirX - X component of the direction vector for animation.
         * @param {number} dirY - Y component of the direction vector for animation.
         * @param {number} duration - Duration of the animation in milliseconds.
         * @param {number} delay - Delay before animation starts in milliseconds.
         */
        function addDamageAnimation(x, y, amount, color, dirX, dirY, duration = 1000, delay = 0) {
            activeDamageTextAnimations.push({
                x: x,
                y: y,
                amount: amount,
                color: VINTAGE_GREEN,
                dirX: dirX,
                dirY: dirY,
                startTime: performance.now(),
                duration: duration,
                delay: delay
            });
        }

        /**
         * Creates a single particle for an explosion animation.
         * @param {number} x - X coordinate of the particle's origin.
         * @param {number} y - Y coordinate of the particle's origin.
         * @param {string} color - Color of the particle.
         * @param {number} initialVelocityX - Initial horizontal velocity.
         * @param {number} initialVelocityY - Initial vertical velocity.
         * @param {number} duration - Duration of the particle's animation.
         * @param {number} fadeFactor - A factor to control how quickly the particle fades.
         * @returns {object} Particle object.
         */
        function createParticle(x, y, color, initialVelocityX, initialVelocityY, duration, fadeFactor) {
            return {
                x: x,
                y: y,
                color: color,
                initialVelocityX: initialVelocityX,
                initialVelocityY: initialVelocityY,
                startTime: performance.now(),
                duration: duration,
                fadeFactor: fadeFactor
            };
        }

        /**
         * Adds an explosion animation at a given tile.
         * @param {number} tileX - X coordinate of the tile.
         * @param {number} tileY - Y coordinate of the tile.
         * @param {string} color - Color of the particles.
         * @param {number} damageAmount - The damage that caused the explosion (for scaling).
         * @param {number} numParticles - Number of particles in the explosion.
         * @param {number} duration - Duration of the explosion animation in milliseconds.
         * @param {number} [spreadFactor=1] - Multiplier for particle spread.
         */
        function addExplosionAnimation(tileX, tileY, color, damageAmount, numParticles = 15, duration = 1500, spreadFactor = 1) {
            const scaledNumParticles = Math.max(5, Math.min(numParticles + (damageAmount * 1), 50)); // Cap at 50 for performance

            const explosion = {
                particles: [],
                startTime: performance.now(),
                duration: duration,
                damageAmount: damageAmount
            };

            for (let i = 0; i < scaledNumParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                // Scale speed by the provided spreadFactor
                const speed = (Math.random() * 1.0 + 0.1) * (dynamicTileSize / 150) * spreadFactor;
                const initialVelocityX = Math.cos(angle) * speed;
                const initialVelocityY = Math.sin(angle) * speed;
                const randomFadeFactor = Math.random() * 0.7 + 0.3;
                explosion.particles.push(createParticle(tileX, tileY, color, initialVelocityX, initialVelocityY, duration, randomFadeFactor));
            }
            activeExplosions.push(explosion);
        }

        /**
         * Handles game over state.
         */
        function handleGameOver() {
            // Prevent multiple executions
            if (gameOver) {
                console.log("Game Over already triggered, ignoring duplicate call.");
                return;
            }
            console.log("Game Over triggered.");
            gameOver = true;
            stopAutomatedMovement();
            // Do not stop animation loop here, enemies need to move and explosion needs to play
            window.removeEventListener('keydown', handleKeyDown); // Temporarily remove player movement listener

            // Activate death animation effects
            deathAnimationActive = true;
            deathAnimationStartTime = performance.now();
            timeScale = DEATH_SLOW_MOTION_FACTOR; // Activate slow motion

            // Capture player's final color
            const playerHealthRatio = player.health / PLAYER_VISUAL_HEALTH_THRESHOLD;
            const finalPlayerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD);

            // Player death animation: Explode and scatter numbers/symbols
            addExplosionAnimation(player.x, player.y, finalPlayerColor, player.health, PLAYER_DEATH_PARTICLE_COUNT, PLAYER_DEATH_EXPLOSION_DURATION, PLAYER_DEATH_PARTICLE_SPREAD_FACTOR);

            // Scatter player's "numbers" (health/damage dealt) and symbols as pickups
            let remainingValueToScatter = player.health;
            const scatterCount = Math.min(player.health + MATH_SYMBOLS.length, 50); // More particles for drama
            for (let i = 0; i < scatterCount; i++) {
                const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR; // Wider spread
                const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;

                let partContent;
                if (remainingValueToScatter > 0 && Math.random() < 0.7) { // Bias towards numbers initially
                    const value = Math.min(PLAYER_DEATH_PICKUP_VALUE_PER_CHUNK, remainingValueToScatter);
                    partContent = { type: 'number', value: value };
                    remainingValueToScatter = remainingValueToScatter - value; // Explicit assignment
                } else {
                    const symbol = MATH_SYMBOLS[getRandomInt(0, MATH_SYMBOLS.length - 1)];
                    partContent = { type: 'symbol', value: symbol };
                }

                staticDamageNumbers.push({
                    x: player.x,
                    y: player.y,
                    parts: [{ content: partContent, offsetX: randomOffsetX, offsetY: randomOffsetY }], // Changed 'amount' to 'content'
                    isEnemyDrop: false,
                    isPlayerRemains: true,
                    playerDeathColor: finalPlayerColor, // Store the player's death color with the remains
                    writhingOffsetAngle: Math.random() * Math.PI * 2, // Initial angle for writhing
                    writhingOffsetRadius: (Math.random() * 0.5 + 0.5) * dynamicTileSize * 0.1, // Small radius, slightly varied
                    writhingSpeed: (Math.random() * 0.0005 + 0.0002) // Very slow speed for subtle writhing
                });
                staticCollectionsDirty = true; // Mark cache as needing update
            }
            // Ensure any remaining value is scattered as a final number if any
            if (remainingValueToScatter > 0) {
                const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;
                const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;
                staticDamageNumbers.push({
                    x: player.x,
                    y: player.y,
                    parts: [{ content: { type: 'number', value: remainingValueToScatter }, offsetX: randomOffsetX, offsetY: randomOffsetY }],
                    isEnemyDrop: false,
                    isPlayerRemains: true,
                    playerDeathColor: finalPlayerColor,
                    writhingOffsetAngle: Math.random() * Math.PI * 2,
                    writhingOffsetRadius: (Math.random() * 0.5 + 0.5) * dynamicTileSize * 0.1,
                    writhingSpeed: (Math.random() * 0.0005 + 0.0002)
                });
                staticCollectionsDirty = true; // Mark cache as needing update
            }

            // Calculate final score and add to leaderboard
            let finalScore = 0;
            if (stepsTaken > 0) {
                const scoreMultiplier = Math.max(1, currentLevel * 0.5);
                const flowBonus = Math.floor((totalDamageDealt / stepsTaken) * 100);
                const healthBonus = Math.floor(player.health * 5);
                const levelBonus = Math.floor((currentLevel - 1) * 200);
                finalScore = Math.floor((totalDamageDealt + flowBonus + healthBonus + levelBonus) * scoreMultiplier);
            }
            
            // Update total player score for world progression
            totalPlayerScore = Math.max(totalPlayerScore, finalScore);
            localStorage.setItem('hardDivisionTotalScore', totalPlayerScore.toString());
            checkAndUnlockWorlds();
            
            // Add score to leaderboard if it's high enough
            if (finalScore > 0 && (leaderboard.length < 10 || finalScore > leaderboard[leaderboard.length - 1].score)) {
                addToLeaderboard(finalScore);
            }

            // Start enemy swarm behavior (animation loop is already running)
            startEnemySwarm();

            // Re-add event listener for restart only
            window.addEventListener('keydown', handleRestartKeyDown);
        }

        /**
         * Handles the 'R' key press for restarting the game.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleRestartKeyDown(event) {
            if (gameOver && (event.key === 'r' || event.key === 'R')) {
                event.preventDefault();

                // Get the position and size of the "PRESS R TO RESTART" text
                const restartText = "PRESS R TO RESTART";
                // Use dynamicTileSize for font sizing to match the game's current scale
                const baseFontSize = Math.floor(dynamicTileSize * 0.8);
                ctx.font = `${baseFontSize}px VT323`;
                const textMetrics = ctx.measureText(restartText);
                const textWidth = textMetrics.width;
                const textHeight = baseFontSize; // Approximate height based on font size

                const textX = gameCanvas.width / 2;
                const textY = gameCanvas.height / 2 + dynamicTileSize * 1.5;

                // Generate particles for each character
                restartTextParticles = [];
                let currentTextX = textX - textWidth / 2; // Start X for the first character
                const charSpacing = textWidth / restartText.length; // Simple even spacing

                for (let i = 0; i < restartText.length; i++) {
                    const char = restartText[i];
                    const charX = currentTextX + charSpacing * i + charSpacing / 2; // Center of the character
                    const charY = textY;

                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 0.5 + 0.2) * (dynamicTileSize / 20); // Slower, more controlled spread
                    const dirX = Math.cos(angle);
                    const dirY = Math.sin(angle);
                    const fadeFactor = Math.random() * 0.7 + 0.3;

                    restartTextParticles.push({
                        char: char,
                        startX: charX,
                        startY: charY,
                        dirX: dirX,
                        dirY: dirY,
                        initialSpeed: speed,
                        fontSize: baseFontSize, // Use the calculated baseFontSize for consistency
                        color: '#FFD700', // Gold color for the text particles
                        startTime: performance.now(),
                        duration: RESTART_TEXT_EXPLOSION_DURATION,
                        fadeFactor: fadeFactor
                    });
                }

                restartTextAnimationActive = true;
                restartTextAnimationStartTime = performance.now();

                // Immediately start the game restart (which includes the zoom-out)
                restartGame();
            }
        }

        /**
         * Restarts the game.
         */
        function restartGame() {
            window.removeEventListener('keydown', handleRestartKeyDown); // Remove restart listener
            initGame(true, false); // Start a brand new game, no overlay on restart
            // The animation loop is already running, no need to restart it here.
        }

        /**
         * Initiates enemy swarm behavior after player death.
         */
        function startEnemySwarm() {
            // This function ensures enemies continuously move towards player remains.
            // The actual movement logic is within enemyTurn().
            console.log("Enemies starting swarm behavior.");
        }

        /**
         * Checks the player's current tile for any static health pickups and collects them.
         */
        function checkAndCollectPickups() {
            for (let i = staticDamageNumbers.length - 1; i >= 0; i--) {
                const staticNum = staticDamageNumbers[i];
                // Only collect non-player-remains pickups
                if (!staticNum.isPlayerRemains && getDistance(player, staticNum) <= DIRECT_PICKUP_RADIUS) {
                    let healthGained = 0;
                    staticNum.parts.forEach(part => {
                        healthGained = healthGained + part.content.value; // Explicit assignment
                        activePickupAnimations.push({
                            startX: staticNum.x,
                            startY: staticNum.y,
                            initialOffsetX: part.offsetX || 0,
                            initialOffsetY: part.offsetY || 0,
                            amount: part.content.value, // Pass value from content
                            color: VINTAGE_GREEN,
                            startTime: performance.now(),
                            duration: 300
                        });
                    });
                    player.health = player.health + healthGained; // Explicit assignment
                    totalPickupValueCollectedThisTurn = totalPickupValueCollectedThisTurn + healthGained; // Explicit assignment
                    player.healthAnimScale = 1.5;
                    player.healthAnimStartTime = performance.now();
                    
                    // Add pickup message
                    if (healthGained >= 10) {
                        addPickupMessage(`${player.name} collected major health pickup (+${healthGained})`, 'high');
                    } else if (healthGained >= 5) {
                        addPickupMessage(`${player.name} collected health (+${healthGained})`, 'medium');
                    } else {
                        addPickupMessage(`${player.name} collected health (+${healthGained})`, 'low');
                    }
                    
                    staticDamageNumbers.splice(i, 1);
                    staticCollectionsDirty = true; // Mark cache as needing update
                }
            }
        }

        /**
         * Applies health loss to the player based on steps taken.
         * Interval and damage are both inversely proportional to current health.
         */
        function applyStepBasedHealthLoss() {
            // Calculate dynamic interval based on health
            const MIN_INTERVAL = 10;  // Minimum steps between health loss (when health is high)
            const MAX_INTERVAL = 37;  // Maximum steps between health loss (when health is low)
            
            let dynamicInterval;
            if (player.health <= 1) {
                dynamicInterval = MAX_INTERVAL; // Lowest health = longest interval
            } else {
                // Use inverse proportion: interval = MAX_INTERVAL / (health)
                // Clamp to minimum interval to prevent too-frequent health loss at high health
                dynamicInterval = Math.max(MIN_INTERVAL, Math.floor(MAX_INTERVAL / player.health));
            }

            if (stepsTaken > 0 && stepsTaken % dynamicInterval === 0) {
                // Always lose 10% of current health (rounded)
                let damage = Math.round(player.health * 0.1);
                if (damage < 1 && player.health > 0) {
                    damage = 1;
                } else if (player.health === 0) {
                    damage = 0;
                }

                if (damage > 0) {
                    player.health = player.health - damage;
                    hitsTaken = hitsTaken + 1;
                    hitsTakenThisTurn = hitsTakenThisTurn + 1;
                    playerTookDamageInCombatThisTurn = true;
                    const animDuration = Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damage - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE));
                    addDamageAnimation(player.x, player.y, damage, VINTAGE_GREEN, 0, -1, animDuration, 0);
                }

                // Sanity check for player health after health loss
                if (isNaN(player.health)) {
                    console.error("Player health became NaN after step-based health loss! Forcing game over.");
                    player.health = 0;
                }

                if (player.health <= 0) {
                    player.health = 0; // Ensure health doesn't go negative for display
                    handleGameOver();
                }
            }
        }

        /**
         * Moves the player if the target tile is a floor or stairs.
         * Handles combat if the target tile is occupied by an enemy.
         * @param {number} dx - Change in X coordinate.
         * @param {number} dy - Change in Y coordinate.
         * @returns {boolean} True if combat occurred, false otherwise.
         */
        function movePlayer(dx, dy) {
            if (gameOver) return false;

            // Validate player position before attempting to move
            if (isNaN(player.x) || isNaN(player.y) || player.x === null || player.y === null) {
                console.error("Player position is invalid. Cannot move.");
                return false;
            }

            const newX = player.x + dx;
            const newY = player.y + dy;

            if (newX < 0 || newX >= dynamicMapWidth || newY < 0 || newY >= dynamicMapHeight) {
                return false;
            }

            const collidedEnemyIndex = enemies.findIndex(e => e.x === newX && e.y === newY);

            if (collidedEnemyIndex !== -1) {
                const attackedEnemy = enemies[collidedEnemyIndex];
                const enemyHealthBeforeHit = attackedEnemy.health; // Store health before hit
                const enemyInitialHealth = attackedEnemy.initialHealth; // Store initial health of this enemy

                let playerAttacksFirst = Math.random() < 0.5;
                combatOccurredThisTurn = true; // Mark that combat occurred this turn

                // Track damage for activity log
                let totalDamageDealtToEnemy = 0;
                let totalDamageDealtToPlayer = 0;
                let damageDealtToEnemy = 0; // Initialize to prevent undefined errors

                if (playerAttacksFirst) {
                    // Player wins initiative and attacks
                    player.thrustAnimActive = true;
                    player.thrustAnimStartTime = performance.now();
                    player.thrustAnimDirectionX = dx;
                    player.thrustAnimDirectionY = dy;
                    const playerCurrentFlow = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0;
                    
                    // New hybrid damage system: base damage from level + small health bonus
                    const levelDamage = Math.max(1, Math.floor(currentLevel / 3)) + 1; // 2-4 at level 1, 4-6 at level 9
                    const healthBonus = Math.floor(player.health / 20); // +1 damage per 20 health
                    const minDamage = levelDamage;
                    const maxDamage = levelDamage + 2 + healthBonus;
                    
                    damageDealtToEnemy = getWeightedRandomInt(minDamage, maxDamage, player.health, attackedEnemy.health, playerCurrentFlow);
                    console.log('Combat: Player attacks enemy -', 'Player health:', player.health, 'Enemy health:', attackedEnemy.health, 'Damage dealt:', damageDealtToEnemy);
                    
                    // Critical Strike chance (10% chance)
                    if (Math.random() < 0.1) {
                        damageDealtToEnemy = Math.floor(damageDealtToEnemy * CRITICAL_STRIKE_DAMAGE_MULTIPLIER);
                        const isMajor = damageDealtToEnemy >= CRITICAL_STRIKE_MAJOR_DAMAGE;
                        const logMessage = `${player.name} dealt ${damageDealtToEnemy} critical damage to ${attackedEnemy.name}`;
                        
                        addEventMessage("Critical Strike!", isMajor, logMessage);
                        eventFlags.criticalStrike = true;
                    } else {
                        eventFlags.criticalStrike = false;
                    }

                    damageDealtToEnemy = Math.min(damageDealtToEnemy, attackedEnemy.health);
                    totalDamageDealtToEnemy = damageDealtToEnemy; // Track for activity log
                    player.thrustAnimMagnitude = Math.min(1, damageDealtToEnemy / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);

                    attackedEnemy.health = attackedEnemy.health - damageDealtToEnemy;
                    attackedEnemy.totalDamageTakenByThisEnemy = (attackedEnemy.totalDamageTakenByThisEnemy || 0) + damageDealtToEnemy;
                    
                    hitsDealt = hitsDealt + 1;
                    totalDamageDealt = totalDamageDealt + damageDealtToEnemy;
                    damageDealtThisTurn = damageDealtThisTurn + damageDealtToEnemy;
                    addDamageAnimation(attackedEnemy.x, attackedEnemy.y, damageDealtToEnemy, VINTAGE_GREEN, dx, dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToEnemy - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));
                    
                    // If enemy survives the player's attack, it counter-attacks
                    if (attackedEnemy.health > 0) {
                        attackedEnemy.thrustAnimActive = true;
                        attackedEnemy.thrustAnimStartTime = performance.now();
                        attackedEnemy.thrustAnimDirectionX = -dx;
                        attackedEnemy.thrustAnimDirectionY = -dy;
                        
                        const enemyCurrentFlow = attackedEnemy.totalDamageTakenByThisEnemy > 0
                            ? attackedEnemy.totalDamageTakenByThisEnemy / (attackedEnemy.stepsTakenByThisEnemy || 1)
                            : attackedEnemy.flowLevel;
                        
                        // Enemy damage should scale with their health, not just level
                        const baseDamage = Math.max(1, Math.floor(attackedEnemy.health / 2)); // 1 damage per 2 health
                        const levelBonus = Math.floor(currentLevel / 4); // Small level bonus
                        const enemyMinDamage = baseDamage;
                        const enemyMaxDamage = baseDamage + 1 + levelBonus;
                        
                        let damageDealtToPlayer = getWeightedRandomInt(enemyMinDamage, enemyMaxDamage, attackedEnemy.health, player.health, enemyCurrentFlow);
                        console.log('Combat: Enemy counter-attacks player -', 'Enemy health:', attackedEnemy.health, 'Player health:', player.health, 'Enemy flow:', enemyCurrentFlow, 'Damage range:', enemyMinDamage, '-', enemyMaxDamage, 'Damage dealt:', damageDealtToPlayer);
                        damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                        totalDamageDealtToPlayer = damageDealtToPlayer; // Track for activity log
                        attackedEnemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                        attackedEnemy.totalDamageDealtByThisEnemy = attackedEnemy.totalDamageDealtByThisEnemy + damageDealtToPlayer;

                        player.health = player.health - damageDealtToPlayer;
                        hitsTaken = hitsTaken + 1;
                        hitsTakenThisTurn = hitsTakenThisTurn + 1;
                        if (damageDealtToPlayer > 0) {
                            playerTookDamageInCombatThisTurn = true;
                        }
                        addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, -dx, -dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));
                    }
                } else {
                    // Enemy wins initiative and attacks
                    attackedEnemy.thrustAnimActive = true;
                    attackedEnemy.thrustAnimStartTime = performance.now();
                    attackedEnemy.thrustAnimDirectionX = -dx;
                    attackedEnemy.thrustAnimDirectionY = -dy;
                    
                    const enemyCurrentFlow = attackedEnemy.totalDamageTakenByThisEnemy > 0
                        ? attackedEnemy.totalDamageTakenByThisEnemy / (attackedEnemy.stepsTakenByThisEnemy || 1)
                        : attackedEnemy.flowLevel;
                    
                    // Enemy damage should scale with their health, not just level
                    const baseDamage = Math.max(1, Math.floor(attackedEnemy.health / 2)); // 1 damage per 2 health
                    const levelBonus = Math.floor(currentLevel / 4); // Small level bonus
                    const enemyMinDamage = baseDamage;
                    const enemyMaxDamage = baseDamage + 1 + levelBonus;
                    
                    let damageDealtToPlayer = getWeightedRandomInt(enemyMinDamage, enemyMaxDamage, attackedEnemy.health, player.health, enemyCurrentFlow);
                    console.log('Combat: Enemy attacks first -', 'Enemy health:', attackedEnemy.health, 'Player health:', player.health, 'Enemy flow:', enemyCurrentFlow, 'Damage range:', enemyMinDamage, '-', enemyMaxDamage, 'Damage dealt:', damageDealtToPlayer);
                    damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                    totalDamageDealtToPlayer = damageDealtToPlayer; // Track for activity log
                    attackedEnemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                    attackedEnemy.totalDamageDealtByThisEnemy = attackedEnemy.totalDamageDealtByThisEnemy + damageDealtToPlayer;

                    player.health = player.health - damageDealtToPlayer;
                    hitsTaken = hitsTaken + 1;
                    hitsTakenThisTurn = hitsTakenThisTurn + 1;
                    if (damageDealtToPlayer > 0) {
                        playerTookDamageInCombatThisTurn = true;
                    }
                    addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, -dx, -dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));
                }

                if (attackedEnemy.health <= 0) {
                    console.log('Enemy died:', attackedEnemy.name, 'Health:', attackedEnemy.health, 'Damage dealt:', damageDealtToEnemy);
                    // Calculate spread factor for explosion based on damage dealt
                    const explosionSpread = ENEMY_DEATH_EXPLOSION_BASE_SPREAD + (damageDealtToEnemy * ENEMY_DEATH_EXPLOSION_DAMAGE_SPREAD_MULTIPLIER);
                    addExplosionAnimation(attackedEnemy.x, attackedEnemy.y, FIXED_COLOR_ENEMY, enemyHealthBeforeHit, undefined, undefined, explosionSpread); // Pass explosionSpread

                    // MODIFIED: "One-Shot Kill" detection - only if enemy went from initial health to 0
                    if (attackedEnemy.initialHealth === enemyHealthBeforeHit && attackedEnemy.health <= 0) {
                        const isMajor = enemyHealthBeforeHit >= ONE_SHOT_MAJOR_HEALTH;
                        const logMessage = `${player.name} eliminated ${attackedEnemy.name} (HP: ${enemyHealthBeforeHit}) in a single devastating strike`;
                        
                        addEventMessage("One-Shot Kill!", isMajor, logMessage);
                        eventFlags.oneShotKill = true;
                    } else {
                        eventFlags.oneShotKill = false;
                    }

                    // Calculate pickup scatter magnitude based on damage dealt
                    const pickupScatterMagnitude = PICKUP_SCATTER_BASE_SPREAD + (damageDealtToEnemy * PICKUP_SCATTER_DAMAGE_MULTIPLIER);

                    // Enemy drops exactly the amount of health it had before the final hit
                    let remainingDroppedHealth = enemyHealthBeforeHit;

                    // Denominations for splitting
                    const denominations = [10, 5, 1]; // Prioritize larger denominations

                    while (remainingDroppedHealth > 0) {
                        const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * pickupScatterMagnitude;
                        const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * pickupScatterMagnitude;

                        let valueToDrop = 0;
                        for (const denom of denominations) {
                            if (remainingDroppedHealth >= denom) {
                                valueToDrop = denom;
                                break;
                            }
                        }
                        if (valueToDrop === 0 && remainingDroppedHealth > 0) {
                            valueToDrop = remainingDroppedHealth; // Drop remaining as a 1 if it's less than smallest denom
                        }

                        if (valueToDrop > 0) {
                            staticDamageNumbers.push({
                                x: attackedEnemy.x,
                                y: attackedEnemy.y,
                                parts: [{ content: { type: 'number', value: valueToDrop }, offsetX: randomOffsetX, offsetY: randomOffsetY }],
                                isEnemyDrop: true
                            });
                            staticCollectionsDirty = true; // Mark cache as needing update
                            remainingDroppedHealth -= valueToDrop;
                        } else {
                            break; // Should not happen if remainingDroppedHealth > 0
                        }
                    }

                    // Add activity log entry for the kill
                    addActivityLogEntry(player, attackedEnemy, totalDamageDealtToEnemy, totalDamageDealtToPlayer);
                    
                    // Track killed enemy for events
                    killedEnemiesThisTurn.push(attackedEnemy.name);
                    
                    enemies.splice(collidedEnemyIndex, 1);
                    enemiesKilledThisTurn = enemiesKilledThisTurn + 1; // Explicit assignment
                }

                // Sanity check for player health after combat
                if (isNaN(player.health)) {
                    console.error("Player health became NaN during combat! Forcing game over.");
                    player.health = 0; // Set to 0 to trigger game over
                }

                if (player.health <= 0) {
                    player.health = 0; // Ensure health doesn't go negative for display
                    handleGameOver();
                }
                // Always return true if combat occurred, regardless of outcome
                return true;
            }

            const obstaclesForPlayer = enemies;
            const playerMoved = moveEntityTowardsTarget(player, newX, newY, obstaclesForPlayer);

            if (playerMoved) {
                stepsTaken = stepsTaken + 1; // Explicit assignment
                // Mark current tile as visited for "Map Explorer"
                if (visitedTiles[player.y] && visitedTiles[player.y][player.x] !== undefined) {
                    visitedTiles[player.y][player.x] = true;
                }
                applyStepBasedHealthLoss();
                checkAndCollectPickups(); // Check for and collect pickups after moving

                if (player.x === stairs.x && player.y === stairs.y) {
                    nextLevel();
                }
                // Enemy turn is now called after player moves, regardless of combat
                enemyTurn();
                return false;
            }
            return false;
        }

        /**
         * Handles enemy turns. Each enemy moves based on its assigned role.
         */
        function enemyTurn() {
            // If game is over, enemies only swarm player remains
            if (gameOver) {
                enemies.forEach(enemy => {
                    const obstaclesForThisEnemy = enemies.filter(e => e !== enemy); // Enemies don't block each other if player is dead

                    // Find the closest player remains pickup
                    updateStaticCollectionsCache(); // Ensure cache is current
                    const closestPlayerRemains = getClosestEntity(cachedPlayerRemains, enemy);

                    if (closestPlayerRemains) {
                        // Move towards the closest player remains
                        const moved = moveEntityTowardsTarget(enemy, closestPlayerRemains.x, closestPlayerRemains.y, obstaclesForThisEnemy, null);

                        // If enemy reached the remains, "eat" them
                        if (moved && enemy.x === closestPlayerRemains.x && enemy.y === closestPlayerRemains.y) {
                            const index = staticDamageNumbers.indexOf(closestPlayerRemains);
                            if (index > -1) {
                                staticDamageNumbers.splice(index, 1);
                                staticCollectionsDirty = true; // Mark cache as needing update
                                console.log(`Enemy ate player remains at (${closestPlayerRemains.x}, ${closestPlayerRemains.y})`);
                                // Increase enemy health by the amount of the eaten remains, only if it's a number
                                if (closestPlayerRemains.parts[0].content.type === 'number') {
                                    enemy.health = enemy.health + closestPlayerRemains.parts[0].content.value; // Explicit assignment
                                }
                            }
                        }
                    } else {
                        // If no more player remains, enemies can just wander or stay put
                        // For now, they'll just stand still if no remains are left.
                        // Could implement a random wander here if desired.
                    }
                });
                checkNotableEvents(); // Check events even if game over, for enemy swarm behavior
                // Reset per-turn stats after checkNotableEvents
                enemiesKilledThisTurn = 0;
                killedEnemiesThisTurn = []; // Reset killed enemies tracking
                damageDealtThisTurn = 0;
                hitsTakenThisTurn = 0;
                totalPickupValueCollectedThisTurn = 0;
                combatOccurredThisTurn = false; // Reset for next turn
                playerTookDamageInCombatThisTurn = false; // Reset for next turn
                return; // Skip normal enemy turn logic if game over
            }

            const HUNTER_MOVE_CHANCE = 0.8;
            const GUARD_PATROL_RADIUS = 5;
            const GUARD_MOVE_CHANCE = 0.5;
            const TRACKER_AGGRO_RADIUS = 8;
            const GLOBAL_STOP_CHANCE = 0.2; // 20% chance for any enemy to stop

            enemies.forEach(enemy => {
                // Apply global random stop chance before any movement logic
                if (Math.random() < GLOBAL_STOP_CHANCE) {
                    // Enemy decided to stop this turn
                    return;
                }

                let enemyAttackedThisTurn = false; // Flag for this enemy's turn

                // Check for unprovoked attack if player is adjacent
                const isPlayerAdjacent = getDistance(enemy, player) <= 1.5; // Manhattan distance of 1 or diagonal
                if (isPlayerAdjacent) {
                    // Use enemy.totalDamageTakenByThisEnemy for enemy flow.
                    // If no damage taken yet, use enemy.flowLevel for initial flow.
                    const enemyCurrentFlow = enemy.totalDamageTakenByThisEnemy > 0
                        ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1)
                        : enemy.flowLevel;
                    const attackChance = Math.min(1.0, Math.max(0.0, enemyCurrentFlow)); // Clamp flow to 0-1 for probability

                    if (Math.random() < attackChance) {
                        // Enemy attacks unprovoked
                        enemy.thrustAnimActive = true;
                        enemy.thrustAnimStartTime = performance.now();
                        let dx = player.x - enemy.x; // Change to let
                        let dy = player.y - enemy.y; // Change to let
                        // Ensure attacks are cardinal only
                        if (Math.abs(dx) > 0 && Math.abs(dy) > 0) { // If diagonal, pick one axis
                            if (Math.random() < 0.5) dy = 0;
                            else dx = 0;
                        }

                        enemy.thrustAnimDirectionX = dx;
                        enemy.thrustAnimDirectionY = dy;

                        // Enemy damage should scale with their health, not just level
                        const baseDamage = Math.max(1, Math.floor(enemy.health / 2)); // 1 damage per 2 health
                        const levelBonus = Math.floor(currentLevel / 4); // Small level bonus
                        const enemyMinDamage = baseDamage;
                        const enemyMaxDamage = baseDamage + 1 + levelBonus;

                        let damageDealtToPlayer = getWeightedRandomInt(enemyMinDamage, enemyMaxDamage, enemy.health, player.health, enemyCurrentFlow);
                        console.log('Combat: Enemy unprovoked attack -', 'Enemy health:', enemy.health, 'Player health:', player.health, 'Enemy flow:', enemyCurrentFlow, 'Attack chance:', attackChance, 'Damage range:', enemyMinDamage, '-', enemyMaxDamage, 'Damage dealt:', damageDealtToPlayer);
                        damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                        enemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                        enemy.totalDamageDealtByThisEnemy = enemy.totalDamageDealtByThisEnemy + damageDealtToPlayer; // Explicit assignment

                        player.health = player.health - damageDealtToPlayer; // Explicit assignment
                        hitsTaken = hitsTaken + 1; // Explicit assignment
                        hitsTakenThisTurn = hitsTakenThisTurn + 1; // Explicit assignment
                        if (damageDealtToPlayer > 0) {
                            playerTookDamageInCombatThisTurn = true; // Player took damage in combat
                        }
                        addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, dx, dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));

                        // Sanity check for player health after combat
                        if (isNaN(player.health)) {
                            console.error("Player health became NaN during enemy unprovoked attack! Forcing game over.");
                            player.health = 0;
                        }
                        if (player.health <= 0) {
                            player.health = 0;
                            handleGameOver();
                            return; // Stop further enemy turns if game over
                        }
                        enemyAttackedThisTurn = true;
                    }
                }

                if (!enemyAttackedThisTurn) { // Only move if no unprovoked attack occurred
                    const obstaclesForThisEnemy = enemies.filter(e => e !== enemy).concat(player);
                    let moved = false; // Flag to track if enemy successfully moved

                    // New: Check enemy's flowLevel for following chance
                    // MODIFIED: Enemy flow is now based on totalDamageTakenByThisEnemy
                    if (Math.random() < (enemy.totalDamageTakenByThisEnemy > 0 ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1) : 0)) { // If random number is less than flowLevel, enemy follows
                        moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                    } else { // Otherwise, enemy performs its role-based movement
                        if (enemy.role === 'hunter') {
                            // Hunters always try to move towards the player if not following by flow
                            moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                        } else if (enemy.role === 'guard') {
                            if (stairs && stairs.x !== undefined && stairs.y !== undefined) {
                                const distToStairs = getDistance(enemy, stairs);

                                if (distToStairs > GUARD_PATROL_RADIUS) {
                                    moved = moveEntityTowardsTarget(enemy, stairs.x, stairs.y, obstaclesForThisEnemy, stairs);
                                } else {
                                    if (Math.random() < GUARD_MOVE_CHANCE) { // Guard-specific stop chance
                                        // Only cardinal directions for guard's random movement
                                        const cardinalDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                                        let bestMove = null;
                                        let minCombinedDistance = Infinity;

                                        for (const [dx, dy] of cardinalDirections) { // Iterate over cardinal directions
                                            const newX = enemy.x + dx;
                                            const newY = enemy.y + dy;

                                            if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                                                gameMap[newY][newX] === TILE_FLOOR && // Only move onto floor tiles
                                                !(newX === player.x && newY === player.y) &&
                                                !obstaclesForThisEnemy.some(o => o.x === newX && o.y === newY) &&
                                                (stairs && stairs.x !== undefined && stairs.y !== undefined && (newX !== stairs.x || newY !== stairs.y)) && // Explicitly avoid stairs
                                                (stairs && stairs.x !== undefined && stairs.y !== undefined && getDistance({x: newX, y: newY}, stairs) <= GUARD_PATROL_RADIUS + 1)) {

                                                const distToPlayer = getDistance({x: newX, y: newY}, player);
                                                const distToStairsFromNewPos = getDistance({x: newX, y: newY}, stairs);

                                                const combinedDistance = distToPlayer + distToStairsFromNewPos;

                                                if (combinedDistance < minCombinedDistance) {
                                                    minCombinedDistance = combinedDistance;
                                                    bestMove = {x: newX, y: newY};
                                                }
                                            }
                                        }

                                        if (bestMove) {
                                            enemy.x = bestMove.x;
                                            enemy.y = bestMove.y;
                                            moved = true; // Mark as moved
                                        }
                                    }
                                }
                            } else {
                                moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                            }
                        } else if (enemy.role === 'tracker') {
                            const distToPlayer = getDistance(enemy, player);
                            if (distToPlayer <= TRACKER_AGGRO_RADIUS) {
                                moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                            } else {
                                if (stairs && stairs.x !== undefined && stairs.y !== undefined) {
                                    moved = moveEntityTowardsTarget(enemy, stairs.x, stairs.y, obstaclesForThisEnemy, stairs);
                                } else {
                                    moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                                }
                            }
                        }
                    }
                }
            });

            checkNotableEvents(); // Check events after all entities have moved
            // Reset per-turn stats
            enemiesKilledThisTurn = 0;
            killedEnemiesThisTurn = []; // Reset killed enemies tracking
            damageDealtThisTurn = 0;
            hitsTakenThisTurn = 0;
            combatOccurredThisTurn = false; // Reset for next turn
            playerTookDamageInCombatThisTurn = false; // Reset for next turn
            totalPickupValueCollectedThisTurn = 0;
        }

        /**
         * Adds an event message to be displayed on screen.
         * @param {string} text - The text of the event message.
         * @param {boolean} isMajor - Whether this is a major event that should be logged.
         * @param {string} logMessage - Detailed message for the activity log (if major).
         */
        function addEventMessage(text, isMajor = false, logMessage = null) {
            // Only add if not already active or recently shown (simple check for now)
            // Could add more sophisticated cooldowns per event type if needed
            if (!activeEventMessages.some(msg => msg.text === text)) {
                activeEventMessages.push({
                    text: text,
                    startTime: performance.now(),
                    duration: EVENT_TEXT_DURATION
                });
                
                // Add major events to the message area like kill messages
                if (isMajor && logMessage) {
                    addMajorEventMessage(logMessage);
                } else {
                    // Regular events still appear briefly as event titles
                    addPlayerDialogue(text);
                }
            }
        }

        /**
         * Adds a major event message with popup styling.
         * @param {string} message - The detailed message to display.
         */
        function addMajorEventMessage(message) {
            showPopupMessage(message, player.x, player.y, 'progress');
        }

        /**
         * Toggles a message filter and updates the UI
         * @param {string} type - The message type to toggle
         */
        function toggleMessageFilter(type) {
            MESSAGE_TYPES[type].enabled = !MESSAGE_TYPES[type].enabled;
            saveMessagePreferences();
            updateFilterUI();
            filterMessages();
        }

        /**
         * Updates the filter button UI to reflect current state
         */
        function updateFilterUI() {
            Object.keys(MESSAGE_TYPES).forEach(type => {
                const btn = document.getElementById(`filter${type.charAt(0) + type.slice(1).toLowerCase()}`);
                if (btn) {
                    if (MESSAGE_TYPES[type].enabled) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });
        }

        /**
         * Filters visible messages based on current filter settings
         */
        function filterMessages() {
            const messages = Array.from(messageArea.children).filter(child => 
                child.classList.contains('kill-message')
            );
            
            messages.forEach(message => {
                const messageType = message.dataset.messageType;
                if (messageType && MESSAGE_TYPES[messageType]) {
                    message.style.display = MESSAGE_TYPES[messageType].enabled ? 'flex' : 'none';
                }
            });
        }

        /**
         * Initializes the message filter system
         */
        function initializeMessageFilters() {
            loadMessagePreferences();
            
            // Set up filter button event listeners
            Object.keys(MESSAGE_TYPES).forEach(type => {
                const btnId = `filter${type.charAt(0) + type.slice(1).toLowerCase()}`;
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.addEventListener('click', () => toggleMessageFilter(type));
                }
            });
            
            updateFilterUI();
        }

        /**
         * Helper functions for specific message types
         */
        function addCombatMessage(message, priority = 'normal') {
            showPopupMessage(message, player.x, player.y, 'combat');
        }

        function addEventMessage(message, priority = 'high') {
            // Convert to popup message instead of using old message area
            let popupType = 'event';
            
            // Determine popup type based on content
            if (message.includes('💀') || message.includes('died') || message.includes('destroyed') || message.includes('Critical Strike') || message.includes('One-Shot')) {
                popupType = 'combat';
            } else if (message.includes('💊') || message.includes('health') || message.includes('pickup')) {
                popupType = 'pickup';
            } else if (message.includes('🏆') || message.includes('Level') || message.includes('World') || message.includes('floor')) {
                popupType = 'progress';
            }
            
            showPopupMessage(message, player.x, player.y, popupType);
        }

        function addPickupMessage(message, priority = 'normal') {
            showPopupMessage(message, player.x, player.y, 'pickup');
        }

        function addProgressMessage(message, priority = 'high') {
            showPopupMessage(message, player.x, player.y, 'progress');
        }

        /**
         * Adds a new line of player dialogue to the dialogue area.
         * Function removed temporarily
         */
        function addPlayerDialogue(statusText) {
            // Dialogue system temporarily removed
            return;
        }

        /**
         * Counts the number of visited tiles in the `visitedTiles` grid.
         * @returns {number} The count of visited tiles.
         */
        function countVisitedTiles() {
            let count = 0;
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (visitedTiles[y] && visitedTiles[y][x]) {
                        count++;
                    }
                }
            }
            return count;
        }

        /**
         * Checks for notable game events based on current state and history.
         */
        function checkNotableEvents() {
            // 1. Store current state in history
            updateStaticCollectionsCache(); // Ensure cache is current
            gameHistory.push({
                stepsTaken: stepsTaken,
                playerHealth: player.health,
                enemiesCount: enemies.length,
                hitsTaken: hitsTaken,
                totalDamageDealt: totalDamageDealt,
                playerX: player.x,
                playerY: player.y,
                enemiesPositions: enemies.map(e => ({ x: e.x, y: e.y, health: e.health, name: e.name })),
                pickupsOnMap: cachedPickups.map(p => ({ x: p.x, y: p.y, value: p.parts[0].content.value })),
                enemiesKilledThisTurn: enemiesKilledThisTurn,
                killedEnemyNames: [...killedEnemiesThisTurn],
                damageDealtThisTurn: damageDealtThisTurn,
                hitsTakenThisTurn: hitsTakenThisTurn,
                totalPickupValueCollectedThisTurn: totalPickupValueCollectedThisTurn,
                visitedTilesCount: countVisitedTiles(),
                combatOccurredThisTurn: combatOccurredThisTurn,
                playerTookDamageInCombatThisTurn: playerTookDamageInCombatThisTurn,
                currentLevel: currentLevel,
                playerFlow: stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0
            });

            if (gameHistory.length > HISTORY_LENGTH) {
                gameHistory.shift();
            }

            const currentTurn = gameHistory[gameHistory.length - 1];
            const previousTurn = gameHistory.length > 1 ? gameHistory[gameHistory.length - 2] : null;

            // === COMBAT EVENTS - OFFENSIVE ===
            
            // Massacre Event
            let enemiesKilledRecently = 0;
            for (let i = Math.max(0, gameHistory.length - 5); i < gameHistory.length; i++) {
                enemiesKilledRecently += gameHistory[i].enemiesKilledThisTurn || 0;
            }
            if (enemiesKilledRecently >= MASSACRE_COUNT && !eventFlags.massacre) {
                const isMajor = true;
                const logMessage = `${player.name} has achieved a MASSACRE, eliminating ${enemiesKilledRecently} enemies in rapid succession!`;
                addEventMessage("Massacre", isMajor, logMessage);
                eventFlags.massacre = true;
            } else if (enemiesKilledRecently < MASSACRE_COUNT) {
                eventFlags.massacre = false;
            }

            // Berserker Mode
            let recentDamage = 0;
            for (let i = Math.max(0, gameHistory.length - BERSERKER_TURNS); i < gameHistory.length; i++) {
                recentDamage += gameHistory[i].damageDealtThisTurn || 0;
            }
            if (recentDamage >= BERSERKER_DAMAGE_THRESHOLD && !eventFlags.berserkerMode) {
                const isMajor = recentDamage >= BERSERKER_DAMAGE_THRESHOLD * 1.5;
                const logMessage = `${player.name} enters BERSERKER MODE, dealing ${recentDamage} damage in ${BERSERKER_TURNS} turns!`;
                addEventMessage("Berserker Mode", isMajor, logMessage);
                eventFlags.berserkerMode = true;
            } else if (recentDamage < BERSERKER_DAMAGE_THRESHOLD) {
                eventFlags.berserkerMode = false;
            }

            // Glass Cannon
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.3 && 
                damageDealtThisTurn >= player.health * GLASS_CANNON_DAMAGE_RATIO && 
                !eventFlags.glassCannon) {
                const isMajor = damageDealtThisTurn >= player.health * GLASS_CANNON_DAMAGE_RATIO * 1.5;
                const logMessage = `${player.name} demonstrates GLASS CANNON tactics, dealing ${damageDealtThisTurn} damage while having only ${player.health} health!`;
                addEventMessage("Glass Cannon", isMajor, logMessage);
                eventFlags.glassCannon = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * 0.3 || damageDealtThisTurn < player.health * GLASS_CANNON_DAMAGE_RATIO) {
                eventFlags.glassCannon = false;
            }

            // Headhunter
            const highValueEnemiesKilled = killedEnemiesThisTurn.filter(name => {
                const enemy = gameHistory.length > 1 ? 
                    gameHistory[gameHistory.length - 2].enemiesPositions.find(e => e.name === name) : null;
                return enemy && enemy.health >= HEADHUNTER_HIGH_VALUE_ENEMY;
            });
            if (highValueEnemiesKilled.length > 0 && !eventFlags.headhunter) {
                const isMajor = highValueEnemiesKilled.length > 1;
                const targets = highValueEnemiesKilled.join(', ');
                const logMessage = `${player.name} is a HEADHUNTER, taking down high-value targets: ${targets}`;
                addEventMessage("Headhunter", isMajor, logMessage);
                eventFlags.headhunter = true;
            } else if (highValueEnemiesKilled.length === 0) {
                eventFlags.headhunter = false;
            }

            // === COMBAT EVENTS - DEFENSIVE ===

            // Last Stand
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * LAST_STAND_HEALTH_RATIO && 
                enemies.length >= 2 && damageDealtThisTurn > 0 && !eventFlags.lastStand) {
                const isMajor = enemies.length >= 3;
                const logMessage = `${player.name} makes a LAST STAND with ${player.health} health against ${enemies.length} enemies!`;
                addEventMessage("Last Stand", isMajor, logMessage);
                eventFlags.lastStand = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * LAST_STAND_HEALTH_RATIO) {
                eventFlags.lastStand = false;
            }

            // Narrow Escape
            if (previousTurn && previousTurn.playerHealth <= PLAYER_VISUAL_HEALTH_THRESHOLD * NARROW_ESCAPE_HEALTH_RATIO && 
                player.health > previousTurn.playerHealth && !eventFlags.narrowEscape) {
                const isMajor = previousTurn.playerHealth <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.03;
                const logMessage = `${player.name} had a NARROW ESCAPE, surviving with only ${previousTurn.playerHealth} health!`;
                addEventMessage("Narrow Escape", isMajor, logMessage);
                eventFlags.narrowEscape = true;
            } else if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * NARROW_ESCAPE_HEALTH_RATIO) {
                eventFlags.narrowEscape = false;
            }

            // Damage Sponge
            let recentDamageAbsorbed = 0;
            for (let i = Math.max(0, gameHistory.length - 5); i < gameHistory.length; i++) {
                recentDamageAbsorbed += gameHistory[i].hitsTakenThisTurn || 0;
            }
            if (recentDamageAbsorbed >= DAMAGE_SPONGE_THRESHOLD && player.health > 0 && !eventFlags.damageSponge) {
                const isMajor = recentDamageAbsorbed >= DAMAGE_SPONGE_THRESHOLD * 1.5;
                const logMessage = `${player.name} is a DAMAGE SPONGE, absorbing ${recentDamageAbsorbed} damage while staying alive!`;
                addEventMessage("Damage Sponge", isMajor, logMessage);
                eventFlags.damageSponge = true;
            } else if (recentDamageAbsorbed < DAMAGE_SPONGE_THRESHOLD) {
                eventFlags.damageSponge = false;
            }

            // Iron Will
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * IRON_WILL_LOW_HEALTH_COMBAT && 
                combatOccurredThisTurn && !playerTookDamageInCombatThisTurn && !eventFlags.ironWill) {
                const isMajor = player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.1;
                const logMessage = `${player.name} shows IRON WILL, fighting at ${player.health} health without taking damage!`;
                addEventMessage("Iron Will", isMajor, logMessage);
                eventFlags.ironWill = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * IRON_WILL_LOW_HEALTH_COMBAT || playerTookDamageInCombatThisTurn) {
                eventFlags.ironWill = false;
            }

            // === TACTICAL EVENTS ===

            // Tactical Advance
            if (previousTurn && enemies.length > 0) {
                const closestEnemyBefore = getClosestEntity(previousTurn.enemiesPositions, {x: previousTurn.playerX, y: previousTurn.playerY});
                const closestEnemyNow = getClosestEntity(enemies, player);
                if (closestEnemyBefore && closestEnemyNow) {
                    const distBefore = getDistance({x: previousTurn.playerX, y: previousTurn.playerY}, closestEnemyBefore);
                    const distNow = getDistance(player, closestEnemyNow);
                    if (distBefore - distNow >= TACTICAL_ADVANCE_DISTANCE && damageDealtThisTurn > 0 && !eventFlags.tacticalAdvance) {
                        const isMajor = distBefore - distNow >= TACTICAL_ADVANCE_DISTANCE * 1.5;
                        const logMessage = `${player.name} executes TACTICAL ADVANCE, closing ${distBefore - distNow} tiles and dealing ${damageDealtThisTurn} damage!`;
                        addEventMessage("Tactical Advance", isMajor, logMessage);
                        eventFlags.tacticalAdvance = true;
                    } else if (distBefore - distNow < TACTICAL_ADVANCE_DISTANCE) {
                        eventFlags.tacticalAdvance = false;
                    }
                }
            }

            // Guerrilla Warfare
            let hitAndRunCount = 0;
            for (let i = Math.max(0, gameHistory.length - GUERRILLA_HIT_AND_RUN); i < gameHistory.length; i++) {
                if (gameHistory[i].damageDealtThisTurn > 0 && gameHistory[i].hitsTakenThisTurn === 0) {
                    hitAndRunCount++;
                }
            }
            if (hitAndRunCount >= GUERRILLA_HIT_AND_RUN && !eventFlags.guerrillaWarfare) {
                const isMajor = hitAndRunCount >= GUERRILLA_HIT_AND_RUN + 2;
                const logMessage = `${player.name} employs GUERRILLA WARFARE, ${hitAndRunCount} consecutive hit-and-run attacks!`;
                addEventMessage("Guerrilla Warfare", isMajor, logMessage);
                eventFlags.guerrillaWarfare = true;
            } else if (hitAndRunCount < GUERRILLA_HIT_AND_RUN) {
                eventFlags.guerrillaWarfare = false;
            }

            // === RESOURCE MANAGEMENT ===

            // Greedy Collector
            updateStaticCollectionsCache(); // Ensure cache is current
            const totalPickupsAvailable = cachedPickups.length;
            const pickupEfficiency = totalPickupsAvailable > 0 ? 
                (totalPickupValueCollectedThisTurn / totalPickupsAvailable) : 0;
            if (pickupEfficiency >= GREEDY_COLLECTOR_RATIO && totalPickupValueCollectedThisTurn > 0 && !eventFlags.greedyCollector) {
                const isMajor = pickupEfficiency >= 1.0;
                const logMessage = `${player.name} is a GREEDY COLLECTOR, gathering ${totalPickupValueCollectedThisTurn} resources with ${Math.round(pickupEfficiency * 100)}% efficiency!`;
                addEventMessage("Greedy Collector", isMajor, logMessage);
                eventFlags.greedyCollector = true;
            } else if (pickupEfficiency < GREEDY_COLLECTOR_RATIO) {
                eventFlags.greedyCollector = false;
            }

            // Resource Hoarder
            let totalResourcesHoarded = 0;
            for (let i = Math.max(0, gameHistory.length - 10); i < gameHistory.length; i++) {
                totalResourcesHoarded += gameHistory[i].totalPickupValueCollectedThisTurn || 0;
            }
            if (totalResourcesHoarded >= RESOURCE_HOARDER_COUNT && !eventFlags.resourceHoarder) {
                const isMajor = totalResourcesHoarded >= RESOURCE_HOARDER_COUNT * 2;
                const logMessage = `${player.name} is a RESOURCE HOARDER, collecting ${totalResourcesHoarded} total resources recently!`;
                addEventMessage("Resource Hoarder", isMajor, logMessage);
                eventFlags.resourceHoarder = true;
            } else if (totalResourcesHoarded < RESOURCE_HOARDER_COUNT) {
                eventFlags.resourceHoarder = false;
            }

            // === EXPLORATION EVENTS ===

            // Speed Runner
            const levelCompletionRatio = enemies.length === 0 ? 1.0 : (currentTurn.enemiesCount === 0 ? 1.0 : 0);
            if (levelCompletionRatio >= SPEED_RUNNER_PERCENTAGE && stepsTaken <= SPEEDSTER_TURN_LIMIT && !eventFlags.speedRunner) {
                const isMajor = stepsTaken <= SPEEDSTER_TURN_LIMIT * 0.7;
                const logMessage = `${player.name} is a SPEED RUNNER, completing level in ${stepsTaken} turns!`;
                addEventMessage("Speed Runner", isMajor, logMessage);
                eventFlags.speedRunner = true;
            }

            // Cartographer
            const mapCoverage = countVisitedTiles() / (dynamicMapWidth * dynamicMapHeight);
            if (mapCoverage >= CARTOGRAPHER_MAP_COVERAGE && !eventFlags.cartographer) {
                const isMajor = mapCoverage >= 0.98;
                const logMessage = `${player.name} is a CARTOGRAPHER, mapping ${Math.round(mapCoverage * 100)}% of the area!`;
                addEventMessage("Cartographer", isMajor, logMessage);
                eventFlags.cartographer = true;
            } else if (mapCoverage < CARTOGRAPHER_MAP_COVERAGE) {
                eventFlags.cartographer = false;
            }

            // === HEALTH & RECOVERY ===

            // Regeneration
            if (previousTurn && player.health - previousTurn.playerHealth >= REGENERATION_HEALTH_GAIN && !eventFlags.regeneration) {
                const isMajor = player.health - previousTurn.playerHealth >= REGENERATION_HEALTH_GAIN * 1.5;
                const healthGained = player.health - previousTurn.playerHealth;
                const logMessage = `${player.name} shows REGENERATION, gaining ${healthGained} health in one turn!`;
                addEventMessage("Regeneration", isMajor, logMessage);
                eventFlags.regeneration = true;
            } else if (!previousTurn || player.health - previousTurn.playerHealth < REGENERATION_HEALTH_GAIN) {
                eventFlags.regeneration = false;
            }

            // Vitality
            if (player.health >= PLAYER_VISUAL_HEALTH_THRESHOLD * VITALITY_HIGH_HEALTH_COMBAT && 
                combatOccurredThisTurn && damageDealtThisTurn > 0 && !eventFlags.vitality) {
                const isMajor = player.health >= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.9;
                const logMessage = `${player.name} demonstrates VITALITY, fighting at ${player.health} health and dealing ${damageDealtThisTurn} damage!`;
                addEventMessage("Vitality", isMajor, logMessage);
                eventFlags.vitality = true;
            } else if (player.health < PLAYER_VISUAL_HEALTH_THRESHOLD * VITALITY_HIGH_HEALTH_COMBAT || !combatOccurredThisTurn) {
                eventFlags.vitality = false;
            }

            // === PSYCHOLOGICAL EVENTS ===

            // Confidence
            const currentFlow = currentTurn.playerFlow;
            if (currentFlow >= CONFIDENCE_HIGH_FLOW && player.health >= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.6 && !eventFlags.confidence) {
                const isMajor = currentFlow >= CONFIDENCE_HIGH_FLOW * 1.5;
                const logMessage = `${player.name} radiates CONFIDENCE with ${currentFlow.toFixed(2)} flow and ${player.health} health!`;
                addEventMessage("Confidence", isMajor, logMessage);
                eventFlags.confidence = true;
            } else if (currentFlow < CONFIDENCE_HIGH_FLOW || player.health < PLAYER_VISUAL_HEALTH_THRESHOLD * 0.6) {
                eventFlags.confidence = false;
            }

            // Desperation
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * DESPERATION_LOW_HEALTH && 
                enemies.length >= 2 && !eventFlags.desperation) {
                const isMajor = player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.05;
                const logMessage = `${player.name} fights with DESPERATION, ${player.health} health against ${enemies.length} enemies!`;
                addEventMessage("Desperation", isMajor, logMessage);
                eventFlags.desperation = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * DESPERATION_LOW_HEALTH || enemies.length < 2) {
                eventFlags.desperation = false;
            }

            // === ACHIEVEMENT EVENTS ===

            // First Blood (only triggers on level 1)
            if (currentLevel === FIRST_BLOOD_LEVEL && enemiesKilledThisTurn > 0 && !eventFlags.firstBlood) {
                const isMajor = false;
                const logMessage = `${player.name} draws FIRST BLOOD in the division!`;
                addEventMessage("First Blood", isMajor, logMessage);
                eventFlags.firstBlood = true;
            }

            // Perfectionist
            if (enemies.length === 0 && hitsTaken === 0 && stepsTaken > 5 && !eventFlags.perfectionist) {
                const isMajor = true;
                const logMessage = `${player.name} achieves PERFECTIONIST status, completing level without taking damage!`;
                addEventMessage("Perfectionist", isMajor, logMessage);
                eventFlags.perfectionist = true;
            }

            // === LEGACY EVENTS (Updated) ===
            
            // Player Surrounded
            let adjacentEnemiesCount = 0;
            let adjacentEnemies = [];
            const eightDirections = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dx, dy] of eightDirections) {
                const checkX = player.x + dx;
                const checkY = player.y + dy;
                const adjacentEnemy = enemies.find(e => e.x === checkX && e.y === checkY);
                if (adjacentEnemy) {
                    adjacentEnemiesCount++;
                    adjacentEnemies.push(adjacentEnemy);
                }
            }
            if (adjacentEnemiesCount >= SURROUNDED_THRESHOLD && !eventFlags.playerSurrounded) {
                const isMajor = adjacentEnemiesCount >= SURROUNDED_MAJOR_THRESHOLD;
                const enemyNames = adjacentEnemies.map(e => e.name).join(', ');
                const logMessage = `${player.name} is SURROUNDED by ${enemyNames} (${adjacentEnemiesCount} enemies)`;
                addEventMessage("Player Surrounded", isMajor, logMessage);
                eventFlags.playerSurrounded = true;
            } else if (adjacentEnemiesCount < SURROUNDED_THRESHOLD) {
                eventFlags.playerSurrounded = false;
            }

            // Near-Death Recovery
            const wasLowHealthThreshold = PLAYER_VISUAL_HEALTH_THRESHOLD * NEAR_DEATH_HEALTH_RATIO;
            const recoveryThreshold = PLAYER_VISUAL_HEALTH_THRESHOLD * RECOVERY_HEALTH_GAIN_RATIO;

            if (player.health <= wasLowHealthThreshold && !player.wasLowHealth) {
                player.wasLowHealth = true;
                player.lowestHealthReached = player.health;
            } else if (player.wasLowHealth && player.health >= player.lowestHealthReached + recoveryThreshold) {
                if (!eventFlags.nearDeathRecovery) {
                    const isMajor = player.lowestHealthReached <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.1;
                    const logMessage = `${player.name} makes NEAR-DEATH RECOVERY from ${player.lowestHealthReached} to ${player.health} health!`;
                    addEventMessage("Near-Death Recovery", isMajor, logMessage);
                    eventFlags.nearDeathRecovery = true;
                }
                player.wasLowHealth = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
            } else if (player.health > wasLowHealthThreshold && player.wasLowHealth && player.health < player.lowestHealthReached + recoveryThreshold) {
                player.wasLowHealth = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
                eventFlags.nearDeathRecovery = false;
            } else if (player.health > wasLowHealthThreshold && !player.wasLowHealth) {
                eventFlags.nearDeathRecovery = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
            }

            // Killing Spree (Updated)
            if (enemiesKilledRecently >= KILLING_SPREE_COUNT && !eventFlags.killingSpree) {
                const isMajor = enemiesKilledRecently >= KILLING_SPREE_MAJOR_COUNT;
                let recentKilledEnemies = [];
                for (let i = Math.max(0, gameHistory.length - KILLING_SPREE_COUNT); i < gameHistory.length; i++) {
                    if (gameHistory[i].killedEnemyNames) {
                        recentKilledEnemies = recentKilledEnemies.concat(gameHistory[i].killedEnemyNames);
                    }
                }
                const killedNames = recentKilledEnemies.length > 0 ? recentKilledEnemies.join(', ') : 'multiple enemies';
                const logMessage = `${player.name} goes on KILLING SPREE, eliminating ${enemiesKilledRecently} enemies: ${killedNames}`;
                addEventMessage("Killing Spree", isMajor, logMessage);
                eventFlags.killingSpree = true;
            } else if (enemiesKilledRecently < KILLING_SPREE_COUNT) {
                eventFlags.killingSpree = false;
            }

            // Other legacy events with similar updates...
            // (Continuing with existing logic but enhanced logging)

            // NEW: 13. "Perfect Dodge"
            // Only check if combat occurred this turn and player took no damage from combat
            if (currentTurn.combatOccurredThisTurn && !currentTurn.playerTookDamageInCombatThisTurn && !eventFlags.perfectDodge) {
                addEventMessage("Perfect Dodge!");
                eventFlags.perfectDodge = true;
            } else if (!currentTurn.combatOccurredThisTurn || currentTurn.playerTookDamageInCombatThisTurn) {
                eventFlags.perfectDodge = false;
            }

            // NEW: 14. "Critical Strike!" - This is handled directly in movePlayer.

            // NEW: 15. "Flawless Victory" (for a level)
            // This needs to be checked when advancing to the next level, not every turn.
            // We'll add a check in `nextLevel()` or `initGame()` when `resetGameStats` is false.
        }

        /**
         * Advances the player to the next level.
         */
        function nextLevel() {
            // Check for "Flawless Victory" before resetting stats for the new level
            const previousLevelState = gameHistory.find(state => state.currentLevel === currentLevel); // Find state from the start of this level
            let totalDamageTakenThisLevel = 0;
            if (previousLevelState) {
                totalDamageTakenThisLevel = hitsTaken - previousLevelState.hitsTaken;
            }
            if (totalDamageTakenThisLevel === 0 && !eventFlags.flawlessVictory) {
                addProgressMessage("🏅 Flawless Victory! 🏅", 'high');
                eventFlags.flawlessVictory = true;
            } else {
                eventFlags.flawlessVictory = false;
            }

            // Preserve auto mode across level transitions
            const previousAutoMode = autoMode;

            // Check for world progression (need points = level * 10)
            const currentScore = stepsTaken > 0 ? Math.floor(totalDamageDealt * (totalDamageDealt / stepsTaken)) : 0;
            const pointsNeededForNextWorld = (currentLevel + 1) * 10;
            
            // Check if we should advance to next world
            if (currentScore >= pointsNeededForNextWorld && WORLDS[currentWorld + 1] && !unlockedWorlds.includes(currentWorld + 1)) {
                currentWorld = currentWorld + 1;
                unlockedWorlds.push(currentWorld);
                console.log(`Advanced to World ${currentWorld}: ${getCurrentWorld().name}!`);
                addProgressMessage(`🌍 ENTERED ${getCurrentWorld().name.toUpperCase()}! 🌍`, 'high');
            }

            currentLevel = currentLevel + 1; // Explicit assignment
            
            // Add level progression message
            addProgressMessage(`🏆 LEVEL ${currentLevel} REACHED! 🏆`, 'high');
            
            initGame(false); // No overlay when progressing levels

            // Restart auto mode if it was active
            if (previousAutoMode) {
                autoMode = previousAutoMode;
                startAutomatedMovement();
            }
        }

        /**
         * Stops all automated movement (A mode).
         */
        function stopAutomatedMovement() {
            if (autoMoveTimeoutId) {
                clearTimeout(autoMoveTimeoutId);
                autoMoveTimeoutId = null;
            }
            autoMode = null;
            autoMovePath = [];
            currentPathIndex = 0;
        }

        /**
         * Finds the closest entity from a list to the player, optionally within a radius.
         * @param {object[]} entities - The list of entities ({x, y}).
         * @param {object} playerPos - The player's current position {x, y}.
         * @param {number} radius - Optional maximum distance to consider. Defaults to Infinity.
         * @returns {object|null} The closest entity, or null if none found within radius.
         */
        function getClosestEntity(entities, playerPos, radius = Infinity) {
            if (!entities || entities.length === 0) return null;
            
            // Use spatial indexing for large entity counts
            if (entities.length > 10 && radius < Infinity) {
                const nearbyEntities = getEntitiesInRadius(playerPos.x, playerPos.y, radius);
                entities = nearbyEntities.length > 0 ? nearbyEntities : entities.slice(0, 20); // Limit search
            }
            
            let closest = null;
            let minDistSquared = radius * radius;
            
            // Use squared distance to avoid expensive sqrt calculations
            for (let i = 0; i < entities.length; i++) {
                const entity = entities[i];
                if (!entity || typeof entity.x !== 'number' || typeof entity.y !== 'number') continue;
                
                const dx = playerPos.x - entity.x;
                const dy = playerPos.y - entity.y;
                const distSquared = dx * dx + dy * dy;
                
                if (distSquared < minDistSquared) {
                    minDistSquared = distSquared;
                    closest = entity;
                }
            }
            
            return closest;
        }

        /**
         * Optimized entity collision and proximity calculations using spatial indexing
         */
        function rebuildSpatialIndex() {
            spatialIndex.clear();
            
            // Use for loops instead of forEach for better performance
            for (let i = 0; i < enemies.length; i++) {
                addToSpatialIndex(enemies[i], 'enemy', i);
            }
            
            // Index pickups 
            updateStaticCollectionsCache(); // Ensure cache is current
            const activePickups = cachedPickups;
            for (let i = 0; i < activePickups.length; i++) {
                addToSpatialIndex(activePickups[i], 'pickup', i);
            }
            
            // Index player
            if (player.x !== undefined && player.y !== undefined) {
                addToSpatialIndex(player, 'player', 0);
            }
            
            spatialIndexValid = true;
        }

        function addToSpatialIndex(entity, type, index) {
            if (!entity || entity.x === undefined || entity.y === undefined) return;
            
            const gridX = Math.floor(entity.x / spatialGridSize);
            const gridY = Math.floor(entity.y / spatialGridSize);
            const key = `${gridX},${gridY}`;
            
            if (!spatialIndex.has(key)) {
                spatialIndex.set(key, []);
            }
            
            spatialIndex.get(key).push({ entity, type, index });
        }

        /**
         * Optimized entity search using spatial index
         */
        function getEntitiesInRadius(centerX, centerY, radius, entityType = null) {
            if (!spatialIndexValid) rebuildSpatialIndex();
            
            const results = [];
            const radiusSquared = radius * radius;
            
            // Calculate grid bounds to check
            const minGridX = Math.floor((centerX - radius) / spatialGridSize);
            const maxGridX = Math.floor((centerX + radius) / spatialGridSize);
            const minGridY = Math.floor((centerY - radius) / spatialGridSize);
            const maxGridY = Math.floor((centerY + radius) / spatialGridSize);
            
            for (let gx = minGridX; gx <= maxGridX; gx++) {
                for (let gy = minGridY; gy <= maxGridY; gy++) {
                    const key = `${gx},${gy}`;
                    const gridEntities = spatialIndex.get(key);
                    
                    if (gridEntities) {
                        for (let i = 0; i < gridEntities.length; i++) {
                            const { entity, type } = gridEntities[i];
                            if (entityType && type !== entityType) continue;
                            
                            const dx = entity.x - centerX;
                            const dy = entity.y - centerY;
                            const distSquared = dx * dx + dy * dy;
                            
                            if (distSquared <= radiusSquared) {
                                results.push(entity);
                            }
                        }
                    }
                }
            }
            
            return results;
        }
        function startAutomatedMovement() {
            console.log('startAutomatedMovement called, autoMode:', autoMode);
            if (gameOver) {
                console.log('Game over, stopping auto movement');
                stopAutomatedMovement();
                return;
            }
            if (autoMode === null) {
                console.log('autoMode is null, returning');
                return;
            }

            // Set standard speed for auto mode
            AUTO_MOVE_SPEED = DEFAULT_AUTO_MOVE_SPEED;

            if (autoMoveTimeoutId) {
                clearTimeout(autoMoveTimeoutId);
                autoMoveTimeoutId = null;
            }

            autoMovePath = [];
            currentPathIndex = 0;

            let targetDestination = null;
            let pathFunction = findPathBasic;
            let pathPenaltyEntities = [];

            const allEnemies = enemies;
            updateStaticCollectionsCache(); // Ensure cache is current
            const allPickups = cachedPickups;

            if (autoMode === 'auto') {
                console.log('Auto mode logic - Player health:', player.health, 'Enemies:', allEnemies.length, 'Pickups:', allPickups.length);
                // Simple auto mode strategy:
                // 1. If player health is low, prioritize nearby pickups
                // 2. If there are weak enemies (health <= player health), target them
                // 3. If there are pickups nearby, collect them
                // 4. Otherwise go to stairs
                
                const isPlayerLowHealth = player.health <= 10;
                const weakEnemies = allEnemies.filter(e => e.health <= player.health);
                const nearbyPickups = allPickups.filter(p => getDistance(player, p) <= 5);
                
                const closestWeakEnemy = getClosestEntity(weakEnemies, player);
                const closestNearbyPickup = getClosestEntity(nearbyPickups, player);
                const closestPickup = getClosestEntity(allPickups, player);

                console.log('Target analysis - Low health:', isPlayerLowHealth, 'Weak enemies:', weakEnemies.length, 'Nearby pickups:', nearbyPickups.length);

                if (isPlayerLowHealth && closestPickup) {
                    // Low health - prioritize any pickup
                    targetDestination = closestPickup;
                    pathPenaltyEntities = allEnemies; // Avoid all enemies when low health
                    console.log('Targeting pickup for low health at:', targetDestination.x, targetDestination.y);
                } else if (closestWeakEnemy) {
                    // Fight weak enemies for easy wins
                    targetDestination = closestWeakEnemy;
                    pathPenaltyEntities = allEnemies.filter(e => e.health > player.health); // Avoid strong enemies
                    console.log('Targeting weak enemy at:', targetDestination.x, targetDestination.y);
                } else if (closestNearbyPickup) {
                    // Collect nearby pickups when no weak enemies
                    targetDestination = closestNearbyPickup;
                    pathPenaltyEntities = allEnemies; // Avoid all enemies when collecting
                    console.log('Targeting nearby pickup at:', targetDestination.x, targetDestination.y);
                } else {
                    // Default: go to stairs
                    targetDestination = stairs;
                    pathPenaltyEntities = allEnemies; // Avoid enemies when heading to exit
                    console.log('Targeting stairs at:', targetDestination.x, targetDestination.y);
                }
                
                pathFunction = findPathWithProximityPenalty;
            }

            if (targetDestination) {
                console.log('Finding path to target:', targetDestination.x, targetDestination.y);
                // For auto-movement, entities should avoid certain obstacles.
                // If the target is stairs, stairs should NOT be an obstacle.
                const entitiesToAvoidForAutoMove = [...pathPenaltyEntities];
                if (targetDestination !== stairs && stairs) {
                    entitiesToAvoidForAutoMove.push(stairs);
                }
                const path = pathFunction(player.x, player.y, targetDestination.x, targetDestination.y, gameMap, dynamicMapWidth, dynamicMapHeight, entitiesToAvoidForAutoMove);
                console.log('Path found:', path ? `${path.length} steps` : 'null');
                if (path && path.length > 1) {
                    autoMovePath = path;
                    console.log('Executing first auto move step');
                    executeAutoMoveStep();
                } else {
                    // Fallback: try basic pathfinding to stairs
                    console.log("Auto mode: Primary pathfinding failed, trying basic pathfinding to stairs...");
                    let fallbackPath = findPathBasic(player.x, player.y, stairs.x, stairs.y, gameMap, dynamicMapWidth, dynamicMapHeight, []);
                    
                    if (fallbackPath && fallbackPath.length > 1) {
                        autoMovePath = fallbackPath;
                        executeAutoMoveStep();
                    } else {
                        console.warn("Auto mode: Even basic pathfinding failed, stopping auto-movement");
                        stopAutomatedMovement();
                    }
                }
            } else {
                console.warn("Auto mode: No target destination found, stopping auto-movement");
                stopAutomatedMovement();
            }
        }

        /**
         * Executes one step of the automated movement path for auto mode.
         * This function is called recursively by setTimeout.
         */
        function executeAutoMoveStep() {
            if (gameOver || autoMode === null) {
                stopAutomatedMovement();
                return;
            }

            if (!autoMovePath || autoMovePath.length === 0 || currentPathIndex >= autoMovePath.length) {
                // If path is exhausted or invalid, try to find a new path
                autoMoveTimeoutId = setTimeout(startAutomatedMovement, AUTO_MOVE_SPEED);
                return;
            }

            const nextPos = autoMovePath[currentPathIndex];
            const dx = nextPos.x - player.x;
            const dy = nextPos.y - player.y;

            const combatOccurred = movePlayer(dx, dy);

            if (gameOver) {
                stopAutomatedMovement();
                return;
            }

            const delay = combatOccurred ? COMBAT_MOVE_DELAY : AUTO_MOVE_SPEED;

            // Check if we need to recalculate the path
            let shouldRecalculate = false;
            
            // If the player didn't move to the expected position or combat occurred, recalculate
            if (player.x !== nextPos.x || player.y !== nextPos.y || combatOccurred) {
                shouldRecalculate = true;
            }

            if (shouldRecalculate) {
                autoMoveTimeoutId = setTimeout(startAutomatedMovement, delay);
                return;
            }

            currentPathIndex = currentPathIndex + 1; // Explicit assignment
            autoMoveTimeoutId = setTimeout(executeAutoMoveStep, delay);
        }

        /**
         * Handles keyboard input for player movement.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDown(event) {
            console.log('Key pressed:', event.key); // Debug: log every key press
            
            // If the game start overlay is active, any key press will dismiss it
            if (gameStartedOverlayActive) {
                gameStartedOverlayActive = false;
                event.preventDefault(); // Prevent default action for the key press
                return;
            }

            // Only process game input if the game is running (which it always is now after initial load)
            if (!isGameRunning) {
                return;
            }

            // Stop auto mode on any key press except A
            if (autoMode !== null && 
                event.key !== 'a' && event.key !== 'A') {
                stopAutomatedMovement();
                // Continue processing the key press for manual control
            }

            if (event.key === 'a' || event.key === 'A') {
                console.log('=== A KEY DETECTED ===');
                event.preventDefault();
                console.log('A key pressed. Current autoMode:', autoMode);
                if (autoMode === 'auto') {
                    console.log('Stopping auto mode');
                    stopAutomatedMovement();
                } else {
                    console.log('Starting auto mode');
                    stopAutomatedMovement();
                    autoMode = 'auto';
                    startAutomatedMovement();
                }
                return;
            }

            // World switching controls (1-9 keys)
            if (['1','2','3','4','5','6','7','8','9'].includes(event.key)) {
                event.preventDefault();
                const worldNumber = parseInt(event.key);
                
                // Check if world exists and is unlocked (temporarily unlock all for testing)
                if (WORLDS[worldNumber] && worldNumber !== currentWorld) {
                    currentWorld = worldNumber;
                    // Temporarily unlock all worlds for testing
                    unlockedWorlds = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                    setupWorldColors();
                    initGame(true, false); // Restart game in new world
                    console.log(`Switched to world ${worldNumber}: ${WORLDS[worldNumber].name}`);
                }
                return;
            }

            if (gameOver) {
                event.preventDefault();
                return;
            }

            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                    // Removed 'a' and 'A' from left movement since A is now auto mode
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    movePlayer(1, 0);
                    break;
            }
        }

        // Controller/Gamepad Support Variables
        let gamepadIndex = -1;
        let lastGamepadState = {
            buttons: [],
            axes: []
        };
        const GAMEPAD_DEADZONE = 0.3;
        const GAMEPAD_POLL_INTERVAL = 16; // ~60fps polling

        /**
         * Detects connected gamepads and sets up gamepad support
         */
        function detectGamepad() {
            const gamepads = navigator.getGamepads();
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i]) {
                    gamepadIndex = i;
                    console.log(`Gamepad connected: ${gamepads[i].id}`);
                    break;
                }
            }
        }

        /**
         * Handles gamepad input polling
         */
        function handleGamepadInput() {
            if (gamepadIndex === -1) return;

            const gamepad = navigator.getGamepads()[gamepadIndex];
            if (!gamepad) {
                gamepadIndex = -1;
                return;
            }

            // Handle D-pad and analog stick movement
            let dx = 0;
            let dy = 0;

            // D-pad (buttons 12, 13, 14, 15 are standard D-pad)
            if (gamepad.buttons[12] && gamepad.buttons[12].pressed) dy = -1; // Up
            if (gamepad.buttons[13] && gamepad.buttons[13].pressed) dy = 1;  // Down
            if (gamepad.buttons[14] && gamepad.buttons[14].pressed) dx = -1; // Left
            if (gamepad.buttons[15] && gamepad.buttons[15].pressed) dx = 1;  // Right

            // Left analog stick (axes 0 and 1)
            if (Math.abs(gamepad.axes[0]) > GAMEPAD_DEADZONE) {
                if (gamepad.axes[0] > GAMEPAD_DEADZONE) dx = 1;
                else if (gamepad.axes[0] < -GAMEPAD_DEADZONE) dx = -1;
            }
            if (Math.abs(gamepad.axes[1]) > GAMEPAD_DEADZONE) {
                if (gamepad.axes[1] > GAMEPAD_DEADZONE) dy = 1;
                else if (gamepad.axes[1] < -GAMEPAD_DEADZONE) dy = -1;
            }

            // Only move if there's input and it's different from last frame
            if ((dx !== 0 || dy !== 0) && !gameOver) {
                const currentInput = `${dx},${dy}`;
                const lastInput = `${lastGamepadState.dx || 0},${lastGamepadState.dy || 0}`;
                
                // Only process movement if it's a new input or enough time has passed
                if (currentInput !== lastInput || !lastGamepadState.lastMoveTime || 
                    performance.now() - lastGamepadState.lastMoveTime > 150) {
                    movePlayer(dx, dy);
                    lastGamepadState.lastMoveTime = performance.now();
                }
                lastGamepadState.dx = dx;
                lastGamepadState.dy = dy;
            } else {
                lastGamepadState.dx = 0;
                lastGamepadState.dy = 0;
            }

            // Handle automation mode buttons
            // X button (button 2) - Toggle stairs mode
            if (gamepad.buttons[2] && gamepad.buttons[2].pressed && !lastGamepadState.buttons[2]) {
                if (autoMode === 'stairs') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'stairs';
                    startAutomatedMovement();
                }
            }

            // Y button (button 3) - Toggle enemies mode
            if (gamepad.buttons[3] && gamepad.buttons[3].pressed && !lastGamepadState.buttons[3]) {
                if (autoMode === 'enemies') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'enemies';
                    startAutomatedMovement();
                }
            }

            // A button (button 0) - Toggle high score mode
            if (gamepad.buttons[0] && gamepad.buttons[0].pressed && !lastGamepadState.buttons[0]) {
                if (autoMode === 'highScore') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'highScore';
                    startAutomatedMovement();
                }
            }

            // B button (button 1) - Toggle survival mode
            if (gamepad.buttons[1] && gamepad.buttons[1].pressed && !lastGamepadState.buttons[1]) {
                if (autoMode === 'survival') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'survival';
                    startAutomatedMovement();
                }
            }

            // Start button (button 9) - Restart game when game over
            if (gameOver && gamepad.buttons[9] && gamepad.buttons[9].pressed && !lastGamepadState.buttons[9]) {
                // Trigger restart animation and game restart
                const restartText = "PRESS R TO RESTART";
                const baseFontSize = Math.floor(dynamicTileSize * 0.8);
                ctx.font = `${baseFontSize}px VT323`;
                const textMetrics = ctx.measureText(restartText);
                const textWidth = textMetrics.width;

                const textX = gameCanvas.width / 2;
                const textY = gameCanvas.height / 2 + dynamicTileSize * 1.5;

                // Generate particles for each character
                restartTextParticles = [];
                let currentTextX = textX - textWidth / 2;
                const charSpacing = textWidth / restartText.length;

                for (let i = 0; i < restartText.length; i++) {
                    const char = restartText[i];
                    const charX = currentTextX + charSpacing * i + charSpacing / 2;
                    const charY = textY;

                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 0.5 + 0.2) * (dynamicTileSize / 20);
                    const dirX = Math.cos(angle);
                    const dirY = Math.sin(angle);
                    const fadeFactor = Math.random() * 0.7 + 0.3;

                    restartTextParticles.push({
                        char: char,
                        startX: charX,
                        startY: charY,
                        dirX: dirX,
                        dirY: dirY,
                        initialSpeed: speed,
                        fontSize: baseFontSize,
                        color: '#FFD700',
                        startTime: performance.now(),
                        duration: RESTART_TEXT_EXPLOSION_DURATION,
                        fadeFactor: fadeFactor
                    });
                }

                restartTextAnimationActive = true;
                restartTextAnimationStartTime = performance.now();
                restartGame();
            }

            // Any face button - Dismiss game start overlay
            if (gameStartedOverlayActive && 
                ((gamepad.buttons[0] && gamepad.buttons[0].pressed) ||
                 (gamepad.buttons[1] && gamepad.buttons[1].pressed) ||
                 (gamepad.buttons[2] && gamepad.buttons[2].pressed) ||
                 (gamepad.buttons[3] && gamepad.buttons[3].pressed))) {
                gameStartedOverlayActive = false;
            }

            // Store button states for next frame
            lastGamepadState.buttons = gamepad.buttons.map(button => button.pressed);
        }

        /**
         * Starts gamepad polling
         */
        function startGamepadPolling() {
            setInterval(() => {
                if (gamepadIndex === -1) {
                    detectGamepad();
                } else {
                    handleGamepadInput();
                }
            }, GAMEPAD_POLL_INTERVAL);
        }

        // Gamepad connection event listeners
        window.addEventListener('gamepadconnected', (e) => {
            console.log(`Gamepad connected: ${e.gamepad.id}`);
            gamepadIndex = e.gamepad.index;
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log(`Gamepad disconnected: ${e.gamepad.id}`);
            if (e.gamepad.index === gamepadIndex) {
                gamepadIndex = -1;
            }
        });

        /**
         * The main animation loop.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function animate(currentTime) {
            try {
                animationFrameId = requestAnimationFrame(animate);
                
                // Calculate field of vision every frame
                calculateFieldOfVision();
                
                drawGame();
            }
            catch (error) {
                console.error("Error in animation loop:", error);
                stopAnimationLoop(); // Stop the loop to prevent further errors
                handleGameOver(); // Attempt to gracefully end the game
            }
        }

        /**
         * Starts the animation loop.
         */
        function startAnimationLoop() {
            console.log('Starting animation loop...');
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(animate);
            console.log('Animation loop started with ID:', animationFrameId);
        }

        /**
         * Stops the animation loop.
         */
        function stopAnimationLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        /**
         * Calculates the current score.
         */
        function calculateScore() {
            let score = 0;
            if (stepsTaken > 0) {
                const averageDamagePerTurn = totalDamageDealt / stepsTaken;
                score = Math.floor(totalDamageDealt * averageDamagePerTurn);
            }
            return score;
        }

        /**
         * Loads high scores from local storage. (Function kept for potential future use, not currently displayed)
         */
        function loadHighScores() {
            const storedScores = localStorage.getItem(HIGH_SCORES_STORAGE_KEY);
            if (storedScores) {
                highScores = JSON.parse(storedScores);
            } else {
                highScores = [];
            }
        }

        /**
         * Saves high scores to local storage. (Function kept for potential future use, not currently displayed)
         */
        function saveHighScores() {
            localStorage.setItem(HIGH_SCORES_STORAGE_KEY, JSON.stringify(highScores));
        }

        /**
         * Adds a new score to the high scores list. (Function kept for potential future use, not currently displayed)
         * @param {string} name - Player's name.
         * @param {number} score - Player's score.
         */
        function addHighScore(name, score) {
            highScores.push({ name: name, score: score });
            highScores.sort((a, b) => b.score - a.score); // Sort descending
            highScores = highScores.slice(0, MAX_HIGH_SCORES); // Keep only top N
            saveHighScores();
        }

        /**
         * Calculates the target dynamicTileSize for a given level based on current canvas dimensions.
         * @param {number} level - The level for which to calculate the target tile size.
         * @returns {number} The calculated target tile size.
         */
        function calculateTargetTileSize(level) {
            const initialMaxTileSize = Math.floor(Math.min(gameCanvas.width / MAX_VISIBLE_TILES_LEVEL1, gameCanvas.height / MAX_VISIBLE_TILES_LEVEL1));
            const finalMinTileSize = Math.floor(Math.min(gameCanvas.width / MIN_VISIBLE_TILES_MAX_LEVEL, gameCanvas.height / MIN_VISIBLE_TILES_MAX_LEVEL));
            let calculated = initialMaxTileSize - ((Math.min(level, ZOOM_LEVELS_EFFECTIVE) - 1) * (initialMaxTileSize - finalMinTileSize) / (ZOOM_LEVELS_EFFECTIVE - 1));
            return Math.max(finalMinTileSize, Math.floor(calculated));
        }

        /**
         * Gets the player's location using geolocation and IP-based lookup
         */
        async function getPlayerLocation() {
            try {
                // Try IP-based location first (more reliable and no API key needed)
                await getLocationByIP();
                updateLeaderboard();
            } catch (error) {
                console.log('All location detection methods failed:', error);
                playerLocation = { city: 'Unknown', country: 'Unknown' };
                updateLeaderboard();
            }
        }

        /**
         * Gets player location based on IP address using multiple fallback services
         */
        async function getLocationByIP() {
            const services = [
                // Try ipapi.co first
                async () => {
                    const response = await fetch('https://ipapi.co/json/');
                    const data = await response.json();
                    return {
                        city: data.city || 'Unknown',
                        country: data.country_name || 'Unknown'
                    };
                },
                // Fallback to ip-api.com
                async () => {
                    const response = await fetch('http://ip-api.com/json/');
                    const data = await response.json();
                    return {
                        city: data.city || 'Unknown',
                        country: data.country || 'Unknown'
                    };
                },
                // Fallback to ipinfo.io
                async () => {
                    const response = await fetch('https://ipinfo.io/json');
                    const data = await response.json();
                    return {
                        city: data.city || 'Unknown',
                        country: data.country || 'Unknown'
                    };
                }
            ];

            for (let i = 0; i < services.length; i++) {
                try {
                    console.log(`Trying location service ${i + 1}...`);
                    const result = await services[i]();
                    if (result.city !== 'Unknown' || result.country !== 'Unknown') {
                        playerLocation.city = result.city;
                        playerLocation.country = result.country;
                        console.log(`Location found: ${result.city}, ${result.country}`);
                        return;
                    }
                } catch (error) {
                    console.log(`Location service ${i + 1} failed:`, error);
                    continue;
                }
            }
            
            // If all services fail
            throw new Error('All location services failed');
        }

        /**
         * Loads the leaderboard from localStorage
         */
        function loadLeaderboard() {
            const saved = localStorage.getItem('hardDivisionLeaderboard');
            if (saved) {
                leaderboard = JSON.parse(saved);
                // Remove any existing duplicates
                removeDuplicatesFromLeaderboard();
            } else {
                // Initialize with some sample scores
                leaderboard = [
                    { name: 'Anonymous', city: 'New York', country: 'USA', score: 1500 },
                    { name: 'Anonymous', city: 'London', country: 'UK', score: 1350 },
                    { name: 'Anonymous', city: 'Tokyo', country: 'Japan', score: 1200 },
                    { name: 'Anonymous', city: 'Berlin', country: 'Germany', score: 1100 },
                    { name: 'Anonymous', city: 'Sydney', country: 'Australia', score: 1000 },
                    { name: 'Anonymous', city: 'Toronto', country: 'Canada', score: 950 },
                    { name: 'Anonymous', city: 'Paris', country: 'France', score: 900 },
                    { name: 'Anonymous', city: 'Seoul', country: 'South Korea', score: 850 },
                    { name: 'Anonymous', city: 'Mumbai', country: 'India', score: 800 },
                    { name: 'Anonymous', city: 'São Paulo', country: 'Brazil', score: 750 }
                ];
            }
        }

        /**
         * Removes duplicate entries from the leaderboard
         */
        function removeDuplicatesFromLeaderboard() {
            const uniqueEntries = [];
            const seen = new Map();

            for (const entry of leaderboard) {
                // Create multiple keys to catch different types of duplicates
                const exactKey = `${entry.name}-${entry.city}-${entry.country}-${entry.score}`;
                const nameScoreKey = `${entry.name}-${entry.score}`;
                const locationScoreKey = `${entry.city}-${entry.country}-${entry.score}`;
                
                // Check if this is an exact duplicate
                if (seen.has(exactKey)) {
                    continue; // Skip exact duplicate
                }
                
                // For Anonymous entries with same score from same location, keep only one
                if (entry.name === 'Anonymous') {
                    if (seen.has(locationScoreKey)) {
                        continue; // Skip duplicate anonymous entry
                    }
                    seen.set(locationScoreKey, true);
                }
                
                // For named players, don't allow same score twice
                if (entry.name !== 'Anonymous' && seen.has(nameScoreKey)) {
                    continue; // Skip duplicate score for same player
                }
                
                seen.set(exactKey, true);
                seen.set(nameScoreKey, true);
                uniqueEntries.push(entry);
            }

            if (uniqueEntries.length !== leaderboard.length) {
                console.log(`Removed ${leaderboard.length - uniqueEntries.length} duplicate entries from leaderboard`);
                leaderboard = uniqueEntries;
                leaderboard.sort((a, b) => b.score - a.score);
                leaderboard = leaderboard.slice(0, 10); // Keep only top 10
                saveLeaderboard(); // Save the cleaned leaderboard
            }
        }

        /**
         * Saves the leaderboard to localStorage
         */
        function saveLeaderboard() {
            localStorage.setItem('hardDivisionLeaderboard', JSON.stringify(leaderboard));
        }

        /**
         * Updates the leaderboard display
         */
        function updateLeaderboard() {
            const content = document.getElementById('leaderboard-content');
            if (!content) return;

            let html = '';
            leaderboard.forEach((entry, index) => {
                // Truncate city name if too long
                const maxCityLength = 8;
                const truncatedCity = entry.city.length > maxCityLength ? 
                    entry.city.substring(0, maxCityLength - 2) + '..' : 
                    entry.city;
                
                // Create a short country abbreviation for display
                const countryAbbrev = entry.country.length > 8 ? 
                    entry.country.substring(0, 3).toUpperCase() : 
                    entry.country.substring(0, 4).toUpperCase();
                
                // Combine city and country with length limit
                const locationText = `${truncatedCity},${countryAbbrev}`;
                const maxLocationLength = 16;
                const finalLocation = locationText.length > maxLocationLength ?
                    locationText.substring(0, maxLocationLength - 2) + '..' :
                    locationText;
                
                html += `
                    <div class="leaderboard-entry">
                        <span class="leaderboard-rank">${index + 1}.</span>
                        <span class="leaderboard-name">${entry.name}</span>
                        <span class="leaderboard-city">${finalLocation}</span>
                        <span class="leaderboard-score">${entry.score}</span>
                    </div>
                `;
            });
            content.innerHTML = html;
            
            // Update the top bar high score display
            updateScoreDisplay();
        }

        /**
         * Adds a score to the leaderboard
         */
        function addToLeaderboard(score) {
            // Use the current player's name from their run
            const currentPlayerName = player && player.name ? player.name : 'Anonymous';

            const newEntry = {
                name: currentPlayerName,
                city: playerLocation.city,
                country: playerLocation.country,
                score: score
            };

            // Check for duplicate entries (same player, same score, same location)
            const isDuplicate = leaderboard.some(entry => 
                entry.name === newEntry.name &&
                entry.city === newEntry.city &&
                entry.country === newEntry.country &&
                entry.score === newEntry.score
            );

            if (isDuplicate) {
                console.log("Duplicate leaderboard entry detected, skipping.");
                return;
            }

            leaderboard.push(newEntry);
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 10); // Keep only top 10

            saveLeaderboard();
            updateLeaderboard();
        }

        /**
         * Initializes the game for a new level or a new game.
         * @param {boolean} resetGameStats - Whether to reset all game statistics.
         * @param {boolean} showGameStartOverlay - Whether to show the "HARD DIVISION" overlay.
         */
        function initGame(resetGameStats = true, showGameStartOverlay = false) {
            console.log('=== initGame() called ===', { resetGameStats, showGameStartOverlay });
            const wasGameOver = gameOver; // Capture state before resetting gameOver
            gameOver = false;
            // Remove any existing event listener before adding a new one
            window.removeEventListener('keydown', handleKeyDown);
            window.addEventListener('keydown', handleKeyDown);
            
            console.log('About to check currentLevel and reset stats...');
            // Ensure currentLevel has a valid value before using it
            if (resetGameStats || currentLevel === undefined || currentLevel === null) {
                currentLevel = 1; // Initialize currentLevel first
                console.log('Set currentLevel to:', currentLevel);
                // Check for world progression on new game
                if (resetGameStats) {
                    checkAndUnlockWorlds();
                }
            }
            
            console.log('About to setup world colors...');
            // Set up world-specific colors and theme
            setupWorldColors();
            
            // Set initial map dimensions based on current level
            const BASE_MAP_DIMENSION = 7;
            dynamicMapWidth = BASE_MAP_DIMENSION + Math.floor((currentLevel - 1) * 0.5);
            dynamicMapHeight = BASE_MAP_DIMENSION + Math.floor((currentLevel - 1) * 0.5);
            
            const MAX_MAP_DIMENSION = 60;
            dynamicMapWidth = Math.min(dynamicMapWidth, MAX_MAP_DIMENSION);
            dynamicMapHeight = Math.min(dynamicMapHeight, MAX_MAP_DIMENSION);

            // Initialize visited tiles grid
            visitedTiles = Array(dynamicMapHeight).fill(null).map(() => Array(dynamicMapWidth).fill(false));
            
            // Initialize core game objects
            if (!player) {
                player = { 
                    x: 0, 
                    y: 0, 
                    health: 1, 
                    name: generateAgentName(), 
                    id: 'player_' + Math.random().toString(36).substr(2, 9),
                    healthAnimScale: 1, 
                    healthAnimStartTime: 0, 
                    thrustAnimActive: false, 
                    thrustAnimStartTime: 0, 
                    thrustAnimDirectionX: 0, 
                    thrustAnimDirectionY: 0, 
                    thrustAnimMagnitude: 0, 
                    lowestHealthReached: PLAYER_VISUAL_HEALTH_THRESHOLD, 
                    wasLowHealth: false, 
                    thrustAnimDuration: 200 
                };
                // Generate hair for player
                player.hair = generateHairStyle(player.id);
                player.head = generateHeadStyle(player.id);
                player.eyes = generateEyeStyle(player.id);
            }
            
            if (!stairs) {
                stairs = { x: 0, y: 0 };
            }
            
            if (!enemies) {
                enemies = [];
            }
            
            if (resetGameStats) {
                player.x = 0; // Reset player position
                player.y = 0;
                // currentLevel already set above
                player.health = 1; // Set player health to 1 for new game/restart
                hitsDealt = 0;
                hitsTaken = 0;
                stepsTaken = 0;
                totalDamageDealt = 0;
                autoMode = null;
                // Reset death animation states
                deathAnimationActive = false;
                deathAnimationStartTime = 0;
                timeScale = 1;
                gameStartedOverlayActive = showGameStartOverlay; // This controls the fading overlay
                if (showGameStartOverlay) {
                    gameStartedOverlayStartTime = performance.now();
                    // Keep top bar visible even during title overlay
                    showTopBar(); // Show top bar from the beginning
                    resizeCanvas(); // Ensure canvas is full-screen for title display
                } else {
                    showTopBar(); // Show top bar during normal gameplay
                }

                // IMPORTANT: Do NOT reset restartTextAnimationActive or restartTextParticles here
                // if we are coming from a game over state, as the animation needs to play out.
                // The drawGame loop will clear them once the animation duration is over.
                if (!wasGameOver) { // Only clear if it's a fresh start, not a restart from game over
                    restartTextAnimationActive = false;
                    restartTextParticles = [];
                }

                // Reset event tracking flags and history for a new game
                for (const key in eventFlags) {
                    eventFlags[key] = false;
                }
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
                player.wasLowHealth = false;

                // Reset activity log for new game
                activityLog = [];

            } else {
                // Heal player by current level number when advancing to a new level
                player.health = player.health + currentLevel; // Explicit assignment
                player.healthAnimScale = 1.5; // Trigger health animation
                player.healthAnimStartTime = performance.now();
                gameStartedOverlayActive = false; // Ensure it's off for level progression
            }
            player.healthAnimScale = 1;
            player.healthAnimStartTime = 0;
            activeDamageTextAnimations = [];
            activeExplosions = [];
            activePickupAnimations = []; // Reset pickup animations for new level
            staticDamageNumbers = []; // Clear all static pickups for new level/game
            activeEventMessages = []; // Clear active event messages

            // Reset per-turn stats
            enemiesKilledThisTurn = 0;
            killedEnemiesThisTurn = []; // Reset killed enemies tracking
            damageDealtThisTurn = 0;
            hitsTakenThisTurn = 0;
            totalPickupValueCollectedThisTurn = 0;
            combatOccurredThisTurn = false; // Reset for new level
            playerTookDamageInCombatThisTurn = false; // Reset for new level

            const targetDynamicTileSizeForLevel = calculateTargetTileSize(currentLevel);

            if (resetGameStats) {
                // For a new game/restart, start zoomed in
                // Increase GAME_START_INITIAL_ZOOM_FACTOR for more zoom
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel * GAME_START_INITIAL_ZOOM_FACTOR);
                gameStartZoomActive = true;
                gameStartZoomStartTime = performance.now();
            } else {
                // For level progression, just set to the target size immediately
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel);
                gameStartZoomActive = false; // Ensure it's off for level progression
            }

            // Update map dimensions based on current level (using original smaller size)
            // Back to original size: base size 7, scaling 0.5, max 60
            dynamicMapWidth = Math.min(
                7 + Math.floor((currentLevel - 1) * 0.5),
                60
            );
            dynamicMapHeight = Math.min(
                7 + Math.floor((currentLevel - 1) * 0.5),
                60
            );

            console.log(`Map dimensions: ${dynamicMapWidth}x${dynamicMapHeight}, level: ${currentLevel}`);

            // Initialize visitedTiles grid
            visitedTiles = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(false));


            console.log(`Initializing Level ${currentLevel}. Map dimensions: ${dynamicMapWidth}x${dynamicMapHeight}`);

            let attempts = 0;
            const MAX_ATTEMPTS = 1000; // Max attempts to generate a connected map
            let mapGeneratedSuccessfully = false;

            // Map generation always happens now, as the game starts directly
            do {
                console.log(`Level ${currentLevel} - World ${currentWorld} (${getCurrentWorld().name}) - Map generation attempt: ${attempts + 1}`);
                initializeMap();
                generateWorldMap();

                // Initialize field of vision system after map generation
                initializeVisibilityMap();

                // Validate map has floor tiles
                let floorTilesFound = false;
                for (let y = 0; y < dynamicMapHeight; y++) {
                    for (let x = 0; x < dynamicMapWidth; x++) {
                        if (gameMap[y][x] === TILE_FLOOR) {
                            floorTilesFound = true;
                            break;
                        }
                    }
                    if (floorTilesFound) break;
                }
                
                if (!floorTilesFound) {
                    console.error("No floor tiles generated - retrying map generation");
                    continue;
                }

                // Place player
                findPlayerStartInCorner(); // This function now ensures player is on a floor tile
                
                // Validate player position
                if (player.x === undefined || player.y === undefined || 
                    player.x === null || player.y === null ||
                    !gameMap[player.y] || gameMap[player.y][player.x] !== TILE_FLOOR) {
                    console.error("Invalid player placement - retrying map generation");
                    continue;
                }

                // Mark player's starting tile as visited
                if (visitedTiles[player.y] && visitedTiles[player.y][player.x] !== undefined) {
                    visitedTiles[player.y][player.x] = true;
                }
                console.log(`Player placed at (${player.x}, ${player.y})`);

                // Place stairs
                placeStairsOppositeCorner(); // This function now ensures stairs are on a stairs tile
                console.log(`Stairs placed at (${stairs.x}, ${stairs.y})`);

                // Calculate player's average flow for new enemies
                const playerAverageFlowForNewEnemies = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0;

                // Spawn enemies
                // For level 1, pass 0 as levelHealthBonus to ensure enemy starts with 1 health
                // For other levels, pass player.health as before
                spawnEnemies(currentLevel === 1 ? 0 : player.health, playerAverageFlowForNewEnemies);

                // Spawn pickups for the current level
                spawnPickups();

                // Check path from player to stairs
                if (player.x !== undefined && player.y !== undefined && stairs.x !== undefined && stairs.y !== undefined) {
                    mapGeneratedSuccessfully = findPathBasic(player.x, player.y, stairs.x, stairs.y, gameMap, dynamicMapWidth, dynamicMapHeight, enemies) !== null;
                    console.log(`Path from player to stairs exists: ${mapGeneratedSuccessfully}`);
                } else {
                    mapGeneratedSuccessfully = false; // Cannot check path if player/stairs not valid
                    console.warn("Player or stairs not valid, map generation considered unsuccessful.");
                }

                attempts = attempts + 1; // Explicit assignment
                if (!mapGeneratedSuccessfully && attempts >= MAX_ATTEMPTS) {
                    console.warn(`Max map generation attempts (${MAX_ATTEMPTS}) reached for Level ${currentLevel}. Attempting to force a path.`);
                    // Force a path by creating a direct line of floor tiles from player to stairs
                    let currentPathX = player.x;
                    let currentPathY = player.y;
                    let pathSteps = 0;
                    const MAX_PATH_FORCING_STEPS = dynamicMapWidth * dynamicMapHeight * 2; // Safeguard

                    while ((currentPathX !== stairs.x || currentPathY !== stairs.y) && pathSteps < MAX_PATH_FORCING_STEPS) {
                        // Ensure current position is floor
                        if (gameMap[currentPathY] && gameMap[currentPathY][currentPathX] !== undefined) {
                            gameMap[currentPathY][currentPathX] = TILE_FLOOR;
                        }

                        const dx = stairs.x - currentPathX;
                        const dy = stairs.y - currentPathY;

                        if (dx !== 0 && dy !== 0) { // If both X and Y need to change
                            if (Math.abs(dx) > Math.abs(dy)) {
                                currentPathX = currentPathX + Math.sign(dx); // Explicit assignment
                            } else {
                                currentPathY = currentPathY + Math.sign(dy); // Explicit assignment
                            }
                        } else if (dx !== 0) { // Only X needs to change
                            currentPathX = currentPathX + Math.sign(dx); // Explicit assignment
                        } else if (dy !== 0) { // Only Y needs to change
                            currentPathY = currentPathY + Math.sign(dy); // Explicit assignment
                        }

                        // Ensure bounds for forced path
                        currentPathX = Math.max(0, Math.min(dynamicMapWidth - 1, currentPathX));
                        currentPathY = Math.max(0, Math.min(dynamicMapHeight - 1, currentPathY));

                        // Ensure the new step is floor, unless it's the stairs
                        if (currentPathX === stairs.x && currentPathY === stairs.y) {
                             gameMap[currentPathY][currentPathX] = TILE_STAIRS;
                        } else if (gameMap[currentPathY] && gameMap[currentPathY][currentPathX] !== undefined) {
                             gameMap[currentPathY][currentPathX] = TILE_FLOOR;
                        }
                        pathSteps = pathSteps + 1; // Explicit assignment
                    }
                    if (pathSteps >= MAX_PATH_FORCING_STEPS) {
                        console.error("Forced path generation hit max steps, likely stuck in an infinite loop logic. This should not happen with the new logic.");
                        // Fallback: Ensure stairs is at least TILE_STAIRS if loop exited prematurely
                        if (gameMap[stairs.y] && gameMap[stairs.y][stairs.x] !== undefined) {
                            gameMap[stairs.y][stairs.x] = TILE_STAIRS;
                        }
                    } else {
                        gameMap[stairs.y][stairs.x] = TILE_STAIRS; // Ensure stairs are still stairs at the end
                    }
                    mapGeneratedSuccessfully = true; // Path is now guaranteed
                    console.log("Forced a path from player to stairs.");
                }
            } while (!mapGeneratedSuccessfully);

            setupColors();
            // Animation loop is already started, no need to call startAnimationLoop() here.
            // It's continuously drawing the game.

            // If an auto-mode was active before initGame, restart it for the new level
            if (autoMode !== null) {
                startAutomatedMovement();
            }
        }

        // Handle canvas resizing for responsiveness
        function resizeCanvas() {
            // Get container dimensions
            const gameContainer = document.getElementById('gameContainer');
            const canvas = document.getElementById('gameCanvas');
            
            if (!gameContainer || !canvas) {
                console.error('Required elements not found:', { 
                    gameContainer: !!gameContainer, 
                    canvas: !!canvas 
                });
                return;
            }

            // Force truly fullscreen dimensions
            const canvasWidth = Math.max(window.innerWidth, document.documentElement.clientWidth);
            const canvasHeight = Math.max(window.innerHeight, document.documentElement.clientHeight);
            
            // Set the container dimensions to fullscreen
            gameContainer.style.width = `${canvasWidth}px`;
            gameContainer.style.height = `${canvasHeight}px`;
            gameContainer.style.position = 'fixed';
            gameContainer.style.top = '0';
            gameContainer.style.left = '0';
            
            // Set the canvas dimensions to fullscreen
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.width = `${canvasWidth}px`;
            canvas.style.height = `${canvasHeight}px`;

            // Calculate new tile size
            const targetDynamicTileSizeForLevel = calculateTargetTileSize(currentLevel);

            // Update the tile size
            if (gameStartZoomActive) {
                // Let the zoom animation handle the tile size
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel * GAME_START_INITIAL_ZOOM_FACTOR);
            } else {
                // Set tile size directly
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel);
            }

            // Force a redraw
            drawGame();
        }

        // Wait for the DOM to be fully loaded before initializing
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded - Initializing game...');
            
            // Get canvas element and context
            gameCanvas = document.getElementById('gameCanvas');
            if (!gameCanvas) {
                console.error('Canvas element not found!');
                return;
            }
            
            ctx = gameCanvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context!');
                return;
            }
            
            console.log('Canvas and context successfully obtained');
            
            // AGGRESSIVELY Force canvas background to be black using every method
            gameCanvas.style.backgroundColor = '#000000';
            gameCanvas.style.background = '#000000';
            gameCanvas.setAttribute('style', 'background-color: #000000 !important; background: #000000 !important;');
            
            // Also force the parent elements
            const gameContainer = document.getElementById('gameContainer');
            if (gameContainer) {
                gameContainer.style.backgroundColor = '#000000';
                gameContainer.style.background = '#000000';
            }
            
            // Clear the canvas immediately to black
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            // Initialize leaderboard and get player location
            loadLeaderboard();
            
            // Load total player score for world progression
            const savedScore = localStorage.getItem('hardDivisionTotalScore');
            if (savedScore) {
                totalPlayerScore = parseInt(savedScore);
            }
            checkAndUnlockWorlds();
            
            // Set initial background color based on current world
            updateBackgroundColor();
            
            console.log('About to update leaderboard and initialize game...');
            console.log('Canvas element found:', gameCanvas ? 'YES' : 'NO');
            console.log('Context obtained:', ctx ? 'YES' : 'NO');
            
            // Show leaderboard immediately with current data
            updateLeaderboard();
            
            // Show the top bar (menu bar) immediately from the beginning
            showTopBar();
            
            // Get player location (this will update leaderboard again once location is found)
            getPlayerLocation(); 
            
            // Initialize the game
            console.log('Calling initGame...');
            initGame(true, true); // Reset game stats and show overlay
            
            // Set up event listeners (keydown is handled in initGame)
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize message filter system
            initializeMessageFilters();
            
            // Initialize gamepad support
            startGamepadPolling();
            detectGamepad();
            
            // Initial canvas resize
            resizeCanvas();
            
            // Start the animation loop
            startAnimationLoop();
            
            console.log('Game initialization complete');
        });

        // Top 10 Scores dropdown functionality
        function toggleTop10() {
            const content = document.getElementById('top10Content');
            const isVisible = content.classList.contains('show');
            
            if (isVisible) {
                content.classList.remove('show');
            } else {
                updateTop10Display();
                content.classList.add('show');
            }
        }

        // Update the top 10 scores display
        function updateTop10Display() {
            const list = document.getElementById('top10List');
            
            if (leaderboard.length === 0) {
                list.innerHTML = `
                    <div class="top10-entry">
                        <span class="top10-rank">-</span>
                        <span class="top10-name-location">Play a game to set your first score!</span>
                        <span class="top10-score">-</span>
                    </div>
                `;
                return;
            }
            
            let html = '';
            for (let i = 0; i < Math.min(10, leaderboard.length); i++) {
                const entry = leaderboard[i];
                
                // Format location similar to original leaderboard
                const maxCityLength = 8;
                const truncatedCity = entry.city.length > maxCityLength ? 
                    entry.city.substring(0, maxCityLength - 2) + '..' : 
                    entry.city;
                
                const countryAbbrev = entry.country.length > 8 ? 
                    entry.country.substring(0, 3).toUpperCase() : 
                    entry.country.substring(0, 4).toUpperCase();
                
                const locationText = `${truncatedCity},${countryAbbrev}`;
                
                html += `
                    <div class="top10-entry">
                        <span class="top10-rank">${i + 1}.</span>
                        <span class="top10-name-location">
                            <span class="top10-name">${entry.name}</span>
                            <span class="top10-location">${locationText}</span>
                        </span>
                        <span class="top10-score">${entry.score}</span>
                    </div>
                `;
            }
            list.innerHTML = html;
        }

        // Update current score display
        function updateScoreDisplay() {
            const currentScoreSpan = document.getElementById('currentScore');
            const highScoreSpan = document.getElementById('highScore');
            
            if (currentScoreSpan) {
                currentScoreSpan.textContent = calculateScore();
            }
            
            if (highScoreSpan) {
                const highScore = leaderboard.length > 0 ? leaderboard[0].score : 0;
                highScoreSpan.textContent = highScore;
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.querySelector('.top10-dropdown');
            const content = document.getElementById('top10Content');
            
            if (dropdown && !dropdown.contains(event.target)) {
                content.classList.remove('show');
            }
        });

        // Initial score display update
        document.addEventListener('DOMContentLoaded', function() {
            updateScoreDisplay();
            setInterval(updateScoreDisplay, 1000); // Update score every second
        });

        // Top bar visibility control
        function showTopBar() {
            const topBar = document.getElementById('topBar');
            if (topBar) {
                topBar.classList.add('visible');
            }
        }

        function hideTopBar() {
            const topBar = document.getElementById('topBar');
            if (topBar) {
                topBar.classList.remove('visible');
            }
        }
    </script>
</body>
</html>
